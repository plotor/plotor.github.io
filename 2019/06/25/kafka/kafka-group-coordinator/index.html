<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="在 Kafka 的设计中，消费者一般都有一个 group 的概念（当然，也存在不属于任何 group 的消费者），将多个消费者组织成一个 group 可以提升消息的消费处理能力，同时又能保证消息消费的顺序性，不重复或遗漏消费。一个 group 名下的消费者包含一个 leader 角色和多个 follower 角色，虽然在消费消息方面这两类角色是等价的，但是 leader 角色相对于 followe">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka 源码解析：Group 协调管理机制">
<meta property="og:url" content="https://plotor.github.io/2019/06/25/kafka/kafka-group-coordinator/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="在 Kafka 的设计中，消费者一般都有一个 group 的概念（当然，也存在不属于任何 group 的消费者），将多个消费者组织成一个 group 可以提升消息的消费处理能力，同时又能保证消息消费的顺序性，不重复或遗漏消费。一个 group 名下的消费者包含一个 leader 角色和多个 follower 角色，虽然在消费消息方面这两类角色是等价的，但是 leader 角色相对于 followe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://plotor.github.io/images/2019/kafka-group-state.png">
<meta property="og:image" content="https://plotor.github.io/images/2019/kafka-group-rebalance.png">
<meta property="article:published_time" content="2019-06-25T06:36:19.000Z">
<meta property="article:modified_time" content="2025-04-19T07:21:55.043Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://plotor.github.io/images/2019/kafka-group-state.png"><title>Kafka 源码解析：Group 协调管理机制 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2019/06/25/kafka/kafka-group-coordinator/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Kafka 源码解析：Group 协调管理机制</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-06-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">13.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">64分</span></span></div></header><div class="post-body"><p>在 Kafka 的设计中，消费者一般都有一个 group 的概念（当然，也存在不属于任何 group 的消费者），将多个消费者组织成一个 group 可以提升消息的消费处理能力，同时又能保证消息消费的顺序性，不重复或遗漏消费。一个 group 名下的消费者包含一个 leader 角色和多个 follower 角色，虽然在消费消息方面这两类角色是等价的，但是 leader 角色相对于 follower 角色还担负着管理整个 group 的职责。当 group 中有新的消费者加入，或者某个消费者因为一些原因退出当前 group 时，亦或是订阅的 topic 分区发生变化时，都需要为 group 名下的消费者重新分配分区，在服务端确定好分区分配策略之后，具体执行分区分配的工作则交由 leader 消费者负责，并在完成分区分配之后将分配结果反馈给服务端。<a id="more"></a></p>
<p>前面在分析消费者运行机制时曾多次提到 GroupCoordinator 类，本篇我们就来分析一下 GroupCoordinator 组件的作用和实现。GroupCoordinator 组件主要功能包括对隶属于同一个 group 的消费者进行分区分配、维护内部 offset topic，以及管理消费者和消费者所属的 group 信息等。集群中的每一个 broker 节点在启动时都会创建并启动一个 GroupCoordinator 实例，每个实例都会管理集群中所有消费者 group 的一个子集。</p>

        <h3 id="GroupCoordinator-组件的定义与启动">
          <a href="#GroupCoordinator-组件的定义与启动" class="heading-link"><i class="fas fa-link"></i></a>GroupCoordinator 组件的定义与启动</h3>
      <p>GroupCoordinator 类的字段定义如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupCoordinator</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">                       val brokerId: <span class="type">Int</span>, // 所属的 broker 节点的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">                       val groupConfig: <span class="type">GroupConfig</span>, // <span class="type">Group</span> 配置对象，记录了 group 中 session 过期的最小时长和最大时长，即超时时长的合法区间</span></span></span><br><span class="line"><span class="class"><span class="params">                       val offsetConfig: <span class="type">OffsetConfig</span>, // 记录 <span class="type">OffsetMetadata</span> 相关的配置项</span></span></span><br><span class="line"><span class="class"><span class="params">                       val groupManager: <span class="type">GroupMetadataManager</span>, // 负责管理 group 元数据以及对应的 offset 信息</span></span></span><br><span class="line"><span class="class"><span class="params">                       val heartbeatPurgatory: <span class="type">DelayedOperationPurgatory</span>[<span class="type">DelayedHeartbeat</span>], // 管理 <span class="type">DelayedHeartbeat</span> 延时任务的炼狱</span></span></span><br><span class="line"><span class="class"><span class="params">                       val joinPurgatory: <span class="type">DelayedOperationPurgatory</span>[<span class="type">DelayedJoin</span>], // 管理 <span class="type">DelayedJoin</span> 延时任务的炼狱</span></span></span><br><span class="line"><span class="class"><span class="params">                       time: <span class="type">Time</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 标识当前 GroupCoordinator 实例是否启动 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> isActive = <span class="keyword">new</span> <span class="type">AtomicBoolean</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略方法定义</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>其中 GroupMetadataManager 类主要用于管理消费者 group 的元数据信息和 offset 相关信息，字段定义如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupMetadataManager</span>(<span class="params">val brokerId: <span class="type">Int</span>, // 所属 broker 节点 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">                           val interBrokerProtocolVersion: <span class="type">ApiVersion</span>, // kafka 版本信息</span></span></span><br><span class="line"><span class="class"><span class="params">                           val config: <span class="type">OffsetConfig</span>, // 记录 <span class="type">OffsetMetadata</span> 相关的配置项</span></span></span><br><span class="line"><span class="class"><span class="params">                           replicaManager: <span class="type">ReplicaManager</span>, // 管理 broker 节点上 offset topic 的分区信息</span></span></span><br><span class="line"><span class="class"><span class="params">                           zkUtils: <span class="type">ZkUtils</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                           time: <span class="type">Time</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 消息压缩类型 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> compressionType: <span class="type">CompressionType</span> = <span class="type">CompressionType</span>.forId(config.offsetsTopicCompressionCodec.codec)</span><br><span class="line">    <span class="comment">/** 缓存每个 group 在服务端对应的 GroupMetadata 对象  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> groupMetadataCache = <span class="keyword">new</span> <span class="type">Pool</span>[<span class="type">String</span>, <span class="type">GroupMetadata</span>]</span><br><span class="line">    <span class="comment">/** 正在加载的 offset topic 分区的 ID 集合 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> loadingPartitions: mutable.<span class="type">Set</span>[<span class="type">Int</span>] = mutable.<span class="type">Set</span>()</span><br><span class="line">    <span class="comment">/** 已经加载完成的 offset topic 分区的 ID 集合 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> ownedPartitions: mutable.<span class="type">Set</span>[<span class="type">Int</span>] = mutable.<span class="type">Set</span>()</span><br><span class="line">    <span class="comment">/** 标识 GroupCoordinator 正在关闭 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> shuttingDown = <span class="keyword">new</span> <span class="type">AtomicBoolean</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="comment">/** 记录 offset topic 的分区数目 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> groupMetadataTopicPartitionCount = getOffsetsTopicPartitionCount</span><br><span class="line">    <span class="comment">/** 用于调度 delete-expired-consumer-offsets 和 GroupCoordinator 迁移等任务 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">KafkaScheduler</span>(threads = <span class="number">1</span>, threadNamePrefix = <span class="string">"group-metadata-manager-"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略方法定义</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Kafka 服务在启动时针对每一个 broker 节点都会创建一个 GroupCoordinator 实例，并调用 <code>GroupCoordinator#startup</code> 方法启动运行。GroupCoordinator 在启动时主要是调用了 <code>GroupMetadataManager#enableMetadataExpiration</code> 方法启动 delete-expired-group-metadata 定时任务：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startup</span></span>(enableMetadataExpiration: <span class="type">Boolean</span> = <span class="literal">true</span>) {</span><br><span class="line">    info(<span class="string">"Starting up."</span>)</span><br><span class="line">    <span class="keyword">if</span> (enableMetadataExpiration) groupManager.enableMetadataExpiration()</span><br><span class="line">    isActive.set(<span class="literal">true</span>)</span><br><span class="line">    info(<span class="string">"Startup complete."</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enableMetadataExpiration</span></span>() {</span><br><span class="line">    <span class="comment">// 启动定时任务调度器</span></span><br><span class="line">    scheduler.startup()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 delete-expired-group-metadata 定时任务</span></span><br><span class="line">    scheduler.schedule(name = <span class="string">"delete-expired-group-metadata"</span>,</span><br><span class="line">        fun = cleanupGroupMetadata,</span><br><span class="line">        period = config.offsetsRetentionCheckIntervalMs,</span><br><span class="line">        unit = <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>定时任务 delete-expired-group-metadata 的主要作用在于从 group 的元数据信息中移除那些已经过期的 topic 分区对应的 offset 元数据，并将这些元数据以消息的形式记录到 offset topic 中，具体执行流程如下：</p>
<ol>
<li>依据当前时间戳计算并获取已经过期的 topic 分区对应的 offset 元数据信息；</li>
<li>将状态为 Empty 且名下记录的所有 offset 元数据都已经过期的 group 切换成 Dead 状态；</li>
<li>如果 group 已经失效，则从 GroupCoordinator 本地移除对应的元数据信息，并与步骤 1 中获取到的 offset 元数据信息一起封装成消息记录到 offset topic 中。</li>
</ol>
<p>具体逻辑由 <code>GroupMetadataManager#cleanupGroupMetadata</code> 方法实现，如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[coordinator] <span class="function"><span class="keyword">def</span> <span class="title">cleanupGroupMetadata</span></span>(): <span class="type">Unit</span> = {</span><br><span class="line">    <span class="keyword">this</span>.cleanupGroupMetadata(<span class="type">None</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cleanupGroupMetadata</span></span>(deletedTopicPartitions: <span class="type">Option</span>[<span class="type">Seq</span>[<span class="type">TopicPartition</span>]]) {</span><br><span class="line">    <span class="keyword">val</span> startMs = time.milliseconds()</span><br><span class="line">    <span class="keyword">var</span> offsetsRemoved = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历处理每个 group 对应的元数据信息</span></span><br><span class="line">    groupMetadataCache.foreach { <span class="keyword">case</span> (groupId, group) =&gt;</span><br><span class="line">        <span class="keyword">val</span> (removedOffsets, groupIsDead, generation) = group synchronized {</span><br><span class="line">            <span class="comment">// 计算待移除的 topic 分区对应的 offset 元数据信息</span></span><br><span class="line">            <span class="keyword">val</span> removedOffsets = deletedTopicPartitions <span class="keyword">match</span> {</span><br><span class="line">                <span class="comment">// 从 group 元数据信息中移除指定的 topic 分区集合</span></span><br><span class="line">                <span class="keyword">case</span> <span class="type">Some</span>(topicPartitions) =&gt; group.removeOffsets(topicPartitions)</span><br><span class="line">                <span class="comment">// 移除那些 offset 元数据已经过期的，且没有 offset 待提交的 topic 分区集合</span></span><br><span class="line">                <span class="keyword">case</span> <span class="type">None</span> =&gt; group.removeExpiredOffsets(startMs)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 group 当前状态为 Empty，且名下 topic 分区所有的 offset 已经过期，则将该 group 状态切换成 Dead</span></span><br><span class="line">            <span class="keyword">if</span> (group.is(<span class="type">Empty</span>) &amp;&amp; !group.hasOffsets) {</span><br><span class="line">                info(<span class="string">s"Group <span class="subst">$groupId</span> transitioned to Dead in generation <span class="subst">${group.generationId}</span>"</span>)</span><br><span class="line">                group.transitionTo(<span class="type">Dead</span>)</span><br><span class="line">            }</span><br><span class="line">            (removedOffsets, group.is(<span class="type">Dead</span>), group.generationId)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 group 对应在 offset topic 中的分区编号</span></span><br><span class="line">        <span class="keyword">val</span> offsetsPartition = partitionFor(groupId)</span><br><span class="line">        <span class="keyword">val</span> appendPartition = <span class="keyword">new</span> <span class="type">TopicPartition</span>(<span class="type">Topic</span>.<span class="type">GroupMetadataTopicName</span>, offsetsPartition)</span><br><span class="line">        getMagic(offsetsPartition) <span class="keyword">match</span> {</span><br><span class="line">            <span class="comment">// 对应 group 由当前 GroupCoordinator 进行管理</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">Some</span>(magicValue) =&gt;</span><br><span class="line">                <span class="keyword">val</span> timestampType = <span class="type">TimestampType</span>.<span class="type">CREATE_TIME</span></span><br><span class="line">                <span class="keyword">val</span> timestamp = time.milliseconds()</span><br><span class="line">                <span class="comment">// 获取当前 group 在 offset topic 中的分区对象</span></span><br><span class="line">                <span class="keyword">val</span> partitionOpt = replicaManager.getPartition(appendPartition)</span><br><span class="line">                partitionOpt.foreach { partition =&gt;</span><br><span class="line">                    <span class="comment">// 遍历处理每个待移除的 topic 分区对应的 offset 元数据信息，封装成消息数据</span></span><br><span class="line">                    <span class="keyword">val</span> tombstones = removedOffsets.map { <span class="keyword">case</span> (topicPartition, offsetAndMetadata) =&gt;</span><br><span class="line">                        trace(<span class="string">s"Removing expired/deleted offset and metadata for <span class="subst">$groupId</span>, <span class="subst">$topicPartition</span>: <span class="subst">$offsetAndMetadata</span>"</span>)</span><br><span class="line">                        <span class="keyword">val</span> commitKey = <span class="type">GroupMetadataManager</span>.offsetCommitKey(groupId, topicPartition)</span><br><span class="line">                        <span class="type">Record</span>.create(magicValue, timestampType, timestamp, commitKey, <span class="literal">null</span>)</span><br><span class="line">                    }.toBuffer</span><br><span class="line">                    trace(<span class="string">s"Marked <span class="subst">${removedOffsets.size}</span> offsets in <span class="subst">$appendPartition</span> for deletion."</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果当前 group 已经失效，则从本地移除对应的元数据信息，并将 group 信息封装成消息，</span></span><br><span class="line">                    <span class="comment">// 如果 generation 为 0 则表示当前 group 仅仅使用 kafka 存储 offset 信息</span></span><br><span class="line">                    <span class="keyword">if</span> (groupIsDead &amp;&amp; groupMetadataCache.remove(groupId, group) &amp;&amp; generation &gt; <span class="number">0</span>) {</span><br><span class="line">                        tombstones += <span class="type">Record</span>.create(magicValue, timestampType, timestamp, <span class="type">GroupMetadataManager</span>.groupMetadataKey(group.groupId), <span class="literal">null</span>)</span><br><span class="line">                        trace(<span class="string">s"Group <span class="subst">$groupId</span> removed from the metadata cache and marked for deletion in <span class="subst">$appendPartition</span>."</span>)</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (tombstones.nonEmpty) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="comment">// 往 offset topic 中追加消息，不需要 ack，如果失败则周期性任务稍后会重试</span></span><br><span class="line">                            partition.appendRecordsToLeader(<span class="type">MemoryRecords</span>.withRecords(timestampType, compressionType, tombstones: _*))</span><br><span class="line">                            offsetsRemoved += removedOffsets.size</span><br><span class="line">                            trace(<span class="string">s"Successfully appended <span class="subst">${tombstones.size}</span> tombstones to <span class="subst">$appendPartition</span> for expired/deleted offsets and/or metadata for group <span class="subst">$groupId</span>"</span>)</span><br><span class="line">                        } <span class="keyword">catch</span> {</span><br><span class="line">                            <span class="keyword">case</span> t: <span class="type">Throwable</span> =&gt;</span><br><span class="line">                                error(<span class="string">s"Failed to append <span class="subst">${tombstones.size}</span> tombstones to <span class="subst">$appendPartition</span> for expired/deleted offsets and/or metadata for group <span class="subst">$groupId</span>."</span>, t)</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">                info(<span class="string">s"BrokerId <span class="subst">$brokerId</span> is no longer a coordinator for the group <span class="subst">$groupId</span>. Proceeding cleanup for other alive groups"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    info(<span class="string">s"Removed <span class="subst">$offsetsRemoved</span> expired offsets in <span class="subst">${time.milliseconds() - startMs}</span> milliseconds."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="Group-状态定义与转换">
          <a href="#Group-状态定义与转换" class="heading-link"><i class="fas fa-link"></i></a>Group 状态定义与转换</h3>
      <p>GroupState 特质定义了 group 的状态，并由 GroupCoordinator 进行维护。围绕 GroupState 特质，Kafka 实现了 5 个样例对象，分别用于描述 group 的 5 种状态：</p>
<ol>
<li><strong>PreparingRebalance</strong> ：表示 group 正在准备执行分区再分配操作。</li>
<li><strong>AwaitingSync</strong> ：表示 group 正在等待 leader 消费者的分区分配结果，新版本已更名为 CompletingRebalance。</li>
<li><strong>Stable</strong> ：表示 group 处于正常运行状态。</li>
<li><strong>Dead</strong> ：表示 group 名下已经没有消费者，且对应的元数据已经（或正在）被删除。</li>
<li><strong>Empty</strong> ：表示 group 名下已经没有消费者，并且正在等待记录的所有 offset 元数据过期。</li>
</ol>
<p>Group 状态之间的转换以及转换原因如下图和表所示：</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2019/kafka-group-state.png" alt="image">
      </p>
<div class="table-container"><table>
<thead>
<tr>
<th>当前状态</th>
<th>目标状态</th>
<th>转换原因</th>
</tr>
</thead>
<tbody><tr>
<td>PreparingRebalance</td>
<td>AwaitingSync</td>
<td>group 之前名下所有的消费者都已经申请加入，或者等待消费者申请加入超时。</td>
</tr>
<tr>
<td>PreparingRebalance</td>
<td>Empty</td>
<td>group 名下的所有消费者都已经离开。</td>
</tr>
<tr>
<td>PreparingRebalance</td>
<td>Dead</td>
<td>group 对应的元数据信息被移除。</td>
</tr>
<tr>
<td>AwaitingSync</td>
<td>Stable</td>
<td>group 收到来自 leader 消费者的分区分配结果。</td>
</tr>
<tr>
<td>AwaitingSync</td>
<td>PreparingRebalance</td>
<td>1. 有消费者申请加入或退出； 2. 名下消费者更新了元数据信息； 3. 名下消费者心跳超时。</td>
</tr>
<tr>
<td>AwaitingSync</td>
<td>Dead</td>
<td>group 对应的元数据信息被移除。</td>
</tr>
<tr>
<td>Stable</td>
<td>PreparingRebalance</td>
<td>1. 有消费者申请加入或退出； 2. 名下消费者心跳超时。</td>
</tr>
<tr>
<td>Stable</td>
<td>Dead</td>
<td>group 对应的元数据信息被移除。</td>
</tr>
<tr>
<td>Empty</td>
<td>PreparingRebalance</td>
<td>有消费者申请加入。</td>
</tr>
<tr>
<td>Empty</td>
<td>Dead</td>
<td>1. group 名下所有的 offset 元数据信息已经过期； 2. group 对应的元数据信息被移除。</td>
</tr>
<tr>
<td>Dead</td>
<td>无</td>
<td></td>
</tr>
</tbody></table></div>

        <h3 id="故障转移机制">
          <a href="#故障转移机制" class="heading-link"><i class="fas fa-link"></i></a>故障转移机制</h3>
      <p>在 Kafka 0.8.2.2 版本中引入了使用 offset topic 存储消费 offset 位置数据，以解决之前版本中采用 ZK 存储所面临的性能压力和不稳定性，并由 GroupCoordinator 组件负责维护。Offset topic 与 Kafka 中的普通 topic 除了用途上的区别之外，在性质上没有任何区别，Kafka 默认为 offset topic 设置了 50 个分区，每个分区分配 3 个副本。当某个 broker 节点宕机时，如果该节点上正好运行着 offset topic 某个分区的 leader 副本，考虑服务可用性需要选举一个位于其它可用 broker 节点上的满足条件的 follower 副本作为新的 leader 副本，同时由位于该 broker 节点上的 GroupCoordinator 实例继续维护对应的 offset topic 分区。因为涉及到 GroupCoordinator 实例的变更，所以需要在新的 GroupCoordinator 实例接管维护这些 offset topic 分区时，需要在这些 GroupCoordinator 实例上恢复对应 group 的元数据信息（一个 offset topic 分区中记录了一批 group 的元数据和 offset 消费数据）。</p>
<p>之前的文章在分析 Kafka 的分区副本机制时曾介绍了对 LeaderAndIsrRequest 请求的处理，ReplicaManager 定义了 <code>ReplicaManager#becomeLeaderOrFollower</code> 方法用于对指定 topic 分区的副本执行角色切换。该方法接收一个 <code>(Iterable[Partition], Iterable[Partition]) =&gt; Unit</code> 类型的回调函数，用于分别处理完成 leader 角色和 follower 角色切换的分区对象集合，回调函数的具体定义位于 <code>KafkaApis#handleLeaderAndIsrRequest</code> 方法中，实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成 GroupCoordinator 的迁移操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onLeadershipChange</span></span>(updatedLeaders: <span class="type">Iterable</span>[<span class="type">Partition</span>], updatedFollowers: <span class="type">Iterable</span>[<span class="type">Partition</span>]) {</span><br><span class="line">    updatedLeaders.foreach { partition =&gt;</span><br><span class="line">        <span class="comment">// 仅处理 offset topic，当 broker 节点维护 offset topic 分区的 leader 副本时回调执行</span></span><br><span class="line">        <span class="keyword">if</span> (partition.topic == <span class="type">Topic</span>.<span class="type">GroupMetadataTopicName</span>) coordinator.handleGroupImmigration(partition.partitionId)</span><br><span class="line">    }</span><br><span class="line">    updatedFollowers.foreach { partition =&gt;</span><br><span class="line">        <span class="comment">// 仅处理 offset topic，当 broker 节点维护 offset topic 分区的 follower 副本时回调执行</span></span><br><span class="line">        <span class="keyword">if</span> (partition.topic == <span class="type">Topic</span>.<span class="type">GroupMetadataTopicName</span>) coordinator.handleGroupEmigration(partition.partitionId)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由上述实现可以看到该回调函数仅处理 offset topic 对应的分区，当 GroupCoordinator 实例开始维护 offset topic 某个分区的 leader 副本时会触发执行 <code>GroupCoordinator#handleGroupImmigration</code> 方法，而当 GroupCoordinator 实例开始维护 offset topic 某个分区的 follower 副本时会触发执行 <code>GroupCoordinator#handleGroupEmigration</code> 方法，下面分别对这两个方法的实现进行分析。</p>
<p>方法 <code>GroupCoordinator#handleGroupImmigration</code> 的实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleGroupImmigration</span></span>(offsetTopicPartitionId: <span class="type">Int</span>) {</span><br><span class="line">    groupManager.loadGroupsForPartition(offsetTopicPartitionId, onGroupLoaded)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">onGroupLoaded</span></span>(group: <span class="type">GroupMetadata</span>) {</span><br><span class="line">    group synchronized {</span><br><span class="line">        info(<span class="string">s"Loading group metadata for <span class="subst">${group.groupId}</span> with generation <span class="subst">${group.generationId}</span>"</span>)</span><br><span class="line">        assert(group.is(<span class="type">Stable</span>) || group.is(<span class="type">Empty</span>))</span><br><span class="line">        <span class="comment">// 遍历更新当前 group 名下所有消费者的心跳信息</span></span><br><span class="line">        group.allMemberMetadata.foreach(completeAndScheduleNextHeartbeatExpiration(group, _))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>关于 <code>GroupCoordinator#completeAndScheduleNextHeartbeatExpiration</code> 方法的执行逻辑我们将在下一小节进行分析，这里我们主要来看一下 <code>GroupMetadataManager#loadGroupsForPartition</code> 方法的实现，该方法会基于 offset topic 更新对应 group 的元数据，并初始化每个 topic 分区对应的 offset 信息：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadGroupsForPartition</span></span>(offsetsPartition: <span class="type">Int</span>, onGroupLoaded: <span class="type">GroupMetadata</span> =&gt; <span class="type">Unit</span>) {</span><br><span class="line">    <span class="comment">// 构建 offset topic 对应的 topic 分区对象</span></span><br><span class="line">    <span class="keyword">val</span> topicPartition = <span class="keyword">new</span> <span class="type">TopicPartition</span>(<span class="type">Topic</span>.<span class="type">GroupMetadataTopicName</span>, offsetsPartition)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doLoadGroupsAndOffsets</span></span>() {</span><br><span class="line">        info(<span class="string">s"Loading offsets and group metadata from <span class="subst">$topicPartition</span>"</span>)</span><br><span class="line"></span><br><span class="line">        inLock(partitionLock) {</span><br><span class="line">            <span class="comment">// 检测当前 offset topic 分区是否正在加载，如果已经处于加载中则返回</span></span><br><span class="line">            <span class="keyword">if</span> (loadingPartitions.contains(offsetsPartition)) {</span><br><span class="line">                info(<span class="string">s"Offset load from <span class="subst">$topicPartition</span> already in progress."</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                loadingPartitions.add(offsetsPartition)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 基于 offset topic 加载更新对应 group 的元数据信息，初始化每个 topic 分区对应的 offset 信息</span></span><br><span class="line">            <span class="keyword">this</span>.loadGroupsAndOffsets(topicPartition, onGroupLoaded)</span><br><span class="line">        } <span class="keyword">catch</span> {</span><br><span class="line">            <span class="keyword">case</span> t: <span class="type">Throwable</span> =&gt; error(<span class="string">s"Error loading offsets from <span class="subst">$topicPartition</span>"</span>, t)</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            inLock(partitionLock) {</span><br><span class="line">                ownedPartitions.add(offsetsPartition)</span><br><span class="line">                loadingPartitions.remove(offsetsPartition)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步调度执行</span></span><br><span class="line">    scheduler.schedule(topicPartition.toString, doLoadGroupsAndOffsets)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>具体加载更新的过程采用异步调度的策略执行，实现位于 <code>GroupMetadataManager#loadGroupsAndOffsets</code> 方法中，该方法会读取对应 topic 分区下的所有消息数据，并依据消息的类型分别处理：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[coordinator] <span class="function"><span class="keyword">def</span> <span class="title">loadGroupsAndOffsets</span></span>(topicPartition: <span class="type">TopicPartition</span>, onGroupLoaded: <span class="type">GroupMetadata</span> =&gt; <span class="type">Unit</span>) {</span><br><span class="line">    <span class="comment">// 获取指定 topic 分区的 HW 值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">highWaterMark</span></span>: <span class="type">Long</span> = replicaManager.getHighWatermark(topicPartition).getOrElse(<span class="number">-1</span>L)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> startMs = time.milliseconds()</span><br><span class="line">    <span class="comment">// 获取并处理 topic 分区对应的 Log 对象</span></span><br><span class="line">    replicaManager.getLog(topicPartition) <span class="keyword">match</span> {</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">            <span class="comment">// 不存在</span></span><br><span class="line">            warn(<span class="string">s"Attempted to load offsets and group metadata from <span class="subst">$topicPartition</span>, but found no log"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(log) =&gt;</span><br><span class="line">            <span class="keyword">var</span> currOffset = log.logStartOffset</span><br><span class="line">            <span class="keyword">val</span> buffer = <span class="type">ByteBuffer</span>.allocate(config.loadBufferSize)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录 topic 分区与对应的 offset 信息映射关系</span></span><br><span class="line">            <span class="keyword">val</span> loadedOffsets = mutable.<span class="type">Map</span>[<span class="type">GroupTopicPartition</span>, <span class="type">OffsetAndMetadata</span>]()</span><br><span class="line">            <span class="keyword">val</span> removedOffsets = mutable.<span class="type">Set</span>[<span class="type">GroupTopicPartition</span>]()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录 group 与对应的 group 元数据信息映射关系</span></span><br><span class="line">            <span class="keyword">val</span> loadedGroups = mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">GroupMetadata</span>]()</span><br><span class="line">            <span class="keyword">val</span> removedGroups = mutable.<span class="type">Set</span>[<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 Log 对象中第一个 LogSegment 开始读取日志数据，直到 HW 位置为止，</span></span><br><span class="line">            <span class="comment">// 加载 offset 信息和 group 元数据信息</span></span><br><span class="line">            <span class="keyword">while</span> (currOffset &lt; highWaterMark &amp;&amp; !shuttingDown.get()) {</span><br><span class="line">                buffer.clear()</span><br><span class="line">                <span class="comment">// 读取日志数据到内存</span></span><br><span class="line">                <span class="keyword">val</span> fileRecords = log</span><br><span class="line">                        .read(currOffset, config.loadBufferSize, maxOffset = <span class="type">None</span>, minOneMessage = <span class="literal">true</span>)</span><br><span class="line">                        .records.asInstanceOf[<span class="type">FileRecords</span>]</span><br><span class="line">                <span class="keyword">val</span> bufferRead = fileRecords.readInto(buffer, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历处理消息集合（深层迭代）</span></span><br><span class="line">                <span class="type">MemoryRecords</span>.readableRecords(bufferRead).deepEntries.asScala.foreach { entry =&gt;</span><br><span class="line">                    <span class="keyword">val</span> record = entry.record</span><br><span class="line">                    require(record.hasKey, <span class="string">"Group metadata/offset entry key should not be null"</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 依据消息的 key 决定当前消息的类型</span></span><br><span class="line">                    <span class="type">GroupMetadataManager</span>.readMessageKey(record.key) <span class="keyword">match</span> {</span><br><span class="line">                        <span class="comment">// 如果是记录 offset 的消息</span></span><br><span class="line">                        <span class="keyword">case</span> offsetKey: <span class="type">OffsetKey</span> =&gt;</span><br><span class="line">                            <span class="keyword">val</span> key = offsetKey.key</span><br><span class="line">                            <span class="keyword">if</span> (record.hasNullValue) {</span><br><span class="line">                                <span class="comment">// 删除标记，则移除对应的 offset 信息</span></span><br><span class="line">                                loadedOffsets.remove(key)</span><br><span class="line">                                removedOffsets.add(key)</span><br><span class="line">                            } <span class="keyword">else</span> {</span><br><span class="line">                                <span class="comment">// 非删除标记，解析并更新 key 对应 offset 信息</span></span><br><span class="line">                                <span class="keyword">val</span> value = <span class="type">GroupMetadataManager</span>.readOffsetMessageValue(record.value)</span><br><span class="line">                                loadedOffsets.put(key, value)</span><br><span class="line">                                removedOffsets.remove(key)</span><br><span class="line">                            }</span><br><span class="line">                        <span class="comment">// 如果是记录 group 元数据的消息</span></span><br><span class="line">                        <span class="keyword">case</span> groupMetadataKey: <span class="type">GroupMetadataKey</span> =&gt;</span><br><span class="line">                            <span class="keyword">val</span> groupId = groupMetadataKey.key</span><br><span class="line">                            <span class="keyword">val</span> groupMetadata = <span class="type">GroupMetadataManager</span>.readGroupMessageValue(groupId, record.value)</span><br><span class="line">                            <span class="keyword">if</span> (groupMetadata != <span class="literal">null</span>) {</span><br><span class="line">                                <span class="comment">// 非删除标记，记录加载的 group 元数据信息</span></span><br><span class="line">                                trace(<span class="string">s"Loaded group metadata for group <span class="subst">$groupId</span> with generation <span class="subst">${groupMetadata.generationId}</span>"</span>)</span><br><span class="line">                                removedGroups.remove(groupId)</span><br><span class="line">                                loadedGroups.put(groupId, groupMetadata)</span><br><span class="line">                            } <span class="keyword">else</span> {</span><br><span class="line">                                <span class="comment">// 删除标记</span></span><br><span class="line">                                loadedGroups.remove(groupId)</span><br><span class="line">                                removedGroups.add(groupId)</span><br><span class="line">                            }</span><br><span class="line">                        <span class="comment">// 未知的消息 key 类型</span></span><br><span class="line">                        <span class="keyword">case</span> unknownKey =&gt;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"Unexpected message key <span class="subst">$unknownKey</span> while loading offsets and group metadata"</span>)</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    currOffset = entry.nextOffset</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将在 offset topic 中存在 offset 信息的 topic 分区以是否在 offset topic 中包含 group 元数据信息进行区分</span></span><br><span class="line">            <span class="keyword">val</span> (groupOffsets, emptyGroupOffsets) = loadedOffsets</span><br><span class="line">                    .groupBy(_._1.group)</span><br><span class="line">                    .mapValues(_.map { <span class="keyword">case</span> (groupTopicPartition, offset) =&gt; (groupTopicPartition.topicPartition, offset) })</span><br><span class="line">                    .partition { <span class="keyword">case</span> (group, _) =&gt; loadedGroups.contains(group) }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历处理在 offset topic 中存在 group 元数据信息的 group</span></span><br><span class="line">            loadedGroups.values.foreach { group =&gt;</span><br><span class="line">                <span class="keyword">val</span> offsets = groupOffsets.getOrElse(group.groupId, <span class="type">Map</span>.empty[<span class="type">TopicPartition</span>, <span class="type">OffsetAndMetadata</span>])</span><br><span class="line">                <span class="comment">// 更新 group 对应的元数据信息，主要是更新名下每个 topic 分区对应的 offset 信息</span></span><br><span class="line">                loadGroup(group, offsets)</span><br><span class="line">                onGroupLoaded(group)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历处理在 offset topic 中不存在 group 元数据信息的 group，但是存在 offset 信息，新建一个</span></span><br><span class="line">            emptyGroupOffsets.foreach { <span class="keyword">case</span> (groupId, offsets) =&gt;</span><br><span class="line">                <span class="keyword">val</span> group = <span class="keyword">new</span> <span class="type">GroupMetadata</span>(groupId)</span><br><span class="line">                <span class="comment">// 更新 group 对应的元数据信息，主要是更新名下每个 topic 分区对应的 offset 信息</span></span><br><span class="line">                loadGroup(group, offsets)</span><br><span class="line">                onGroupLoaded(group)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测需要删除的 group 元数据信息，如果对应 group 在本地有记录且在 offset topic 中存在 offset 信息，</span></span><br><span class="line">            <span class="comment">// 则不应该删除，此类 group 一般仅依赖 kafka 存储 offset 信息，而不存储对应的 group 元数据信息</span></span><br><span class="line">            removedGroups.foreach { groupId =&gt;</span><br><span class="line">                <span class="keyword">if</span> (groupMetadataCache.contains(groupId) &amp;&amp; !emptyGroupOffsets.contains(groupId))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"Unexpected unload of active group <span class="subst">$groupId</span> while loading partition <span class="subst">$topicPartition</span>"</span>)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Offset topic 中主要记录了 group 的元数据和对应的 offset 的消费位置信息，上述方法会分别解析这两类数据并据此来恢复 GroupCoordinator 本地记录的对应 group 的元数据信息。如果 offset topic 中包含对应 group 的元数据信息则恢复时会直接复用，否则会创建一个空的 GroupMetadata 对象（这类 group 一般仅使用 Kafka 存储 offset 位置数据），并应用 <code>GroupMetadataManager#loadGroup</code> 方法更新 group 名下每个 topic 分区的 offset 值，同时将 group 元数据记录到 GroupCoordinator 本地缓存中：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">loadGroup</span></span>(group: <span class="type">GroupMetadata</span>, offsets: <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">OffsetAndMetadata</span>]): <span class="type">Unit</span> = {</span><br><span class="line">    <span class="comment">// 遍历处理每个 topic 分区的 offset 信息，兼容更新老版本的过期时间</span></span><br><span class="line">    <span class="keyword">val</span> loadedOffsets = offsets.mapValues { offsetAndMetadata =&gt;</span><br><span class="line">        <span class="comment">// 对应老版本的 offset 元数据，设置过期时间戳为 commit 时间加上系统默认的保留时间（默认为 24 小时）</span></span><br><span class="line">        <span class="keyword">if</span> (offsetAndMetadata.expireTimestamp == <span class="type">OffsetCommitRequest</span>.<span class="type">DEFAULT_TIMESTAMP</span>)</span><br><span class="line">            offsetAndMetadata.copy(expireTimestamp = offsetAndMetadata.commitTimestamp + config.offsetsRetentionMs)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            offsetAndMetadata</span><br><span class="line">    }</span><br><span class="line">    trace(<span class="string">s"Initialized offsets <span class="subst">$loadedOffsets</span> for group <span class="subst">${group.groupId}</span>"</span>)</span><br><span class="line">    <span class="comment">// 更新 group 名下每个 topic 分区的 offset 信息</span></span><br><span class="line">    group.initializeOffsets(loadedOffsets)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 group 对应的元数据信息</span></span><br><span class="line">    <span class="keyword">val</span> currentGroup = <span class="keyword">this</span>.addGroup(group)</span><br><span class="line">    <span class="keyword">if</span> (group != currentGroup)</span><br><span class="line">        debug(<span class="string">s"Attempt to load group <span class="subst">${group.groupId}</span> from log with generation <span class="subst">${group.generationId}</span> failed because there is already a cached group with generation <span class="subst">${currentGroup.generationId}</span>"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>下面继续来看 GroupCoordinator 实例开始维护 offset topic 某个分区的 follower 副本的执行逻辑，实现位于 <code>GroupCoordinator#handleGroupEmigration</code> 方法中：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleGroupEmigration</span></span>(offsetTopicPartitionId: <span class="type">Int</span>) {</span><br><span class="line">    groupManager.removeGroupsForPartition(offsetTopicPartitionId, onGroupUnloaded)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">onGroupUnloaded</span></span>(group: <span class="type">GroupMetadata</span>) {</span><br><span class="line">    group synchronized {</span><br><span class="line">        info(<span class="string">s"Unloading group metadata for <span class="subst">${group.groupId}</span> with generation <span class="subst">${group.generationId}</span>"</span>)</span><br><span class="line">        <span class="keyword">val</span> previousState = group.currentState</span><br><span class="line">        <span class="comment">// 将当前 group 切换成 Dead 状态</span></span><br><span class="line">        group.transitionTo(<span class="type">Dead</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依据前置状态分别处理</span></span><br><span class="line">        previousState <span class="keyword">match</span> {</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Empty</span> | <span class="type">Dead</span> =&gt;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">PreparingRebalance</span> =&gt;</span><br><span class="line">                <span class="comment">// 遍历响应所有消费者的 JoinGroupRequest 请求，返回 NOT_COORDINATOR_FOR_GROUP 错误码</span></span><br><span class="line">                <span class="keyword">for</span> (member &lt;- group.allMemberMetadata) {</span><br><span class="line">                    <span class="keyword">if</span> (member.awaitingJoinCallback != <span class="literal">null</span>) {</span><br><span class="line">                        member.awaitingJoinCallback(joinError(member.memberId, <span class="type">Errors</span>.<span class="type">NOT_COORDINATOR_FOR_GROUP</span>.code))</span><br><span class="line">                        member.awaitingJoinCallback = <span class="literal">null</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 尝试执行 DelayedJoin 延时任务</span></span><br><span class="line">                joinPurgatory.checkAndComplete(<span class="type">GroupKey</span>(group.groupId))</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Stable</span> | <span class="type">AwaitingSync</span> =&gt;</span><br><span class="line">                <span class="comment">// 遍历响应所有消费者的 JoinGroupRequest 请求，返回 NOT_COORDINATOR_FOR_GROUP 错误码</span></span><br><span class="line">                <span class="keyword">for</span> (member &lt;- group.allMemberMetadata) {</span><br><span class="line">                    <span class="keyword">if</span> (member.awaitingSyncCallback != <span class="literal">null</span>) {</span><br><span class="line">                        member.awaitingSyncCallback(<span class="type">Array</span>.empty[<span class="type">Byte</span>], <span class="type">Errors</span>.<span class="type">NOT_COORDINATOR_FOR_GROUP</span>.code)</span><br><span class="line">                        member.awaitingSyncCallback = <span class="literal">null</span></span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 尝试执行 DelayHeartbeat 延时任务</span></span><br><span class="line">                    heartbeatPurgatory.checkAndComplete(<span class="type">MemberKey</span>(member.groupId, member.memberId))</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>当 GroupCoordinator 不再管理相应的 group 时，会将本地记录的 group 状态切换成 Dead，同时针对来自该 group 名下消费者的 JoinGroupRequest 请求均会响应 <code>NOT_COORDINATOR_FOR_GROUP</code> 错误。此外，还会从本地移除之前管理的 offset topic 分区对象，以及对应的 group 元数据信息，实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeGroupsForPartition</span></span>(offsetsPartition: <span class="type">Int</span>, onGroupUnloaded: <span class="type">GroupMetadata</span> =&gt; <span class="type">Unit</span>) {</span><br><span class="line">    <span class="comment">// 构建 offset topic 对应的 topic 分区对象</span></span><br><span class="line">    <span class="keyword">val</span> topicPartition = <span class="keyword">new</span> <span class="type">TopicPartition</span>(<span class="type">Topic</span>.<span class="type">GroupMetadataTopicName</span>, offsetsPartition)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步调度执行</span></span><br><span class="line">    scheduler.schedule(topicPartition.toString, removeGroupsAndOffsets)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeGroupsAndOffsets</span></span>() {</span><br><span class="line">        <span class="keyword">var</span> numOffsetsRemoved = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> numGroupsRemoved = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        inLock(partitionLock) {</span><br><span class="line">            <span class="comment">// 从已经加载完成的 offset topic 分区集合中移除指定的分区，表示当前 GroupCoordinator 实例不再管理对应的 group</span></span><br><span class="line">            ownedPartitions.remove(offsetsPartition)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历移除本地缓存的 group 对应的元数据信息</span></span><br><span class="line">            <span class="keyword">for</span> (group &lt;- groupMetadataCache.values) {</span><br><span class="line">                <span class="keyword">if</span> (partitionFor(group.groupId) == offsetsPartition) {</span><br><span class="line">                    onGroupUnloaded(group)</span><br><span class="line">                    groupMetadataCache.remove(group.groupId, group)</span><br><span class="line">                    numGroupsRemoved += <span class="number">1</span></span><br><span class="line">                    numOffsetsRemoved += group.numOffsets</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="心跳报活机制">
          <a href="#心跳报活机制" class="heading-link"><i class="fas fa-link"></i></a>心跳报活机制</h3>
      <p>消费者依赖于心跳机制向 GroupCoordinator 报活，向对应的 GroupCoordinator 实例发送 HeartbeatRequest 请求，GroupCoordinator 实例同样依赖于消费者的心跳来判断消费者的上下线。KafkaApis 定义了 <code>KafkaApis#handleHeartbeatRequest</code> 方法处理 HeartbeatRequest 请求，具体的处理逻辑则委托给 <code>GroupCoordinator#handleHeartbeat</code> 方法执行，该方法首先会校验目标 GroupCoordinator 实例是合法且能够处理当前请求，然后依据目标 group 的状态对本次心跳请求进行处理。只有当目标 group 处于 PreparingRebalance 或 Stable 状态时，且当前消费者确实属于该 group 才能够正常响应请求，对于处于其它状态的 group 而言只是简单返回对应的错误码。</p>
<p>正常响应 HeartbeatRequest 请求的逻辑位于 <code>GroupCoordinator#completeAndScheduleNextHeartbeatExpiration</code> 方法中，实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">completeAndScheduleNextHeartbeatExpiration</span></span>(group: <span class="type">GroupMetadata</span>, member: <span class="type">MemberMetadata</span>) {</span><br><span class="line">    <span class="comment">// 更新对应消费者的心跳时间</span></span><br><span class="line">    member.latestHeartbeat = time.milliseconds()</span><br><span class="line">    <span class="comment">// 获取 DelayedHeartbeat 延时任务关注的消费者</span></span><br><span class="line">    <span class="keyword">val</span> memberKey = <span class="type">MemberKey</span>(member.groupId, member.memberId)</span><br><span class="line">    <span class="comment">// 尝试完成之前添加的 DelayedHeartbeat 延时任务</span></span><br><span class="line">    heartbeatPurgatory.checkAndComplete(memberKey)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算下一次的心跳超时时间</span></span><br><span class="line">    <span class="keyword">val</span> newHeartbeatDeadline = member.latestHeartbeat + member.sessionTimeoutMs</span><br><span class="line">    <span class="comment">// 创建新的 DelayedHeartbeat 延时任务，并添加到炼狱中进行管理</span></span><br><span class="line">    <span class="keyword">val</span> delayedHeartbeat = <span class="keyword">new</span> <span class="type">DelayedHeartbeat</span>(<span class="keyword">this</span>, group, member, newHeartbeatDeadline, member.sessionTimeoutMs)</span><br><span class="line">    heartbeatPurgatory.tryCompleteElseWatch(delayedHeartbeat, <span class="type">Seq</span>(memberKey))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于 HeartbeatRequest 请求的正常响应会更新当前消费者的最近一次心跳时间，并尝试完成关注该消费者的 DelayedHeartbeat 延时任务，同时创建新的 DelayedHeartbeat 延时任务，延迟时间为下次心跳超时时间。在整个 GroupCoordinator 实现中有多个地方调用了上述方法，这也意味着心跳机制不单单依赖于 HeartbeatRequest 请求，实际上只要是消费者发往 GroupCoordinator 的请求都可以携带心跳信息，例如 JoinGroupRequest、SyncGroupRequest，以及 OffsetCommitRequest 等等。</p>
<p>下面来看一下延时任务 DelayedHeartbeat 的实现，重点看一下 <code>DelayedHeartbeat#tryComplete</code> 方法和 <code>DelayedHeartbeat#onExpiration</code> 方法，这两个方法分别调用了 <code>GroupCoordinator#tryCompleteHeartbeat</code> 和 <code>GroupCoordinator#onExpireHeartbeat</code> 方法，而 <code>DelayedHeartbeat#onComplete</code> 方法则是一个空实现，也就是说延时任务 DelayedHeartbeat 的真正执行逻辑就是从炼狱中删除该延时任务，这也符合心跳机制的目的，正常的心跳无需多做处理，只有在消费者的心跳超时时才需要处理相关异常的情况。</p>
<p>方法 <code>GroupCoordinator#tryCompleteHeartbeat</code> 会检测当前消费者的状态，如果满足以下 3 个条件之一则强制执行 DelayedHeartbeat 延时任务，表示对应消费者心跳正常：</p>
<ol>
<li>消费者正在等待 JoinGroupResponse 或 SyncGroupResponse 响应。</li>
<li>消费者最近一次心跳时间距离延时任务到期时间在消费者会话超时时间范围内。</li>
<li>消费者已经离开之前所属的 group。</li>
</ol>
<p>方法 <code>GroupCoordinator#onExpireHeartbeat</code> 会检测当前消费者是否已经离线，如果是则依据所属 group 的当前状态执行：</p>
<ol>
<li>如果目标 group 已经失效（Dead/Empty），则什么也不做；</li>
<li>如果目标 group 处于正常运行状态（Stable），或者正在等待 leader 消费者的分区分配结果（AwaitingSync），则因当前消费者的下线可能导致之前的分区分配结果已经失效，所以需要重新分配分区；</li>
<li>如果目标 group 处于准备执行分区再分配状态（PreparingRebalance），则无需请求再次重新分配分区，但是因为当前消费者的下线，可能让关注目标 group 的 DelayedJoin 延时任务满足执行条件，所以尝试执行。</li>
</ol>
<p>具体逻辑实现位于 <code>GroupCoordinator#onMemberFailure</code> 方法中，实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">onMemberFailure</span></span>(group: <span class="type">GroupMetadata</span>, member: <span class="type">MemberMetadata</span>) {</span><br><span class="line">    trace(<span class="string">"Member %s in group %s has failed"</span>.format(member.memberId, group.groupId))</span><br><span class="line">    <span class="comment">// 将对应的消费者从 GroupMetadata 中删除</span></span><br><span class="line">    group.remove(member.memberId)</span><br><span class="line">    group.currentState <span class="keyword">match</span> {</span><br><span class="line">        <span class="comment">// 对应 group 已经失效，什么也不做</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Dead</span> | <span class="type">Empty</span> =&gt;</span><br><span class="line">        <span class="comment">// 之前的分区分配结果可能已经失效，切换 GroupMetadata 状态为 PreparingRebalance，准备再次重新分配分区</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Stable</span> | <span class="type">AwaitingSync</span> =&gt; <span class="keyword">this</span>.maybePrepareRebalance(group)</span><br><span class="line">        <span class="comment">// 某个消费者下线，可能满足关注该 group 的 DelayedJoin 的执行条件，尝试执行</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">PreparingRebalance</span> =&gt; joinPurgatory.checkAndComplete(<span class="type">GroupKey</span>(group.groupId))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>其中 <code>GroupCoordinator#maybePrepareRebalance</code> 方法的执行逻辑将在下一小节介绍分区再分配机制时进行分析。</p>

        <h3 id="分区再分配机制">
          <a href="#分区再分配机制" class="heading-link"><i class="fas fa-link"></i></a>分区再分配机制</h3>
      <p>前面在分析消费者运行机制时，我们曾站在消费者的视角分析了分区再分配机制的执行过程，本小节我们继续从服务端的视角介绍集群对分区再分配操作过程中涉及到的来自消费者的请求的处理细节，主要包括 GroupCoordinatorRequest、JoinGroupResult 和 SyncGroupRequest 这 3 个请求。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2019/kafka-group-rebalance.png" alt="image">
      </p>
<p>上述时序图描绘了分区再分配期间客户端与服务端的交互过程。</p>

        <h4 id="GroupCoordinatorRequest-请求处理">
          <a href="#GroupCoordinatorRequest-请求处理" class="heading-link"><i class="fas fa-link"></i></a>GroupCoordinatorRequest 请求处理</h4>
      <p>当消费者与 GroupCoordinator 进行交互之前，需要先发送 GroupCoordinatorRequest 请求到负载较小的 broker 节点，以获取管理当前 group 的 GroupCoordinator 实例所在的 broker 节点的位置信息。KafkaApis 提供了 <code>KafkaApis#handleGroupCoordinatorRequest</code> 方法用于处理 GroupCoordinatorRequest 请求，方法实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleGroupCoordinatorRequest</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) {</span><br><span class="line">    <span class="keyword">val</span> groupCoordinatorRequest = request.body.asInstanceOf[<span class="type">GroupCoordinatorRequest</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 权限验证</span></span><br><span class="line">    <span class="keyword">if</span> (!authorize(request.session, <span class="type">Describe</span>, <span class="keyword">new</span> <span class="type">Resource</span>(<span class="type">Group</span>, groupCoordinatorRequest.groupId))) {</span><br><span class="line">        <span class="keyword">val</span> responseBody = <span class="keyword">new</span> <span class="type">GroupCoordinatorResponse</span>(<span class="type">Errors</span>.<span class="type">GROUP_AUTHORIZATION_FAILED</span>.code, <span class="type">Node</span>.noNode)</span><br><span class="line">        requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, responseBody))</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 获取 group 对应的 offset topic 的分区 ID</span></span><br><span class="line">        <span class="keyword">val</span> partition = coordinator.partitionFor(groupCoordinatorRequest.groupId)</span><br><span class="line">        <span class="comment">// 从 MetadataCache 中获取 offset topic 的相关信息，如果未创建则进行创建</span></span><br><span class="line">        <span class="keyword">val</span> offsetsTopicMetadata = <span class="keyword">this</span>.getOrCreateGroupMetadataTopic(request.listenerName)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> responseBody = <span class="keyword">if</span> (offsetsTopicMetadata.error != <span class="type">Errors</span>.<span class="type">NONE</span>) {</span><br><span class="line">            <span class="comment">// 创建 offset topic 信息失败</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">GroupCoordinatorResponse</span>(<span class="type">Errors</span>.<span class="type">GROUP_COORDINATOR_NOT_AVAILABLE</span>.code, <span class="type">Node</span>.noNode)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取当前 group 对应 offset topic 分区 leader 副本所在的节点</span></span><br><span class="line">            <span class="keyword">val</span> coordinatorEndpoint = offsetsTopicMetadata.partitionMetadata().asScala</span><br><span class="line">                    .find(_.partition == partition)</span><br><span class="line">                    .map(_.leader())</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 GroupCoordinatorResponse 对象，将 leader 副本所在节点信息返回给客户端</span></span><br><span class="line">            coordinatorEndpoint <span class="keyword">match</span> {</span><br><span class="line">                <span class="keyword">case</span> <span class="type">Some</span>(endpoint) <span class="keyword">if</span> !endpoint.isEmpty =&gt; <span class="keyword">new</span> <span class="type">GroupCoordinatorResponse</span>(<span class="type">Errors</span>.<span class="type">NONE</span>.code, endpoint)</span><br><span class="line">                <span class="keyword">case</span> _ =&gt; <span class="keyword">new</span> <span class="type">GroupCoordinatorResponse</span>(<span class="type">Errors</span>.<span class="type">GROUP_COORDINATOR_NOT_AVAILABLE</span>.code, <span class="type">Node</span>.noNode)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        trace(<span class="string">"Sending consumer metadata %s for correlation id %d to client %s."</span>.format(responseBody, request.header.correlationId, request.header.clientId))</span><br><span class="line">        <span class="comment">// 将响应对象加入到 channel 中，等待发送</span></span><br><span class="line">        requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, responseBody))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Kafka 会依据请求的 group 的 ID 查找对应 offset topic 分区 leader 副本所在的 broker 节点，并将节点信息封装成 GroupCoordinatorResponse 响应发送给消费者。接下来消费者会向对应的 broker 节点建立连接并发送 JoinGroupRequest 请求申请加入对应的 group。</p>

        <h4 id="JoinGroupRequest-请求处理">
          <a href="#JoinGroupRequest-请求处理" class="heading-link"><i class="fas fa-link"></i></a>JoinGroupRequest 请求处理</h4>
      <p>针对来自消费者申请加入指定 group 的 JoinGroupRequest 请求，GroupCoordinator 实例会为 group 中的消费者确定最终的分区分配策略，并选举新的 group leader 消费者。KafkaApis 定义了 <code>KafkaApis#handleJoinGroupRequest</code> 方法处理 JoinGroupRequest 请求，不过该方法只是简单解析了请求对象，并执行权限校验，以及定义了回调函数用于向客户端发送 JoinGroupResponse 响应，具体处理请求的过程则交由 <code>GroupCoordinator#handleJoinGroup</code> 方法实现：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleJoinGroup</span></span>(groupId: <span class="type">String</span>,</span><br><span class="line">                    memberId: <span class="type">String</span>,</span><br><span class="line">                    clientId: <span class="type">String</span>,</span><br><span class="line">                    clientHost: <span class="type">String</span>,</span><br><span class="line">                    rebalanceTimeoutMs: <span class="type">Int</span>,</span><br><span class="line">                    sessionTimeoutMs: <span class="type">Int</span>,</span><br><span class="line">                    protocolType: <span class="type">String</span>,</span><br><span class="line">                    protocols: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Byte</span>])],</span><br><span class="line">                    responseCallback: <span class="type">JoinCallback</span>) {</span><br><span class="line">    <span class="keyword">if</span> (!isActive.get) {</span><br><span class="line">        <span class="comment">// GroupCoordinator 实例未启动</span></span><br><span class="line">        responseCallback(joinError(memberId, <span class="type">Errors</span>.<span class="type">GROUP_COORDINATOR_NOT_AVAILABLE</span>.code))</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!validGroupId(groupId)) {</span><br><span class="line">        <span class="comment">// groupId 不合法</span></span><br><span class="line">        responseCallback(joinError(memberId, <span class="type">Errors</span>.<span class="type">INVALID_GROUP_ID</span>.code))</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!isCoordinatorForGroup(groupId)) {</span><br><span class="line">        <span class="comment">// 当前 GroupCoordinator 实例并不负责管理当前 group</span></span><br><span class="line">        responseCallback(joinError(memberId, <span class="type">Errors</span>.<span class="type">NOT_COORDINATOR_FOR_GROUP</span>.code))</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (isCoordinatorLoadingInProgress(groupId)) {</span><br><span class="line">        <span class="comment">// 当前 GroupCoordinator 实例正在加载该 group 对应的 offset topic 分区信息</span></span><br><span class="line">        responseCallback(joinError(memberId, <span class="type">Errors</span>.<span class="type">GROUP_LOAD_IN_PROGRESS</span>.code))</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (sessionTimeoutMs &lt; groupConfig.groupMinSessionTimeoutMs || sessionTimeoutMs &gt; groupConfig.groupMaxSessionTimeoutMs) {</span><br><span class="line">        <span class="comment">// 会话时长超时，保证消费者是活跃的</span></span><br><span class="line">        responseCallback(joinError(memberId, <span class="type">Errors</span>.<span class="type">INVALID_SESSION_TIMEOUT</span>.code))</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 获取并处理 group 对应的元数据信息</span></span><br><span class="line">        groupManager.getGroup(groupId) <span class="keyword">match</span> {</span><br><span class="line">            <span class="comment">// 对应的 group 不存在</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">                <span class="keyword">if</span> (memberId != <span class="type">JoinGroupRequest</span>.<span class="type">UNKNOWN_MEMBER_ID</span>) {</span><br><span class="line">                    <span class="comment">// 指定了消费者 ID，但是对应的 group 不存在，则拒绝请求</span></span><br><span class="line">                    responseCallback(joinError(memberId, <span class="type">Errors</span>.<span class="type">UNKNOWN_MEMBER_ID</span>.code))</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// group 不存在，且消费者 ID 未知的情况下，创建 GroupMetadata 对象，并将消费者加入到对应的 group，同时执行分区再均衡操作</span></span><br><span class="line">                    <span class="keyword">val</span> group = groupManager.addGroup(<span class="keyword">new</span> <span class="type">GroupMetadata</span>(groupId))</span><br><span class="line">                    <span class="keyword">this</span>.doJoinGroup(group, memberId, clientId, clientHost, rebalanceTimeoutMs, sessionTimeoutMs, protocolType, protocols, responseCallback)</span><br><span class="line">                }</span><br><span class="line">            <span class="comment">// 对应的 group 存在，将消费者加入到对应的 group，并执行分区再均衡操作</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">Some</span>(group) =&gt;</span><br><span class="line">                <span class="keyword">this</span>.doJoinGroup(group, memberId, clientId, clientHost, rebalanceTimeoutMs, sessionTimeoutMs, protocolType, protocols, responseCallback)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>GroupCoordinator 实例在具体处理 JoinGroupRequest 请求之前，首先会执行一系列的校验操作以保证发送请求的消费者和目标 group 都是合法的，且对应的 GroupCoordinator 能够正常处理当前请求。如果目标 group 不存在，则在未指定对应的消费者 ID 时会首先新建 group，然后将当前消费者添加到对应 group 中开始执行分区再分配操作。方法 <code>GroupCoordinator#doJoinGroup</code> 会校验消费者 ID （如果指定的话）能否被当前 group 识别，以及消费者指定的分区分配策略能否被当前 group 支持，如果这些条件都不能满足，则没有必要再继续为该消费者分配分区，方法实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doJoinGroup</span></span>(group: <span class="type">GroupMetadata</span>,</span><br><span class="line">                        memberId: <span class="type">String</span>,</span><br><span class="line">                        clientId: <span class="type">String</span>,</span><br><span class="line">                        clientHost: <span class="type">String</span>,</span><br><span class="line">                        rebalanceTimeoutMs: <span class="type">Int</span>,</span><br><span class="line">                        sessionTimeoutMs: <span class="type">Int</span>,</span><br><span class="line">                        protocolType: <span class="type">String</span>,</span><br><span class="line">                        protocols: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Byte</span>])],</span><br><span class="line">                        responseCallback: <span class="type">JoinCallback</span>) {</span><br><span class="line"></span><br><span class="line">    group synchronized {</span><br><span class="line">        <span class="keyword">if</span> (!group.is(<span class="type">Empty</span>)</span><br><span class="line">                <span class="comment">// 消费者指定的分区分配策略，对应的 group 不支持</span></span><br><span class="line">                &amp;&amp; (group.protocolType != <span class="type">Some</span>(protocolType) || !group.supportsProtocols(protocols.map(_._1).toSet))) {</span><br><span class="line">            responseCallback(joinError(memberId, <span class="type">Errors</span>.<span class="type">INCONSISTENT_GROUP_PROTOCOL</span>.code))</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (memberId != <span class="type">JoinGroupRequest</span>.<span class="type">UNKNOWN_MEMBER_ID</span> &amp;&amp; !group.has(memberId)) {</span><br><span class="line">            <span class="comment">// 消费者 ID 不能够被识别</span></span><br><span class="line">            responseCallback(joinError(memberId, <span class="type">Errors</span>.<span class="type">UNKNOWN_MEMBER_ID</span>.code))</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 依据 group 的当前状态分别进行处理</span></span><br><span class="line">            group.currentState <span class="keyword">match</span> {</span><br><span class="line">                <span class="comment">// 目标 group 已经失效</span></span><br><span class="line">                <span class="keyword">case</span> <span class="type">Dead</span> =&gt;</span><br><span class="line">                    <span class="comment">// 对应的 group 的元数据信息已经被删除，说明已经迁移到其它 GroupCoordinator 实例或者不再可用，直接返回错误码</span></span><br><span class="line">                    responseCallback(joinError(memberId, <span class="type">Errors</span>.<span class="type">UNKNOWN_MEMBER_ID</span>.code))</span><br><span class="line">                <span class="comment">// 目标 group 正在执行分区再均衡操作</span></span><br><span class="line">                <span class="keyword">case</span> <span class="type">PreparingRebalance</span> =&gt;</span><br><span class="line">                    <span class="keyword">if</span> (memberId == <span class="type">JoinGroupRequest</span>.<span class="type">UNKNOWN_MEMBER_ID</span>) {</span><br><span class="line">                        <span class="comment">// 对于未知 ID 的消费者申请加入，创建对应的元数据信息，并分配 ID，同时切换 group 的状态为 PreparingRebalance，准备执行分区再分配</span></span><br><span class="line">                        <span class="keyword">this</span>.addMemberAndRebalance(rebalanceTimeoutMs, sessionTimeoutMs, clientId, clientHost, protocolType, protocols, group, responseCallback)</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// 对于已知 ID 的消费者重新申请加入，更新对应的元数据信息，同时切换 group 的状态为 PreparingRebalance，准备执行分区再分配</span></span><br><span class="line">                        <span class="keyword">val</span> member = group.get(memberId)</span><br><span class="line">                        <span class="keyword">this</span>.updateMemberAndRebalance(group, member, protocols, responseCallback)</span><br><span class="line">                    }</span><br><span class="line">                <span class="comment">// 目标 group 正在等待 leader 消费者的分区分配结果</span></span><br><span class="line">                <span class="keyword">case</span> <span class="type">AwaitingSync</span> =&gt;</span><br><span class="line">                    <span class="keyword">if</span> (memberId == <span class="type">JoinGroupRequest</span>.<span class="type">UNKNOWN_MEMBER_ID</span>) {</span><br><span class="line">                        <span class="comment">// 对于未知 ID 的消费者申请加入，创建对应的元数据信息，并分配 ID，同时切换 group 的状态为 PreparingRebalance，准备执行分区再分配</span></span><br><span class="line">                        <span class="keyword">this</span>.addMemberAndRebalance(rebalanceTimeoutMs, sessionTimeoutMs, clientId, clientHost, protocolType, protocols, group, responseCallback)</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// 对于已知 ID 的消费者重新申请加入</span></span><br><span class="line">                        <span class="keyword">val</span> member = group.get(memberId)</span><br><span class="line">                        <span class="keyword">if</span> (member.matches(protocols)) {</span><br><span class="line">                            <span class="comment">// 分区分配策略未发生变化，返回 GroupMetadata 的信息</span></span><br><span class="line">                            responseCallback(<span class="type">JoinGroupResult</span>(</span><br><span class="line">                                members = <span class="keyword">if</span> (memberId == group.leaderId) {</span><br><span class="line">                                    group.currentMemberMetadata</span><br><span class="line">                                } <span class="keyword">else</span> {</span><br><span class="line">                                    <span class="type">Map</span>.empty</span><br><span class="line">                                },</span><br><span class="line">                                memberId = memberId,</span><br><span class="line">                                generationId = group.generationId,</span><br><span class="line">                                subProtocol = group.protocol,</span><br><span class="line">                                leaderId = group.leaderId,</span><br><span class="line">                                errorCode = <span class="type">Errors</span>.<span class="type">NONE</span>.code))</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="comment">// 分区分配策略发生变化，更新对应的元数据信息，同时切换 group 的状态为 PreparingRebalance，准备执行分区再分配</span></span><br><span class="line">                            <span class="keyword">this</span>.updateMemberAndRebalance(group, member, protocols, responseCallback)</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                <span class="comment">// 目标 group 运行正常，或者正在等待 offset 过期</span></span><br><span class="line">                <span class="keyword">case</span> <span class="type">Empty</span> | <span class="type">Stable</span> =&gt;</span><br><span class="line">                    <span class="keyword">if</span> (memberId == <span class="type">JoinGroupRequest</span>.<span class="type">UNKNOWN_MEMBER_ID</span>) {</span><br><span class="line">                        <span class="comment">// 对于未知 ID 的消费者申请加入，创建对应的元数据信息，并分配 ID，同时切换 group 的状态为 PreparingRebalance，准备执行分区再分配</span></span><br><span class="line">                        <span class="keyword">this</span>.addMemberAndRebalance(rebalanceTimeoutMs, sessionTimeoutMs, clientId, clientHost, protocolType, protocols, group, responseCallback)</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// 对于已知 ID 的消费者重新申请加入</span></span><br><span class="line">                        <span class="keyword">val</span> member = group.get(memberId)</span><br><span class="line">                        <span class="keyword">if</span> (memberId == group.leaderId || !member.matches(protocols)) {</span><br><span class="line">                            <span class="comment">// 当前消费者是 group leader 或支持的分区分配策略发生变化，更新对应的元数据信息，同时切换 group 的状态为 PreparingRebalance，准备执行分区再分配</span></span><br><span class="line">                            <span class="keyword">this</span>.updateMemberAndRebalance(group, member, protocols, responseCallback)</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="comment">// 分区分配策略未发生变化，返回 GroupMetadata 信息</span></span><br><span class="line">                            responseCallback(<span class="type">JoinGroupResult</span>(</span><br><span class="line">                                members = <span class="type">Map</span>.empty,</span><br><span class="line">                                memberId = memberId,</span><br><span class="line">                                generationId = group.generationId,</span><br><span class="line">                                subProtocol = group.protocol,</span><br><span class="line">                                leaderId = group.leaderId,</span><br><span class="line">                                errorCode = <span class="type">Errors</span>.<span class="type">NONE</span>.code))</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前 group 正在准备执行分区再分配，尝试执行 DelayedJoin 延时任务</span></span><br><span class="line">            <span class="keyword">if</span> (group.is(<span class="type">PreparingRebalance</span>)) joinPurgatory.checkAndComplete(<span class="type">GroupKey</span>(group.groupId))</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于满足条件的消费者来说，需要依据 group 的当前运行状态分而治之。如果当前 group 的状态为 Dead，则说明对应的 group 不再可用，或者已经由其它 GroupCoordinator 实例管理，直接响应 <code>UNKNOWN_MEMBER_ID</code> 错误，消费者可以再次请求获取新接管的 GroupCoordinator 实例所在的位置信息。</p>
<p>如果当前 group 的状态为 PreparingRebalance，则说明对应的 group 正在准备执行分区再分配操作，此时：</p>
<ul>
<li>对于新加入的消费者（未指定 ID），首先需要为其创建消费者 ID 和元数据信息，并交由目标 group 进行管理，然后开始执行分区再分配操作。</li>
<li>对于已存在的消费者（已指定 ID），首先需要更新消费者最终的分区分配策略和回调响应函数，然后开始执行分区再分配操作。</li>
</ul>
<p>如果当前 group 的状态为 AwaitingSync，则说明对应的 group 正在等待 leader 消费者的分区分配结果，此时：</p>
<ul>
<li>对于新加入的消费者（未指定 ID），首先需要为其创建消费者 ID 和元数据信息，并交由目标 group 进行管理，然后开始执行分区再分配操作。</li>
<li>对于已存在的消费者（已指定 ID），如果分区分配策略未发生变化则无需再重复分配，如果分区分配策略发生变化则需要先更新消费者最终的分区分配策略和回调响应函数，然后开始执行分区再分配操作。</li>
</ul>
<p>如果当前 group 的状态为 Empty 或 Stable，则说明对应的 group 目前处于一个正常运行的状态，此时：</p>
<ul>
<li>对于新加入的消费者（未指定 ID），首先需要为其创建消费者 ID 和元数据信息，并交由目标 group 进行管理，然后开始执行分区再分配操作。</li>
<li>对于已存在的消费者（已指定 ID），如果不是 leader，或者分区分配策略未发生变化，则无需再重复分配，否则需要先更新消费者最终的分区分配策略和回调响应函数，然后开始执行分区再分配操作。</li>
</ul>
<p>上述过程中多次调用了 <code>GroupCoordinator#addMemberAndRebalance</code> 方法为消费者创建元数据信息并分配 ID，并将对应的消费者元数据信息记录到 group 元数据信息中。方法 <code>GroupMetadata#add</code> 定义了 <strong>如果当前 group 名下还未选举 leader 消费者，则以第一个加入到当前 group 的消费者作为 leader 角色</strong> ，然后调用 <code>GroupCoordinator#updateMemberAndRebalance</code> 方法更新消费者的分区分配策略和响应回调函数。这两个方法分别实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">addMemberAndRebalance</span></span>(rebalanceTimeoutMs: <span class="type">Int</span>,</span><br><span class="line">                                  sessionTimeoutMs: <span class="type">Int</span>,</span><br><span class="line">                                  clientId: <span class="type">String</span>,</span><br><span class="line">                                  clientHost: <span class="type">String</span>,</span><br><span class="line">                                  protocolType: <span class="type">String</span>,</span><br><span class="line">                                  protocols: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Byte</span>])],</span><br><span class="line">                                  group: <span class="type">GroupMetadata</span>,</span><br><span class="line">                                  callback: <span class="type">JoinCallback</span>): <span class="type">MemberMetadata</span> = {</span><br><span class="line">    <span class="comment">// 基于 UUID 生成消费者的 ID</span></span><br><span class="line">    <span class="keyword">val</span> memberId = clientId + <span class="string">"-"</span> + group.generateMemberIdSuffix</span><br><span class="line">    <span class="comment">// 创建新的 MemberMetadata 元数据信息对象</span></span><br><span class="line">    <span class="keyword">val</span> member = <span class="keyword">new</span> <span class="type">MemberMetadata</span>(memberId, group.groupId, clientId, clientHost, rebalanceTimeoutMs, sessionTimeoutMs, protocolType, protocols)</span><br><span class="line">    <span class="comment">// 设置回调函数，即 KafkaApis#sendResponseCallback 方法，用于向客户端发送 JoinGroupResponse 响应</span></span><br><span class="line">    member.awaitingJoinCallback = callback</span><br><span class="line">    <span class="comment">// 添加到 GroupMetadata 中，第一个加入 group 的消费者成为 leader 角色</span></span><br><span class="line">    group.add(member)</span><br><span class="line">    <span class="comment">// 尝试切换 group 的状态为 PreparingRebalance</span></span><br><span class="line">    <span class="keyword">this</span>.maybePrepareRebalance(group)</span><br><span class="line">    member</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">updateMemberAndRebalance</span></span>(group: <span class="type">GroupMetadata</span>,</span><br><span class="line">                                     member: <span class="type">MemberMetadata</span>,</span><br><span class="line">                                     protocols: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Byte</span>])],</span><br><span class="line">                                     callback: <span class="type">JoinCallback</span>) {</span><br><span class="line">    <span class="comment">// 更新 MemberMetadata 支持的协议</span></span><br><span class="line">    member.supportedProtocols = protocols</span><br><span class="line">    <span class="comment">// 更新 MemberMetadata 的响应回调函数</span></span><br><span class="line">    member.awaitingJoinCallback = callback</span><br><span class="line">    <span class="comment">// 尝试执行状态切换</span></span><br><span class="line">    <span class="keyword">this</span>.maybePrepareRebalance(group)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由上述实现可以看到这两个方法最终都调用了 <code>GroupCoordinator#maybePrepareRebalance</code> 方法，该方法会校验 group 的当前状态，如果是 Stable、AwaitingSync，以及 Empty 中的一种，则会调用 <code>GroupCoordinator#prepareRebalance</code> 方法切换 group 的状态为 PreparingRebalance，并创建相应的 DelayedJoin 延时任务，等待 group 名下所有的消费者发送 JoinGroupRequest 请求申请加入到当前 group 中。</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">prepareRebalance</span></span>(group: <span class="type">GroupMetadata</span>) {</span><br><span class="line">    <span class="comment">// 如果处于 AwaitingSync 状态，说明在等待 leader 消费者的分区分配结果，</span></span><br><span class="line">    <span class="comment">// 此时对于来自 follower 的 SyncGroupRequest 请求，直接响应 REBALANCE_IN_PROGRESS 错误</span></span><br><span class="line">    <span class="keyword">if</span> (group.is(<span class="type">AwaitingSync</span>)) resetAndPropagateAssignmentError(group, <span class="type">Errors</span>.<span class="type">REBALANCE_IN_PROGRESS</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 group 状态切换成 PreparingRebalance 状态，准备执行分区再分配操作</span></span><br><span class="line">    group.transitionTo(<span class="type">PreparingRebalance</span>)</span><br><span class="line">    info(<span class="string">"Preparing to restabilize group %s with old generation %s"</span>.format(group.groupId, group.generationId))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分区再均衡超时时长是所有消费者设置的超时时长的最大值</span></span><br><span class="line">    <span class="keyword">val</span> rebalanceTimeout = group.rebalanceTimeoutMs</span><br><span class="line">    <span class="comment">// 创建 DelayedJoin 延时任务，用于等待消费者申请加入当前 group</span></span><br><span class="line">    <span class="keyword">val</span> delayedRebalance = <span class="keyword">new</span> <span class="type">DelayedJoin</span>(<span class="keyword">this</span>, group, rebalanceTimeout)</span><br><span class="line">    <span class="keyword">val</span> groupKey = <span class="type">GroupKey</span>(group.groupId) <span class="comment">// 关注当前 group</span></span><br><span class="line">    <span class="comment">// 将延时任务添加到炼狱中进行管理</span></span><br><span class="line">    joinPurgatory.tryCompleteElseWatch(delayedRebalance, <span class="type">Seq</span>(groupKey))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先会校验 group 当前状态是不是 AwaitingSync，如果是则说明当前 GroupCoordinator 实例正在等待 leader 消费者的分区分配的结果，此时如果有来自 follower 消费者的 SyncGroupRequest 请求，则直接响应 <code>REBALANCE_IN_PROGRESS</code> 错误，同时需要清空 group 名下所有消费者记录的分区分配信息。然后切换 group 的状态为 PreparingRebalance，表示开始准备执行分区再分配，并创建 DelayedJoin 延时任务等待 group 名下所有消费者发送 JoinGroupRequest 请求申请加入当前 group。</p>
<p>下面来看一下延时任务 DelayedJoin 的实现，这里的延时时长等于 group 名下所有消费者设置的超时时长的最大值。我们重点看一下 <code>DelayedJoin#tryComplete</code> 和 <code>DelayedJoin#onComplete</code> 方法，这两个方法分别调用了 <code>GroupCoordinator#tryCompleteJoin</code> 和 <code>GroupCoordinator#onCompleteJoin</code> 方法。其中 <code>GroupCoordinator#tryCompleteJoin</code> 方法基于消费者元数据信息 <code>MemberMetadata#awaitingJoinCallback</code> 字段判断 group 名下已知的消费者是否都已经发送了 JoinGroupRequest 请求，如果是则强制完成 DelayedJoin 延时任务，方法实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tryCompleteJoin</span></span>(group: <span class="type">GroupMetadata</span>, forceComplete: () =&gt; <span class="type">Boolean</span>): <span class="type">Boolean</span> = {</span><br><span class="line">    group synchronized {</span><br><span class="line">        <span class="comment">// 判断所有已知的消费者是否是否都已经申请加入，</span></span><br><span class="line">        <span class="comment">// 基于 awaitingJoinCallback 回调函数，只有发送了 JoinGroupRequest 请求的消费者才会设置该回调</span></span><br><span class="line">        <span class="keyword">if</span> (group.notYetRejoinedMembers.isEmpty) forceComplete() <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notYetRejoinedMembers</span></span>: <span class="type">List</span>[<span class="type">MemberMetadata</span>] = members.values.filter(_.awaitingJoinCallback == <span class="literal">null</span>).toList</span><br></pre></td></tr></tbody></table></div></figure>
<p>消费者元数据信息的 <code>MemberMetadata#awaitingJoinCallback</code> 字段实际上就是在 <code>KafkaApis#handleJoinGroupRequest</code> 方法中定义的 sendResponseCallback 回调函数，用于向客户端发送 JoinGroupResponse 响应。所以这里我们可以依据该字段判断对应消费者是否发送了 JoinGroupRequest 请求，因为只有发送了该请求才会为 <code>MemberMetadata#awaitingJoinCallback</code> 字段赋值。</p>
<p>当延时任务 DelayedJoin 被执行时会触发调用 <code>GroupCoordinator#onCompleteJoin</code> 方法，实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onCompleteJoin</span></span>(group: <span class="type">GroupMetadata</span>) {</span><br><span class="line">    <span class="keyword">var</span> delayedStore: <span class="type">Option</span>[<span class="type">DelayedStore</span>] = <span class="type">None</span></span><br><span class="line">    group synchronized {</span><br><span class="line">        <span class="comment">// 移除那些已知的但是未申请重新加入当前 group 的消费者</span></span><br><span class="line">        group.notYetRejoinedMembers.foreach { failedMember =&gt; group.remove(failedMember.memberId) }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!group.is(<span class="type">Dead</span>)) {</span><br><span class="line">            <span class="comment">// 递增 group 的年代信息，并选择 group 最终使用的分区分配策略，如果 group 名下存在消费者则切换状态为 AwaitingSync，否则切换成 Empty</span></span><br><span class="line">            group.initNextGeneration()</span><br><span class="line">            <span class="keyword">if</span> (group.is(<span class="type">Empty</span>)) {</span><br><span class="line">                info(<span class="string">s"Group <span class="subst">${group.groupId}</span> with generation <span class="subst">${group.generationId}</span> is now empty"</span>)</span><br><span class="line">                <span class="comment">// 如果 group 名下已经没有消费者，将空的分区分配信息记录到 offset topic</span></span><br><span class="line">                delayedStore = groupManager.prepareStoreGroup(group, <span class="type">Map</span>.empty, error =&gt; {</span><br><span class="line">                    <span class="keyword">if</span> (error != <span class="type">Errors</span>.<span class="type">NONE</span>) {</span><br><span class="line">                        warn(<span class="string">s"Failed to write empty metadata for group <span class="subst">${group.groupId}</span>: <span class="subst">${error.message}</span>"</span>)</span><br><span class="line">                    }</span><br><span class="line">                })</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                info(<span class="string">s"Stabilized group <span class="subst">${group.groupId}</span> generation <span class="subst">${group.generationId}</span>"</span>)</span><br><span class="line">                <span class="comment">// 向 group 名下所有的消费者发送 JoinGroupResponse 响应，</span></span><br><span class="line">                <span class="keyword">for</span> (member &lt;- group.allMemberMetadata) {</span><br><span class="line">                    assert(member.awaitingJoinCallback != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">val</span> joinResult = <span class="type">JoinGroupResult</span>(</span><br><span class="line">                        members = <span class="keyword">if</span> (member.memberId == group.leaderId) {</span><br><span class="line">                            group.currentMemberMetadata</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="type">Map</span>.empty</span><br><span class="line">                        },</span><br><span class="line">                        memberId = member.memberId,</span><br><span class="line">                        generationId = group.generationId,</span><br><span class="line">                        subProtocol = group.protocol,</span><br><span class="line">                        leaderId = group.leaderId,</span><br><span class="line">                        errorCode = <span class="type">Errors</span>.<span class="type">NONE</span>.code)</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 该回调函数在 KafkaApis#handleJoinGroupRequest 中定义（对应 sendResponseCallback 方法），用于将响应对象放入 channel 中等待发送</span></span><br><span class="line">                    member.awaitingJoinCallback(joinResult)</span><br><span class="line">                    member.awaitingJoinCallback = <span class="literal">null</span></span><br><span class="line">                    <span class="comment">// 心跳机制</span></span><br><span class="line">                    <span class="keyword">this</span>.completeAndScheduleNextHeartbeatExpiration(group, member)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 往 offset topic 中追加消息</span></span><br><span class="line">    delayedStore.foreach(groupManager.store)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>DelayedJoin 延时任务在等待期间主要是等待关注的 group 名下的消费者发送 JoinGroupRequest 请求的情况，一旦任务满足执行条件（也可能是因为超时）则执行：</p>
<ol>
<li>剔除那些已知的但是未申请重新加入当前 group 的消费者；</li>
<li>如果目标 group 状态已经为 Dead，则结束任务；</li>
<li>否则，递增 group 的年代信息，并为 group 名下的消费者确定最终的分区分配策略，同时依据名下是否存在消费者来将 group 状态切换成 AwaitingSync 或 Empty；</li>
<li>如果切换后的 group 状态为 Empty，则将空的分区分配结果追加到 topic offset 中；</li>
<li>如果切换后的 group 状态为 AwaitingSync，则向 group 名下所有的消费者发送 JoinGroupResponse 响应，并等待 leader 消费者的 SyncGroupRequest 请求反馈分区的分配结果。</li>
</ol>
<p>其中 <strong>步骤 3</strong> 的实现位于 <code>GroupMetadata#initNextGeneration</code> 方法中，该方法会依据 group 名下是否存在消费者将 group 切换成相应的状态，如果名下存在消费者还会确定最终的分区分配策略。方法实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initNextGeneration</span></span>(): <span class="type">Unit</span> = {</span><br><span class="line">    assert(notYetRejoinedMembers == <span class="type">List</span>.empty[<span class="type">MemberMetadata</span>])</span><br><span class="line">    <span class="keyword">if</span> (members.nonEmpty) {</span><br><span class="line">        generationId += <span class="number">1</span></span><br><span class="line">        <span class="comment">// 基于投票的方式选择一个所有消费者都支持的分区分配策略</span></span><br><span class="line">        protocol = selectProtocol</span><br><span class="line">        transitionTo(<span class="type">AwaitingSync</span>)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        generationId += <span class="number">1</span></span><br><span class="line">        protocol = <span class="literal">null</span></span><br><span class="line">        transitionTo(<span class="type">Empty</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>确定最终的分区分配策略， <strong>简单来说就是从消费者都支持的分区分配策略中投票选举一个得票最高的策略作为最终策略</strong> ，实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectProtocol</span></span>: <span class="type">String</span> = {</span><br><span class="line">    <span class="keyword">if</span> (members.isEmpty)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Cannot select protocol for empty group"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所有消费者都支持的分区分配策略</span></span><br><span class="line">    <span class="keyword">val</span> candidates = candidateProtocols</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择所有消费者都支持的协议作为候选协议集合，</span></span><br><span class="line">    <span class="comment">// 每个消费者都会通过 vote 方法进行投票（为支持的协议中的第一个协议投一票），</span></span><br><span class="line">    <span class="comment">// 最终选择投票最多的分区分配策略</span></span><br><span class="line">    <span class="keyword">val</span> votes: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = allMemberMetadata</span><br><span class="line">            .map(_.vote(candidates))</span><br><span class="line">            .groupBy(identity)</span><br><span class="line">            .mapValues(_.size)</span><br><span class="line">            .toList</span><br><span class="line"></span><br><span class="line">    votes.maxBy(_._2)._1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>其中 <code>MemberMetadata#vote</code> 方法的投票策略实际上就是从消费者自身支持的分区分配策略和 group 名下所有消费者都支持的分区分配策略中选择第 1 个进行投票。</p>
<p><strong>步骤 4</strong> 的实现位于 <code>GroupMetadataManager#prepareStoreGroup</code> 方法中，这一步主要的逻辑就是基于分区分配结果（不过这里的分区分配结果是空集合）创建 Kafka 消息，并写入到 offset topic 中。方法实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepareStoreGroup</span></span>(group: <span class="type">GroupMetadata</span>,</span><br><span class="line">                      groupAssignment: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Byte</span>]],</span><br><span class="line">                      responseCallback: <span class="type">Errors</span> =&gt; <span class="type">Unit</span>): <span class="type">Option</span>[<span class="type">DelayedStore</span>] = {</span><br><span class="line">    <span class="comment">// 依据 group 对应 offset topic 分区的消息版本进行处理</span></span><br><span class="line">    getMagic(partitionFor(group.groupId)) <span class="keyword">match</span> {</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(magicValue) =&gt;</span><br><span class="line">            <span class="keyword">val</span> groupMetadataValueVersion = {</span><br><span class="line">                <span class="keyword">if</span> (interBrokerProtocolVersion &lt; <span class="type">KAFKA_0_10_1_IV0</span>) <span class="number">0.</span>toShort</span><br><span class="line">                <span class="keyword">else</span> <span class="type">GroupMetadataManager</span>.<span class="type">CURRENT_GROUP_VALUE_SCHEMA_VERSION</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> timestampType = <span class="type">TimestampType</span>.<span class="type">CREATE_TIME</span></span><br><span class="line">            <span class="keyword">val</span> timestamp = time.milliseconds()</span><br><span class="line">            <span class="comment">// 创建记录 GroupMetadata 信息的消息，其中 value 是分区的分配结果</span></span><br><span class="line">            <span class="keyword">val</span> record = <span class="type">Record</span>.create(magicValue, timestampType, timestamp,</span><br><span class="line">                <span class="type">GroupMetadataManager</span>.groupMetadataKey(group.groupId),</span><br><span class="line">                <span class="type">GroupMetadataManager</span>.groupMetadataValue(group, groupAssignment, version = groupMetadataValueVersion))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 group 对应的 offset topic 分区对象</span></span><br><span class="line">            <span class="keyword">val</span> groupMetadataPartition = <span class="keyword">new</span> <span class="type">TopicPartition</span>(<span class="type">Topic</span>.<span class="type">GroupMetadataTopicName</span>, partitionFor(group.groupId))</span><br><span class="line">            <span class="comment">// 构造 offset topic 分区与消息集合的映射关系</span></span><br><span class="line">            <span class="keyword">val</span> groupMetadataRecords = <span class="type">Map</span>(groupMetadataPartition -&gt; <span class="type">MemoryRecords</span>.withRecords(timestampType, compressionType, record))</span><br><span class="line">            <span class="keyword">val</span> generationId = group.generationId</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ... 省略 putCacheCallback 回调函数，该函数在消息完成追加到 offset topic 之后被回调，后面再进行分析</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里并没有真正追加消息，而是记录到 DelayedStore 中，具体追加由 GroupMetadataManager#store 方法追加</span></span><br><span class="line">            <span class="type">Some</span>(<span class="type">DelayedStore</span>(groupMetadataRecords, putCacheCallback))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">            responseCallback(<span class="type">Errors</span>.<span class="type">NOT_COORDINATOR_FOR_GROUP</span>)</span><br><span class="line">            <span class="type">None</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法会基于分区分配结果创建 Kafka 消息并写入到 offset topic 对应的分区中（前面的小节分析 GroupCoordinator 故障转移时有基于此类消息在新的 GroupCoordinator 节点上恢复 group 的元数据信息），需要注意的是这里并没有执行真正的写入操作，而是将待写入的数据和写入完成的回调函数封装成 DelayedStore 对象，等待后续调用 <code>GroupMetadataManager#store</code> 方法时才执行真正的写入操作：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">store</span></span>(delayedStore: <span class="type">DelayedStore</span>) {</span><br><span class="line">    <span class="comment">// 调用 ReplicaManager#appendRecords 方法往 offset topic 中追加消息</span></span><br><span class="line">    replicaManager.appendRecords(</span><br><span class="line">        config.offsetCommitTimeoutMs.toLong,</span><br><span class="line">        config.offsetCommitRequiredAcks, <span class="comment">// -1，需要 ISR 集合中所有的副本都同步了该消息才认为消息成功追加</span></span><br><span class="line">        internalTopicsAllowed = <span class="literal">true</span>, <span class="comment">// 指定允许向内部 topic 追加消息，即 offset topic</span></span><br><span class="line">        delayedStore.partitionRecords, <span class="comment">// 分区与对应消息之间的映射</span></span><br><span class="line">        delayedStore.callback) <span class="comment">// 回调函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法中的回调函数实际上也就是在 <code>GroupMetadataManager#prepareStoreGroup</code> 方法中定义的 putCacheCallback 方法，当消息被追加到 offset topic 中后会回调执行该方法：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">putCacheCallback</span></span>(responseStatus: <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">PartitionResponse</span>]) {</span><br><span class="line">    <span class="keyword">if</span> (responseStatus.size != <span class="number">1</span> || !responseStatus.contains(groupMetadataPartition))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Append status %s should only have one partition %s"</span>.format(responseStatus, groupMetadataPartition))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息追加响应结果</span></span><br><span class="line">    <span class="keyword">val</span> status = responseStatus(groupMetadataPartition)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> responseError = <span class="keyword">if</span> (status.error == <span class="type">Errors</span>.<span class="type">NONE</span>) {</span><br><span class="line">        <span class="comment">// 追加成功</span></span><br><span class="line">        <span class="type">Errors</span>.<span class="type">NONE</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// ... 追加异常，对错误码执行一些转换操作，省略</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行回调函数</span></span><br><span class="line">    responseCallback(responseError)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>当消息被追加到 offset topic 中之后会依据消息的追加结果封装成对应的错误码，并回调 responseCallback 方法，这是一个 <code>Errors =&gt; Unit</code> 的函数，在本步骤中该函数只是简单的在追加失败时打印一行警告日志，毕竟追加的消息本来就是空的。</p>

        <h4 id="SyncGroupRequest-请求处理">
          <a href="#SyncGroupRequest-请求处理" class="heading-link"><i class="fas fa-link"></i></a>SyncGroupRequest 请求处理</h4>
      <p>对于 GroupCoordinator 实例而言，分区再分配操作的最后一步是处理来自 leader 消费者的 SyncGroupRequest 请求，以获取 leader 消费者基于服务端确定的分区分配策略为当前 group 名下消费者分配分区的结果信息。KafkaApis 中定义了 <code>KafkaApis#handleSyncGroupRequest</code> 方法处理该请求，而具体的处理逻辑则交由 <code>GroupCoordinator#handleSyncGroup</code> 方法实现，该方法首先会校验 GroupCoordinator 实例的运行状态，保证能够处理来自对应消费者的 SyncGroupRequest 请求，具体处理逻辑实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doSyncGroup</span></span>(group: <span class="type">GroupMetadata</span>,</span><br><span class="line">                        generationId: <span class="type">Int</span>,</span><br><span class="line">                        memberId: <span class="type">String</span>,</span><br><span class="line">                        groupAssignment: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Array</span>[<span class="type">Byte</span>]],</span><br><span class="line">                        responseCallback: <span class="type">SyncCallback</span>) {</span><br><span class="line">    <span class="keyword">var</span> delayedGroupStore: <span class="type">Option</span>[<span class="type">DelayedStore</span>] = <span class="type">None</span></span><br><span class="line"></span><br><span class="line">    group synchronized {</span><br><span class="line">        <span class="keyword">if</span> (!group.has(memberId)) {</span><br><span class="line">            <span class="comment">// 当前消费者不属于该 group</span></span><br><span class="line">            responseCallback(<span class="type">Array</span>.empty, <span class="type">Errors</span>.<span class="type">UNKNOWN_MEMBER_ID</span>.code)</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (generationId != group.generationId) {</span><br><span class="line">            <span class="comment">// group 年代信息不合法</span></span><br><span class="line">            responseCallback(<span class="type">Array</span>.empty, <span class="type">Errors</span>.<span class="type">ILLEGAL_GENERATION</span>.code)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            group.currentState <span class="keyword">match</span> {</span><br><span class="line">                <span class="keyword">case</span> <span class="type">Empty</span> | <span class="type">Dead</span> =&gt;</span><br><span class="line">                    <span class="comment">// 直接返回错误码</span></span><br><span class="line">                    responseCallback(<span class="type">Array</span>.empty, <span class="type">Errors</span>.<span class="type">UNKNOWN_MEMBER_ID</span>.code)</span><br><span class="line">                <span class="keyword">case</span> <span class="type">PreparingRebalance</span> =&gt;</span><br><span class="line">                    <span class="comment">// 直接返回错误码</span></span><br><span class="line">                    responseCallback(<span class="type">Array</span>.empty, <span class="type">Errors</span>.<span class="type">REBALANCE_IN_PROGRESS</span>.code)</span><br><span class="line">                <span class="keyword">case</span> <span class="type">AwaitingSync</span> =&gt;</span><br><span class="line">                    <span class="comment">// 设置对应消费者的响应回调函数</span></span><br><span class="line">                    group.get(memberId).awaitingSyncCallback = responseCallback</span><br><span class="line">                    <span class="comment">// 仅处理来自 leader 消费者发来的 SyncGroupRequest 请求</span></span><br><span class="line">                    <span class="keyword">if</span> (memberId == group.leaderId) {</span><br><span class="line">                        info(<span class="string">s"Assignment received from leader for group <span class="subst">${group.groupId}</span> for generation <span class="subst">${group.generationId}</span>"</span>)</span><br><span class="line">                        <span class="comment">// 将未分配分区的消费者对应的分区分配结果填充为空的字节数组</span></span><br><span class="line">                        <span class="keyword">val</span> missing = group.allMembers -- groupAssignment.keySet</span><br><span class="line">                        <span class="keyword">val</span> assignment = groupAssignment ++ missing.map(_ -&gt; <span class="type">Array</span>.empty[<span class="type">Byte</span>]).toMap</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 GroupMetadata 相关信息以消息的形式写入到对应的 offset topic 分区中</span></span><br><span class="line">                        delayedGroupStore = groupManager.prepareStoreGroup(group, assignment,</span><br><span class="line">                            <span class="comment">// ... 追加消息完成的回调响应逻辑，省略，后面针对性分析</span></span><br><span class="line">                            )</span><br><span class="line">                    }</span><br><span class="line">                <span class="keyword">case</span> <span class="type">Stable</span> =&gt;</span><br><span class="line">                    <span class="comment">// 将已有的分区分配结果返回给当前消费者</span></span><br><span class="line">                    <span class="keyword">val</span> memberMetadata = group.get(memberId)</span><br><span class="line">                    responseCallback(memberMetadata.assignment, <span class="type">Errors</span>.<span class="type">NONE</span>.code)</span><br><span class="line">                    <span class="comment">// 心跳相关操作</span></span><br><span class="line">                    <span class="keyword">this</span>.completeAndScheduleNextHeartbeatExpiration(group, group.get(memberId))</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行写 offset topic 逻辑</span></span><br><span class="line">    delayedGroupStore.foreach(groupManager.store)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>GroupCoordinator 依赖于目标 group 的当前状态对 SyncGroupRequest 请求分而治之，对于 Empty、Dead 和 PreparingRebalance 状态而言直接返回对应的错误码，此时没有正常响应 SyncGroupRequest 请求的意义和条件，下面主要分析一下 AwaitingSync 和 Stable 状态。</p>
<p>对于 AwaitingSync 状态而言，此时 GroupCoordinator 正在等待 leader 消费者的分区分配结果（即 SyncGroupRequest 请求），所以位于此状态的 group 只处理来自 leader 消费者的 SyncGroupRequest 请求。如果消费者的数目多于 topic 的分区数，则多出来的消费者不会分配分区，因为 Kafka 在设计上要求一个分区至多被一个消费者消费，所以这些多出来的消费者的分区分配信息会被置空。然后 GroupCoordinator 实例会调用 <code>GroupMetadataManager#prepareStoreGroup</code> 方法将分区分配信息写入到 offset topic 中，该方法的执行逻辑已在前面分析过，所以这里不再重复撰述，重点来看一下该方法的回调函数实现。我们前面已经介绍了当消息完成追加到 offset topic 中之后会回调参数指定的回调函数，而这里的回调逻辑实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(error: <span class="type">Errors</span>) =&gt; {</span><br><span class="line">    group synchronized {</span><br><span class="line">        <span class="comment">// 检查 group 的状态（正在等待 leader 消费者将分区的分配结果发送给 GroupCoordinator）和年代信息</span></span><br><span class="line">        <span class="keyword">if</span> (group.is(<span class="type">AwaitingSync</span>) &amp;&amp; generationId == group.generationId) {</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="type">Errors</span>.<span class="type">NONE</span>) {</span><br><span class="line">                <span class="comment">// 清空分区的分配结果，并发送异常响应</span></span><br><span class="line">                resetAndPropagateAssignmentError(group, error)</span><br><span class="line">                <span class="comment">// 切换 group 状态为 PreparingRebalance，再次尝试分配分区</span></span><br><span class="line">                maybePrepareRebalance(group)</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 设置分区的分配结果，发送正常的 SyncGroupResponse 响应</span></span><br><span class="line">                setAndPropagateAssignment(group, assignment)</span><br><span class="line">                group.transitionTo(<span class="type">Stable</span>)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果追加消息失败，则在回调逻辑中会清空分区的分配结果，并将错误信息返回给 leader 消费者，同时 GroupCoordinator 实例会切换状态为 PreparingRebalance 准备再次尝试分配分区。如果追加消息成功，则会将分区分配结果更新到 group 名下对应消费者的元数据信息中，同时向 leader 消费者响应正常的 SyncGroupResponse，同时切换 group 的状态为 Stable，开始正常运行。</p>
<p>对于 Stable 状态而言，此时 group 处于正常运行中，所以对于来自消费者的 SyncGroupRequest 请求，只是简单将历史的分区分配结果直接返回，不做特殊处理。</p>

        <h3 id="消费者请求处理">
          <a href="#消费者请求处理" class="heading-link"><i class="fas fa-link"></i></a>消费者请求处理</h3>
      
        <h4 id="OffsetFetchRequest-请求处理">
          <a href="#OffsetFetchRequest-请求处理" class="heading-link"><i class="fas fa-link"></i></a>OffsetFetchRequest 请求处理</h4>
      <p>当完成执行分区再分配操作之后，消费者一般会被重新分配新的分区，此时消费者需要向集群发送 OffsetFetchRequest 请求以获取对应 topic 分区上次消费者的 offset 值，并从该位置继续消费，以防止消息的重复消费或遗漏消费。</p>
<p>KafkaApis 定义了 <code>KafkaApis#handleOffsetFetchRequest</code> 方法用于处理 OffsetFetchRequest 请求，该方法会对请求的 topic 分区执行权限校验，如果校验通过则会依据请求中指定的版本号决定是从 ZK 还是 offset topic 中获取目标 topic 分区的 offset 位置信息。目前新版本的 Kafka 为了避免 ZK 压力对于服务可用性的影响，已经默认使用 offset topic 取代 ZK 记录消费者消费的 offset 位置信息，所以本小节仅介绍基于 offset topic 的 OffsetFetchRequest 请求处理过程。</p>
<p>具体的处理逻辑交由 <code>GroupCoordinator#handleFetchOffsets</code> 方法执行，如果在请求中未指明要获取 offset 的 topic 分区，则表示期望获取当前 group 范围内所有 topicc 分区最近一次提交的 offset 值。方法实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleFetchOffsets</span></span>(groupId: <span class="type">String</span>, partitions: <span class="type">Option</span>[<span class="type">Seq</span>[<span class="type">TopicPartition</span>]] = <span class="type">None</span>): (<span class="type">Errors</span>, <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">OffsetFetchResponse</span>.<span class="type">PartitionData</span>]) = {</span><br><span class="line">    <span class="keyword">if</span> (!isActive.get) {</span><br><span class="line">        <span class="comment">// 当前 GroupCoordinator 实例未启动运行</span></span><br><span class="line">        (<span class="type">Errors</span>.<span class="type">GROUP_COORDINATOR_NOT_AVAILABLE</span>, <span class="type">Map</span>())</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!isCoordinatorForGroup(groupId)) {</span><br><span class="line">        <span class="comment">// 当前 GroupCoordinator 实例并不负责管理当前 group</span></span><br><span class="line">        debug(<span class="string">"Could not fetch offsets for group %s (not group coordinator)."</span>.format(groupId))</span><br><span class="line">        (<span class="type">Errors</span>.<span class="type">NOT_COORDINATOR_FOR_GROUP</span>, <span class="type">Map</span>())</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (isCoordinatorLoadingInProgress(groupId)) {</span><br><span class="line">        <span class="comment">// 当前 GroupCoordinator 实例正在加载该 group 对应的 offset topic 分区信息</span></span><br><span class="line">        (<span class="type">Errors</span>.<span class="type">GROUP_LOAD_IN_PROGRESS</span>, <span class="type">Map</span>())</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 返回指定 topic 分区集合对应的最近一次提交的 offset 位置信息</span></span><br><span class="line">        (<span class="type">Errors</span>.<span class="type">NONE</span>, groupManager.getOffsets(groupId, partitions))</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOffsets</span></span>(groupId: <span class="type">String</span>, topicPartitionsOpt: <span class="type">Option</span>[<span class="type">Seq</span>[<span class="type">TopicPartition</span>]]): <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">OffsetFetchResponse</span>.<span class="type">PartitionData</span>] = {</span><br><span class="line">    trace(<span class="string">"Getting offsets of %s for group %s."</span>.format(topicPartitionsOpt.getOrElse(<span class="string">"all partitions"</span>), groupId))</span><br><span class="line">    <span class="comment">// 获取 group 对应的元数据信息</span></span><br><span class="line">    <span class="keyword">val</span> group = groupMetadataCache.get(groupId)</span><br><span class="line">    <span class="keyword">if</span> (group == <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// group 对应的元数据信息不存在，则统一返回 offset 为 -1</span></span><br><span class="line">        topicPartitionsOpt.getOrElse(<span class="type">Seq</span>.empty[<span class="type">TopicPartition</span>]).map { topicPartition =&gt;</span><br><span class="line">            (topicPartition, <span class="keyword">new</span> <span class="type">OffsetFetchResponse</span>.<span class="type">PartitionData</span>(<span class="type">OffsetFetchResponse</span>.<span class="type">INVALID_OFFSET</span>, <span class="string">""</span>, <span class="type">Errors</span>.<span class="type">NONE</span>))</span><br><span class="line">        }.toMap</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        group synchronized {</span><br><span class="line">            <span class="keyword">if</span> (group.is(<span class="type">Dead</span>)) {</span><br><span class="line">                <span class="comment">// 对应的 group 名下已经没有消费者，并且元数据信息已经被删除</span></span><br><span class="line">                topicPartitionsOpt.getOrElse(<span class="type">Seq</span>.empty[<span class="type">TopicPartition</span>]).map { topicPartition =&gt;</span><br><span class="line">                    (topicPartition, <span class="keyword">new</span> <span class="type">OffsetFetchResponse</span>.<span class="type">PartitionData</span>(<span class="type">OffsetFetchResponse</span>.<span class="type">INVALID_OFFSET</span>, <span class="string">""</span>, <span class="type">Errors</span>.<span class="type">NONE</span>))</span><br><span class="line">                }.toMap</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                topicPartitionsOpt <span class="keyword">match</span> {</span><br><span class="line">                    <span class="comment">// 请求未指定 topic 分区，表示请求 group 名下全部 topic 分区对应的最近一次提交的 offset 值</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">                        group.allOffsets.map { <span class="keyword">case</span> (topicPartition, offsetAndMetadata) =&gt;</span><br><span class="line">                            topicPartition -&gt; <span class="keyword">new</span> <span class="type">OffsetFetchResponse</span>.<span class="type">PartitionData</span>(offsetAndMetadata.offset, offsetAndMetadata.metadata, <span class="type">Errors</span>.<span class="type">NONE</span>)</span><br><span class="line">                        }</span><br><span class="line">                    <span class="comment">// 查找指定 topic 分区集合对应的最近一次提交的 offset 值</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="type">Some</span>(_) =&gt;</span><br><span class="line">                        topicPartitionsOpt.getOrElse(<span class="type">Seq</span>.empty[<span class="type">TopicPartition</span>]).map { topicPartition =&gt;</span><br><span class="line">                            <span class="keyword">val</span> partitionData = group.offset(topicPartition) <span class="keyword">match</span> {</span><br><span class="line">                                <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">                                    <span class="keyword">new</span> <span class="type">OffsetFetchResponse</span>.<span class="type">PartitionData</span>(<span class="type">OffsetFetchResponse</span>.<span class="type">INVALID_OFFSET</span>, <span class="string">""</span>, <span class="type">Errors</span>.<span class="type">NONE</span>)</span><br><span class="line">                                <span class="keyword">case</span> <span class="type">Some</span>(offsetAndMetadata) =&gt;</span><br><span class="line">                                    <span class="keyword">new</span> <span class="type">OffsetFetchResponse</span>.<span class="type">PartitionData</span>(offsetAndMetadata.offset, offsetAndMetadata.metadata, <span class="type">Errors</span>.<span class="type">NONE</span>)</span><br><span class="line">                            }</span><br><span class="line">                            topicPartition -&gt; partitionData</span><br><span class="line">                        }.toMap</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Group 元数据信息的 <code>GroupMetadata#offsets</code> 字段缓存了每个 topic 分区最近一次提交的 offset 位置信息和用户自定义数据，所以这里只要获取对应 topic 分区的 offset 值即可。</p>

        <h4 id="OffsetCommitRequest-请求处理">
          <a href="#OffsetCommitRequest-请求处理" class="heading-link"><i class="fas fa-link"></i></a>OffsetCommitRequest 请求处理</h4>
      <p>消费者在完成对指定 offset 的消费之后，会基于配置和相应的场景以 OffsetCommitRequest 请求的方式向服务端提交该 offset 值。服务端在接收到 OffsetCommitRequest 请求之后，需要为每个消费者记录对应 topic 分区的消费位置。</p>
<p>KafkaApis 定义了 <code>KafkaApis#handleOffsetCommitRequest</code> 方法用于处理 OffsetCommitRequest 请求，该方法会校验目标 topic 是否存在，以及是否有对于该 topic 的读取权限，如果满足条件则会依据请求中指定的版本号决定将对应的 offset 位置信息记录到 ZK 还是 offset topic，本小节同样仅介绍基于 offset topic 的 OffsetCommitRequest 请求处理过程。</p>
<p>具体的处理逻辑交由 <code>GroupCoordinator#handleCommitOffsets</code> 方法执行，该方法首先会校验 GroupCoordinator 的状态，确保能够正常处理当前 OffsetCommitRequest 请求，并在允许的条件下调用 <code>GroupCoordinator#doCommitOffsets</code> 方法将 offset 消费位置信息封装成消息追加到 offset topic 中：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doCommitOffsets</span></span>(group: <span class="type">GroupMetadata</span>,</span><br><span class="line">                            memberId: <span class="type">String</span>,</span><br><span class="line">                            generationId: <span class="type">Int</span>,</span><br><span class="line">                            offsetMetadata: immutable.<span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">OffsetAndMetadata</span>],</span><br><span class="line">                            responseCallback: immutable.<span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">Short</span>] =&gt; <span class="type">Unit</span>) {</span><br><span class="line">    <span class="keyword">var</span> delayedOffsetStore: <span class="type">Option</span>[<span class="type">DelayedStore</span>] = <span class="type">None</span></span><br><span class="line"></span><br><span class="line">    group synchronized {</span><br><span class="line">        <span class="keyword">if</span> (group.is(<span class="type">Dead</span>)) {</span><br><span class="line">            <span class="comment">// 目标 group 已经失效，直接响应错误码</span></span><br><span class="line">            responseCallback(offsetMetadata.mapValues(_ =&gt; <span class="type">Errors</span>.<span class="type">UNKNOWN_MEMBER_ID</span>.code))</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (generationId &lt; <span class="number">0</span> &amp;&amp; group.is(<span class="type">Empty</span>)) {</span><br><span class="line">            <span class="comment">// 目标 group 的信息不是由 kafka 维护，而仅仅依赖于 kafka 记录 offset 消费信息</span></span><br><span class="line">            delayedOffsetStore = groupManager.prepareStoreOffsets(group, memberId, generationId, offsetMetadata, responseCallback)</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (group.is(<span class="type">AwaitingSync</span>)) {</span><br><span class="line">            <span class="comment">// 目标 group 目前正在执行分区再分配操作</span></span><br><span class="line">            responseCallback(offsetMetadata.mapValues(_ =&gt; <span class="type">Errors</span>.<span class="type">REBALANCE_IN_PROGRESS</span>.code))</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!group.has(memberId)) {</span><br><span class="line">            <span class="comment">// 目标 group 并不包含当前消费者</span></span><br><span class="line">            responseCallback(offsetMetadata.mapValues(_ =&gt; <span class="type">Errors</span>.<span class="type">UNKNOWN_MEMBER_ID</span>.code))</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (generationId != group.generationId) {</span><br><span class="line">            <span class="comment">// 目标 group 年代信息不一致</span></span><br><span class="line">            responseCallback(offsetMetadata.mapValues(_ =&gt; <span class="type">Errors</span>.<span class="type">ILLEGAL_GENERATION</span>.code))</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 将记录 offset 信息的消息追加到对应的 offset topic 对应分区中</span></span><br><span class="line">            <span class="keyword">val</span> member = group.get(memberId)</span><br><span class="line">            completeAndScheduleNextHeartbeatExpiration(group, member)</span><br><span class="line">            delayedOffsetStore = groupManager.prepareStoreOffsets(group, memberId, generationId, offsetMetadata, responseCallback)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行真正的追加消息操作</span></span><br><span class="line">    delayedOffsetStore.foreach(groupManager.store)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>具体追加消息到 offset topic 的过程已在前面分析过，不再重复撰述。</p>

        <h4 id="LeaveGroupRequest-请求处理">
          <a href="#LeaveGroupRequest-请求处理" class="heading-link"><i class="fas fa-link"></i></a>LeaveGroupRequest 请求处理</h4>
      <p>当消费者取消对指定 topic 的订阅，或者配置了 <code>internal.leave.group.on.close=true</code> 指明在关闭消费者时一同退出所属的 group，以及消费者因一些异常原因离线时，会向对应的 GroupCoordinator 节点发送 LeaveGroupRequest 请求，已告知集群对应的消费者已经失效，可能需要触发分区再分配操作。</p>
<p>KafkaApis 定义了 <code>KafkaApis#handleLeaveGroupRequest</code> 方法用于处理 LeaveGroupRequest 请求，该方法首先会对消费者执行权限校验，并在权限校验通过的前提下委托 GroupCoordinator 处理相应的离线策略。具体逻辑实现位于 <code>GroupCoordinator#handleLeaveGroup</code> 方法中：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleLeaveGroup</span></span>(groupId: <span class="type">String</span>, memberId: <span class="type">String</span>, responseCallback: <span class="type">Short</span> =&gt; <span class="type">Unit</span>) {</span><br><span class="line">    <span class="keyword">if</span> (!isActive.get) {</span><br><span class="line">        <span class="comment">// GroupCoordinator 实例未启动</span></span><br><span class="line">        responseCallback(<span class="type">Errors</span>.<span class="type">GROUP_COORDINATOR_NOT_AVAILABLE</span>.code)</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!isCoordinatorForGroup(groupId)) {</span><br><span class="line">        <span class="comment">// 当前 GroupCoordinator 实例并不负责管理当前 group</span></span><br><span class="line">        responseCallback(<span class="type">Errors</span>.<span class="type">NOT_COORDINATOR_FOR_GROUP</span>.code)</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (isCoordinatorLoadingInProgress(groupId)) {</span><br><span class="line">        <span class="comment">// 当前 GroupCoordinator 实例正在加载该 group 对应的 offset topic 分区信息</span></span><br><span class="line">        responseCallback(<span class="type">Errors</span>.<span class="type">GROUP_LOAD_IN_PROGRESS</span>.code)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        groupManager.getGroup(groupId) <span class="keyword">match</span> {</span><br><span class="line">            <span class="comment">// 对应的 group 不存在或已经失效</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">                responseCallback(<span class="type">Errors</span>.<span class="type">UNKNOWN_MEMBER_ID</span>.code)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Some</span>(group) =&gt;</span><br><span class="line">                group synchronized {</span><br><span class="line">                    <span class="keyword">if</span> (group.is(<span class="type">Dead</span>) || !group.has(memberId)) {</span><br><span class="line">                        responseCallback(<span class="type">Errors</span>.<span class="type">UNKNOWN_MEMBER_ID</span>.code)</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">val</span> member = group.get(memberId)</span><br><span class="line">                        <span class="comment">// 设置 MemberMetadata#isLeaving 为 true，并尝试完成对应的 DelayedHeartbeat 延时任务</span></span><br><span class="line">                        <span class="keyword">this</span>.removeHeartbeatForLeavingMember(group, member)</span><br><span class="line">                        <span class="comment">// 从 group 元数据信息中移除对应的 MemberMetadata 对象，并切换状态</span></span><br><span class="line">                        <span class="keyword">this</span>.onMemberFailure(group, member)</span><br><span class="line">                        <span class="comment">// 调用回调响应函数</span></span><br><span class="line">                        responseCallback(<span class="type">Errors</span>.<span class="type">NONE</span>.code)</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果发送 LeaveGroupRequest 请求的消费者所属的 group 存在且运行正常，则服务端首先会将对应消费者元数据信息的 <code>MemberMetadata#isLeaving</code> 字段设置为 true，标识当前消费者已经离线，并尝试触发关注当前消费者的 DelayedHeartbeat 延时任务。此外，还会将该消费者从之前所属的 group 元数据信息中移除，并依据 group 当前的状态决定是触发分区再分配操作，还是触发执行关注该 group 的 DelayedJoin 延时任务，相关实现位于 <code>GroupCoordinator#onMemberFailure</code> 方法中，前面已经分析过该方法，这里不再重复撰述。</p>

        <h3 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>本文我们分析了 GroupCoordinator 组件的作用和实现，该组件与消费者之间关系密切，消费者在运行期间除了从 ReplicaManager 组件拉取消息进行消费，剩余的交互基本都由 GroupCoordinator 组件负责处理。Kafka 依赖该组件对消费者所属的 group 实施管理，并对 group 名下的消费者进行协调，主要提供了分区分配与再平衡支持、记录 group 的消费 offset 位置信息，以及维护与消费者之间的心跳等功能。此外，GroupCoordinator 内置了故障转移机制，以保证在 topic offset 对应分区 leader 副本失效时，能够切换到新的 GroupCoordinator 实例继续对外提供服务。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2019/06/25/kafka/kafka-group-coordinator/">https://plotor.github.io/2019/06/25/kafka/kafka-group-coordinator/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/Kafka/">Kafka</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2019/06/26/kafka/kafka-controller/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Kafka 源码解析：集群协同运行控制器</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2019/06/24/kafka/kafka-replica/"><span class="paginator-prev__text">Kafka 源码解析：分区多副本容错机制</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#GroupCoordinator-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%90%AF%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">
          GroupCoordinator 组件的定义与启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Group-%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">
          Group 状态定义与转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">
          故障转移机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%8A%A5%E6%B4%BB%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">
          心跳报活机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%86%8D%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">
          分区再分配机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GroupCoordinatorRequest-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">
          GroupCoordinatorRequest 请求处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JoinGroupRequest-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">
          JoinGroupRequest 请求处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SyncGroupRequest-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">
          SyncGroupRequest 请求处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">
          消费者请求处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OffsetFetchRequest-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">
          OffsetFetchRequest 请求处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OffsetCommitRequest-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">
          OffsetCommitRequest 请求处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LeaveGroupRequest-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">
          LeaveGroupRequest 请求处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">
          总结</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">96</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">14</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">29</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2025</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>