<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="由上一篇分析可知，在 broker 节点启动过程中会创建一个 SocketServer 类型的对象，并调用其 SocketServer#startup 方法执行组件的启动过程。SocketServer 是 Kafka 对外提供网络服务的核心实现类，在 Kafka 运行过程中用于接收来自客户端和其它 broker 节点的网络请求。考虑到性能上的需求，SocketServer 采用了 Reactor">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka 源码解析：网络交互模型">
<meta property="og:url" content="https://plotor.github.io/2019/06/21/kafka/kafka-reactor/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="由上一篇分析可知，在 broker 节点启动过程中会创建一个 SocketServer 类型的对象，并调用其 SocketServer#startup 方法执行组件的启动过程。SocketServer 是 Kafka 对外提供网络服务的核心实现类，在 Kafka 运行过程中用于接收来自客户端和其它 broker 节点的网络请求。考虑到性能上的需求，SocketServer 采用了 Reactor">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://plotor.github.io/images/2019/kafka-reactor.png">
<meta property="article:published_time" content="2019-06-21T05:56:18.000Z">
<meta property="article:modified_time" content="2024-09-30T09:38:40.720Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://plotor.github.io/images/2019/kafka-reactor.png"><title>Kafka 源码解析：网络交互模型 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2019/06/21/kafka/kafka-reactor/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Kafka 源码解析：网络交互模型</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-06-21</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">5.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">25分</span></span></div></header><div class="post-body"><p>由上一篇分析可知，在 broker 节点启动过程中会创建一个 SocketServer 类型的对象，并调用其 <code>SocketServer#startup</code> 方法执行组件的启动过程。SocketServer 是 Kafka 对外提供网络服务的核心实现类，在 Kafka 运行过程中用于接收来自客户端和其它 broker 节点的网络请求。考虑到性能上的需求，SocketServer 采用了 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://www.zhenchao.org/2017/10/23/design-pattern/reactor/">Reactor</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 模式，并基于 java NIO 实现。</p>
<p>参考如下示意图，Kafka 为 broker 所在宿主机的每一张网卡创建并绑定了一个 Acceptor 组件，用于接收并处理所有的连接请求；每个 Acceptor 组件维护多个 Processor 线程，其中每个 Processor 拥有专属的 Selector，用于从连接中读取请求和写回响应；每个 Acceptor 组件同时维护多个 Handler 线程，用于处理请求并生成响应传递给 Processor，而 Handler 与 Processor 之间通过请求队列进行通信。<a id="more"></a></p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2019/kafka-reactor.png" alt="image">
      </p>

        <h3 id="SocketServer-组件">
          <a href="#SocketServer-组件" class="heading-link"><i class="fas fa-link"></i></a>SocketServer 组件</h3>
      <p>SocketServer 是整个 kafka server 网络模型的管家类，主要用于构建和启动整个网络模块。SocketServer 类的字段定义如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span>(<span class="params">val config: <span class="type">KafkaConfig</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                   val metrics: <span class="type">Metrics</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                   val time: <span class="type">Time</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                   val credentialProvider: <span class="type">CredentialProvider</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 封装服务器对应的多张网卡，kafka 可以同时监听这些 IP 和端口，每个 EndPoint 对应一个 Acceptor */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> endpoints: <span class="type">Map</span>[<span class="type">ListenerName</span>, <span class="type">EndPoint</span>] = config.listeners.map(l =&gt; l.listenerName -&gt; l).toMap</span><br><span class="line">    <span class="comment">/** 每个 Acceptor 对应的 Processor 对应的线程数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> numProcessorThreads = config.numNetworkThreads</span><br><span class="line">    <span class="comment">/** broker 节点上 Processor 线程总数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> totalProcessorThreads = numProcessorThreads * endpoints.size</span><br><span class="line">    <span class="comment">/** 请求队列中缓存的最大请求个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> maxQueuedRequests = config.queuedMaxRequests</span><br><span class="line">    <span class="comment">/** 每个 IP 允许创建的最大连接数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> maxConnectionsPerIp = config.maxConnectionsPerIp</span><br><span class="line">    <span class="comment">/** 针对特定 IP 指定的允许创建的最大连接数，会覆盖 maxConnectionsPerIp 配置 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> maxConnectionsPerIpOverrides = config.maxConnectionsPerIpOverrides</span><br><span class="line">    <span class="comment">/** Processor 线程与 Handler 线程之间交换数据的通道 */</span></span><br><span class="line">    <span class="keyword">val</span> requestChannel = <span class="keyword">new</span> <span class="type">RequestChannel</span>(totalProcessorThreads, maxQueuedRequests)</span><br><span class="line">    <span class="comment">/** Acceptor 对象集合，每个 EndPoint 对应一个 Acceptor */</span></span><br><span class="line">    <span class="keyword">private</span>[network] <span class="keyword">val</span> acceptors = mutable.<span class="type">Map</span>[<span class="type">EndPoint</span>, <span class="type">Acceptor</span>]()</span><br><span class="line">    <span class="comment">/** Processor 对象集合，封装所有的 Processor 对象 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> processors = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Processor</span>](totalProcessorThreads)</span><br><span class="line">    <span class="comment">/** 用于控制每个 IP 上的最大连接数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> connectionQuotas: <span class="type">ConnectionQuotas</span> = _</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略方法定义</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>各字段的含义参考注释，其中 EndPoint 类用于封装服务器对应的 host、port，以及网络协议等信息，而 RequestChannel 类定义了 Processor 和 Handler 之间交换数据的通道，该类的字段定义如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestChannel</span>(<span class="params">val numProcessors: <span class="type">Int</span>, // <span class="type">Processor</span> 线程总数</span></span></span><br><span class="line"><span class="class"><span class="params">                     val queueSize: <span class="type">Int</span> // 请求队列的大小</span></span></span><br><span class="line"><span class="class"><span class="params">                    </span>) <span class="keyword">extends</span> <span class="title">KafkaMetricsGroup</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 响应监听器列表，当 Handler 往响应队列写回响应数据时唤醒对应的 Processor 线程进行处理 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> responseListeners: <span class="type">List</span>[<span class="type">Int</span> =&gt; <span class="type">Unit</span>] = <span class="type">Nil</span></span><br><span class="line">    <span class="comment">/** 请求队列，所有的 Processor 共用一个 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> requestQueue = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Request</span>](queueSize)</span><br><span class="line">    <span class="comment">/** 响应队列，每个 Processor 对应一个响应队列 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseQueues = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">BlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Response</span>]](numProcessors)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略方法定义</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>RequestChannel 封装了请求队列和响应队列，这里需要注意的一点是请求队列是 Processor 线程共享的，而响应队列则是每个 Processor 线程专属的。Processor 负责将读取到的请求写入请求队列中，并从自己的响应队列中取出响应对象发送给请求方。Handler 负责从请求队列中读取请求进行处理，并在处理完成之后将响应对象写入到之前读取该请求的 Processor 的响应队列中。关于 Acceptor、Processor 和 Handler 的实现下文会专门进行分析，这里我们先来看一下 SocketServer 的启动逻辑，位于 <code>SocketServer#startup</code> 方法中，实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startup</span></span>() {</span><br><span class="line">    synchronized {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建控制 IP 最大连接数的 ConnectionQuotas 对象</span></span><br><span class="line">        connectionQuotas = <span class="keyword">new</span> <span class="type">ConnectionQuotas</span>(maxConnectionsPerIp, maxConnectionsPerIpOverrides)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定 socket send buffer 的大小（对应 socket.send.buffer.bytes 配置）</span></span><br><span class="line">        <span class="keyword">val</span> sendBufferSize = config.socketSendBufferBytes</span><br><span class="line">        <span class="comment">// 指定 socket receive buffer 的大小（对应 socket.receive.buffer.bytes 配置）</span></span><br><span class="line">        <span class="keyword">val</span> recvBufferSize = config.socketReceiveBufferBytes</span><br><span class="line">        <span class="comment">// 获取 broker 节点 ID</span></span><br><span class="line">        <span class="keyword">val</span> brokerId = config.brokerId</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> processorBeginIndex = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 遍历为每个 EndPoint，创建并绑定对应的 Acceptor 和 Processor</span></span><br><span class="line">        config.listeners.foreach { endpoint =&gt;</span><br><span class="line">            <span class="keyword">val</span> listenerName = endpoint.listenerName</span><br><span class="line">            <span class="keyword">val</span> securityProtocol = endpoint.securityProtocol</span><br><span class="line">            <span class="keyword">val</span> processorEndIndex = processorBeginIndex + numProcessorThreads</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照指定的 processor 线程数，为每个 EndPoint 创建对应数量的 Processor 对象，</span></span><br><span class="line">            <span class="comment">// 编号区间 [processorBeginIndex, processorEndIndex)</span></span><br><span class="line">            <span class="keyword">for</span> (i &lt;- processorBeginIndex until processorEndIndex)</span><br><span class="line">                processors(i) = <span class="keyword">this</span>.newProcessor(i, connectionQuotas, listenerName, securityProtocol)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为当前 EndPoint 创建并绑定一个 Acceptor 对象</span></span><br><span class="line">            <span class="keyword">val</span> acceptor = <span class="keyword">new</span> <span class="type">Acceptor</span>(endpoint, sendBufferSize, recvBufferSize, brokerId,</span><br><span class="line">                processors.slice(processorBeginIndex, processorEndIndex), connectionQuotas)</span><br><span class="line">            acceptors.put(endpoint, acceptor)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动 Acceptor 线程</span></span><br><span class="line">            <span class="type">Utils</span>.newThread(<span class="string">s"kafka-socket-acceptor-<span class="subst">$listenerName</span>-<span class="subst">$securityProtocol</span>-<span class="subst">${endpoint.port}</span>"</span>, acceptor, <span class="literal">false</span>).start()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程等待 Acceptor 线程启动完成</span></span><br><span class="line">            acceptor.awaitStartup()</span><br><span class="line"></span><br><span class="line">            processorBeginIndex = processorEndIndex</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    info(<span class="string">"Started "</span> + acceptors.size + <span class="string">" acceptor threads"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>SocketServer 启动过程中会遍历为当前 broker 节点上的每张网卡创建并绑定对应 Acceptor 对象，然后按照配置的 Processor 线程数（对应 <code>num.network.threads</code> 配置）为每个 Acceptor 创建并绑定对应数量的 Processor 实例，最后启动 Acceptor 线程。</p>

        <h3 id="Acceptor-组件">
          <a href="#Acceptor-组件" class="heading-link"><i class="fas fa-link"></i></a>Acceptor 组件</h3>
      <p>Acceptor 主要负责接收来自客户端和其它 broker 节点的请求，并创建对应的 socket 连接交由 Processor 进行处理。Acceptor 类的字段定义如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[kafka] <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span>(<span class="params">val endPoint: <span class="type">EndPoint</span>, // 对应的网卡信息</span></span></span><br><span class="line"><span class="class"><span class="params">                              val sendBufferSize: <span class="type">Int</span>, // socket send buffer size</span></span></span><br><span class="line"><span class="class"><span class="params">                              val recvBufferSize: <span class="type">Int</span>, // socket receive buffer size</span></span></span><br><span class="line"><span class="class"><span class="params">                              brokerId: <span class="type">Int</span>, // broker 节点 id</span></span></span><br><span class="line"><span class="class"><span class="params">                              processors: <span class="type">Array</span>[<span class="type">Processor</span>], // 绑定的 <span class="type">Processor</span> 线程集合</span></span></span><br><span class="line"><span class="class"><span class="params">                              connectionQuotas: <span class="type">ConnectionQuotas</span> // 控制 <span class="type">IP</span> 连接数的对象</span></span></span><br><span class="line"><span class="class"><span class="params">                             </span>) <span class="keyword">extends</span> <span class="title">AbstractServerThread</span>(<span class="params">connectionQuotas</span>) <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** NIO Selector */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> nioSelector = <span class="type">NSelector</span>.open()</span><br><span class="line">    <span class="comment">/** ServerSocketChannel 对象，监听对应网卡的指定端口 */</span></span><br><span class="line">    <span class="keyword">val</span> serverChannel: <span class="type">ServerSocketChannel</span> = <span class="keyword">this</span>.openServerSocket(endPoint.host, endPoint.port)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略方法定义</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>SocketServer 在启动过程中会创建并启动 Acceptor 线程，由上面的定义可以看出 Acceptor 继承自 AbstractServerThread 抽象类，而 AbstractServerThread 实现了 Runnable 接口，并提供了对线程的基本管理方法。Acceptor 的具体执行逻辑位于 <code>Acceptor#run</code> 方法中：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() {</span><br><span class="line">    <span class="comment">// 注册监听 OP_ACCEPT 事件</span></span><br><span class="line">    serverChannel.register(nioSelector, <span class="type">SelectionKey</span>.<span class="type">OP_ACCEPT</span>)</span><br><span class="line">    <span class="comment">// 标记当前线程启动完成，以便 SocketServer 能够继续为其它网卡创建并绑定对应的 Acceptor 线程</span></span><br><span class="line">    <span class="keyword">this</span>.startupComplete()</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">var</span> currentProcessor = <span class="number">0</span> <span class="comment">// 当前生效的 processor 编号</span></span><br><span class="line">        <span class="keyword">while</span> (isRunning) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 等待关注的事件</span></span><br><span class="line">                <span class="keyword">val</span> ready = nioSelector.select(<span class="number">500</span>)</span><br><span class="line">                <span class="keyword">if</span> (ready &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">val</span> keys = nioSelector.selectedKeys()</span><br><span class="line">                    <span class="keyword">val</span> iter = keys.iterator()</span><br><span class="line">                    <span class="comment">// 遍历处理接收到的请求</span></span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext &amp;&amp; isRunning) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="keyword">val</span> key = iter.next</span><br><span class="line">                            iter.remove()</span><br><span class="line">                            <span class="comment">// 如果是 OP_ACCEPT 事件，则调用 accept 方法进行处理</span></span><br><span class="line">                            <span class="keyword">if</span> (key.isAcceptable)</span><br><span class="line">                                <span class="keyword">this</span>.accept(key, processors(currentProcessor))</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Unrecognized key state for acceptor thread."</span>)</span><br><span class="line">                            <span class="comment">// 基于轮询算法选择下一个 Processor 处理下一次请求，负载均衡</span></span><br><span class="line">                            currentProcessor = (currentProcessor + <span class="number">1</span>) % processors.length</span><br><span class="line">                        } <span class="keyword">catch</span> {</span><br><span class="line">                            <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error while accepting connection"</span>, e)</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> {</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">ControlThrowable</span> =&gt; <span class="keyword">throw</span> e</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error occurred"</span>, e)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        debug(<span class="string">"Closing server socket and selector."</span>)</span><br><span class="line">        <span class="keyword">this</span>.swallowError(serverChannel.close())</span><br><span class="line">        <span class="keyword">this</span>.swallowError(nioSelector.close())</span><br><span class="line">        <span class="keyword">this</span>.shutdownComplete()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(key: <span class="type">SelectionKey</span>, processor: <span class="type">Processor</span>) {</span><br><span class="line">    <span class="keyword">val</span> serverSocketChannel = key.channel().asInstanceOf[<span class="type">ServerSocketChannel</span>]</span><br><span class="line">    <span class="comment">// 创建 SocketChannel 对象</span></span><br><span class="line">    <span class="keyword">val</span> socketChannel = serverSocketChannel.accept()</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 增加对应 IP 上的连接数，如果连接数超过阈值，则抛 TooManyConnectionsException 异常</span></span><br><span class="line">        connectionQuotas.inc(socketChannel.socket().getInetAddress)</span><br><span class="line">        <span class="comment">// 配置 SocketChannel 对象，非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>)</span><br><span class="line">        socketChannel.socket().setTcpNoDelay(<span class="literal">true</span>)</span><br><span class="line">        socketChannel.socket().setKeepAlive(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> (sendBufferSize != <span class="type">Selectable</span>.<span class="type">USE_DEFAULT_BUFFER_SIZE</span>)</span><br><span class="line">            socketChannel.socket().setSendBufferSize(sendBufferSize)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 SocketChannel 交给 Processor 进行处理</span></span><br><span class="line">        processor.accept(socketChannel)</span><br><span class="line">    } <span class="keyword">catch</span> {</span><br><span class="line">        <span class="comment">// 连接数过多，关闭当前通道上的连接，并将连接计数减 1</span></span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">TooManyConnectionsException</span> =&gt;</span><br><span class="line">            info(<span class="string">"Rejected connection from %s, address already has the configured maximum of %d connections."</span>.format(e.ip, e.count))</span><br><span class="line">            <span class="keyword">this</span>.close(socketChannel)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的执行逻辑是一个典型的 NIO server 的实现。Acceptor 会循环监听 <code>OP_ACCEPT</code> 事件，当有新的连接请求到达时会创建并配置连接对应的 SocketChannel 对象，并交由 Processor 处理（调用 <code>Processor#accept</code> 方法）。我们知道一个 Acceptor 上绑定了多个 Processor 线程，为了保证各个 Processor 的负载均衡，这里使用了简单的轮询算法，逐个选择 Processor 线程处理请求。</p>
<p>对于新进来的请求，Acceptor 首先会使用 ConnectionQuotas 对象管理请求 IP 上的连接数，并在连接数超过配置的阈值（默认对应 <code>max.connections.per.ip</code> 配置，可以通过 <code>max.connections.per.ip.overrides</code> 配置覆盖默认配置）时触发限流机制，关闭当前连接的通道。</p>

        <h3 id="Processor-组件">
          <a href="#Processor-组件" class="heading-link"><i class="fas fa-link"></i></a>Processor 组件</h3>
      <p>Processor 主要负责读取来自请求方的请求，并向请求方发送响应，但是本身不负责对请求进行处理，而是委托给相应的 Handler 线程进行处理。Processor 中几个重要的字段定义如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Processor 与 Handler 线程之间传递请求数据的队列 */</span></span><br><span class="line"><span class="keyword">val</span> requestChannel: <span class="type">RequestChannel</span></span><br><span class="line"><span class="comment">/** 记录分配给当前 Processor 的待处理的 SocketChannel 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> newConnections = <span class="keyword">new</span> <span class="type">ConcurrentLinkedQueue</span>[<span class="type">SocketChannel</span>]()</span><br><span class="line"><span class="comment">/** 缓存未发送给客户端的响应，由于客户端不会进行确认，所以服务端在发送成功之后会将其移除 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> inflightResponses = mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">RequestChannel</span>.<span class="type">Response</span>]()</span><br></pre></td></tr></tbody></table></div></figure>
<p>Acceptor 线程在收到连接请求之后会将请求封装成 SocketChannel 对象，并调用 <code>Processor#accept</code> 方法将其分配给对应的 Processor 线程进行处理，该对象会被记录到 <code>Processor#newConnections</code> 字段中，并唤醒对应的 Processor 线程。方法 <code>Processor#accept</code> 的实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(socketChannel: <span class="type">SocketChannel</span>) {</span><br><span class="line">    <span class="comment">// 将 Acceptor 分配的 SocketChannel 对象缓存到同步队列中</span></span><br><span class="line">    newConnections.add(socketChannel)</span><br><span class="line">    <span class="comment">// 唤醒 Processor 线程处理队列</span></span><br><span class="line">    <span class="keyword">this</span>.wakeup() <span class="comment">// 本质上调用 NIO Server 的 wakeup 方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Processor 同样继承了 AbstractServerThread 抽象类，所以也是一个线程类实现。在创建 Acceptor 对象的过程中会遍历启动分配给当前 Acceptor 的 Processor 线程。</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">synchronized {</span><br><span class="line">    <span class="comment">// 遍历启动分配给当前 Acceptor 的 Processor 线程</span></span><br><span class="line">    processors.foreach { processor =&gt;</span><br><span class="line">        <span class="type">Utils</span>.newThread(</span><br><span class="line">            <span class="string">s"kafka-network-thread-<span class="subst">$brokerId</span>-<span class="subst">${endPoint.listenerName}</span>-<span class="subst">${endPoint.securityProtocol}</span>-<span class="subst">${processor.id}</span>"</span>,</span><br><span class="line">            processor, <span class="literal">false</span>).start()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Processor 的 <code>Processor#run</code> 方法在线程启动之后会一直循环处理 Acceptor 分配的请求，读取并封装请求数据到队列中，然后等待 Handler 线程处理。对于已经处理完成的请求对应的响应对象，Processor 线程会依据响应类型分而治之。方法 <code>Processor#run</code> 的实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() {</span><br><span class="line">    <span class="comment">// 标识当前线程启动完成</span></span><br><span class="line">    <span class="keyword">this</span>.startupComplete()</span><br><span class="line">    <span class="keyword">while</span> (isRunning) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 1. 遍历获取分配给当前 Processor 的 SocketChannel 对象，注册 OP_READ 事件</span></span><br><span class="line">            <span class="keyword">this</span>.configureNewConnections()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 遍历处理当前 Processor 的响应队列，依据响应类型进行处理</span></span><br><span class="line">            <span class="keyword">this</span>.processNewResponses()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 发送缓存的响应对象给客户端</span></span><br><span class="line">            <span class="keyword">this</span>.poll()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.</span></span><br><span class="line">            <span class="comment">// 遍历处理 poll 操作放置在 Selector 的 completedReceives 队列中的请求，</span></span><br><span class="line">            <span class="comment">// 封装请求信息为 Request 对象，并记录到请求队列中等待 Handler 线程处理，</span></span><br><span class="line">            <span class="comment">// 同时标记当前 Selector 暂时不再接收新的请求</span></span><br><span class="line">            <span class="keyword">this</span>.processCompletedReceives()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.</span></span><br><span class="line">            <span class="comment">// 遍历处理 poll 操作放置在 Selector 的 completedSends 队列中的请求，</span></span><br><span class="line">            <span class="comment">// 将其从 inflightResponses 集合中移除，并标记当前 Selector 可以继续读取数据</span></span><br><span class="line">            <span class="keyword">this</span>.processCompletedSends()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.</span></span><br><span class="line">            <span class="comment">// 遍历处理 poll 操作放置在 Selector 的 disconnected 集合中的断开的连接，</span></span><br><span class="line">            <span class="comment">// 将连接对应的所有响应从 inflightResponses 中移除，同时更新对应 IP 的连接数</span></span><br><span class="line">            <span class="keyword">this</span>.processDisconnected()</span><br><span class="line">        } <span class="keyword">catch</span> {</span><br><span class="line">            <span class="keyword">case</span> e: <span class="type">ControlThrowable</span> =&gt; <span class="keyword">throw</span> e</span><br><span class="line">            <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">                error(<span class="string">"Processor got uncaught exception."</span>, e)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    debug(<span class="string">"Closing selector - processor "</span> + id)</span><br><span class="line">    <span class="comment">// 关闭所有的连接以及选择器</span></span><br><span class="line">    <span class="keyword">this</span>.swallowError(closeAll())</span><br><span class="line">    <span class="keyword">this</span>.shutdownComplete()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>当 Processor 线程启动完成后会调用 <code>Processor#startupComplete</code> 方法标识当前线程启动完成，然后开始进入循环，依次执行以下操作：</p>
<ol>
<li>遍历处理 Acceptor 分配给当前 Processor 的 SocketChannel 对象，注册 <code>OP_READ</code> 事件读取请求数据；</li>
<li>遍历处理 Processor 自己的响应队列，按照响应类型分别处理；</li>
<li>发送缓存的响应给请求方，并将读取到的请求、已经发送成功的请求，以及断开的连接分别放置到 Selector 的 completedReceives、completedSends 和 disconnected 集合中；</li>
<li>处理 Selector 的 completedReceives 集合，封装请求数据到请求队列中，等待 Handler 线程处理；</li>
<li>处理 Selector 的 completedSends 集合，将已经发送成功的响应从本地 inflightResponses 集合中移除；</li>
<li>处理 Selector 的 disconnected 集合，将已经断开的连接上的响应从 inflightResponses 集合中移除。</li>
</ol>
<p>下面对各个步骤逐一进行深入分析，首先来看 <strong>步骤 1</strong> ，实现位于 <code>Processor#configureNewConnections</code> 方法中：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">configureNewConnections</span></span>() {</span><br><span class="line">    <span class="keyword">while</span> (!newConnections.isEmpty) {</span><br><span class="line">        <span class="comment">// 获取待处理 SocketChannel 对象</span></span><br><span class="line">        <span class="keyword">val</span> channel = newConnections.poll()</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            debug(<span class="string">s"Processor <span class="subst">$id</span> listening to new connection from <span class="subst">${channel.socket.getRemoteSocketAddress}</span>"</span>)</span><br><span class="line">            <span class="keyword">val</span> localHost = channel.socket().getLocalAddress.getHostAddress</span><br><span class="line">            <span class="keyword">val</span> localPort = channel.socket().getLocalPort</span><br><span class="line">            <span class="keyword">val</span> remoteHost = channel.socket().getInetAddress.getHostAddress</span><br><span class="line">            <span class="keyword">val</span> remotePort = channel.socket().getPort</span><br><span class="line">            <span class="keyword">val</span> connectionId = <span class="type">ConnectionId</span>(localHost, localPort, remoteHost, remotePort).toString</span><br><span class="line">            <span class="comment">// 注册 OP_READ 事件</span></span><br><span class="line">            selector.register(connectionId, channel)</span><br><span class="line">        } <span class="keyword">catch</span> {</span><br><span class="line">            <span class="comment">// 对于不致命的异常，则捕获并关闭对应的通道</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">                <span class="keyword">val</span> remoteAddress = channel.getRemoteAddress</span><br><span class="line">                <span class="keyword">this</span>.close(channel)</span><br><span class="line">                error(<span class="string">s"Processor <span class="subst">$id</span> closed connection from <span class="subst">$remoteAddress</span>"</span>, e)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>前面我们曾介绍过 Acceptor 会将请求对应的 SocketChannel 对象记录到 <code>Processor#newConnections</code> 字段中，而这一步的主要任务就是遍历处理这些 SocketChannel 对象，分别将 Processor 对应的 Selector 注册到这些通道上（对应 <code>OP_READ</code> 事件），用于读取请求数据。</p>
<p><strong>步骤 2</strong> 会遍历消费当前 Processor 的响应队列，按照响应的类型分别处理，实现位于 <code>Processor#processNewResponses</code> 方法中：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processNewResponses</span></span>() {</span><br><span class="line">    <span class="comment">// 获取当前 Processor 的响应队列</span></span><br><span class="line">    <span class="keyword">var</span> curr = requestChannel.receiveResponse(id)</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 依据响应类型对响应进行处理</span></span><br><span class="line">            curr.responseAction <span class="keyword">match</span> {</span><br><span class="line">                <span class="comment">// 暂时没有响应需要发送，如果对应的通道未被关闭，则继续注册 OP_READ 事件读取请求数据</span></span><br><span class="line">                <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">NoOpAction</span> =&gt;</span><br><span class="line">                    curr.request.updateRequestMetrics()</span><br><span class="line">                    trace(<span class="string">"Socket server received empty response to send, registering for read: "</span> + curr)</span><br><span class="line">                    <span class="keyword">val</span> channelId = curr.request.connectionId</span><br><span class="line">                    <span class="keyword">if</span> (selector.channel(channelId) != <span class="literal">null</span> || selector.closingChannel(channelId) != <span class="literal">null</span>)</span><br><span class="line">                        selector.unmute(channelId) <span class="comment">// 注册 OP_READ 事件</span></span><br><span class="line">                <span class="comment">// 当前响应需要发送给请求方</span></span><br><span class="line">                <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">SendAction</span> =&gt;</span><br><span class="line">                    <span class="comment">// 发送该响应，并将响应对象记录到 inflightResponses 集合中</span></span><br><span class="line">                    <span class="keyword">this</span>.sendResponse(curr)</span><br><span class="line">                <span class="comment">// 需要关闭当前连接</span></span><br><span class="line">                <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">CloseConnectionAction</span> =&gt;</span><br><span class="line">                    curr.request.updateRequestMetrics()</span><br><span class="line">                    trace(<span class="string">"Closing socket connection actively according to the response code."</span>)</span><br><span class="line">                    <span class="comment">// 关闭连接</span></span><br><span class="line">                    <span class="keyword">this</span>.close(selector, curr.request.connectionId)</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 获取下一个待处理的响应</span></span><br><span class="line">            curr = requestChannel.receiveResponse(id)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>我们知道 Processor 本身不负责处理请求，它只是封装请求交由 Handler 线程进行处理，同时每一个 Processor 会维护一个响应队列，Handler 线程在处理完请求之后会将对应的响应对象放置到对应 Processor 的响应队列中，而这一步会遍历处理该响应队列，并依据响应类型分而治之：</p>
<ol>
<li>如果当前没有响应需要处理，那么会重新在对应的通道上注册 <code>OP_READ</code> 事件，以继续读取新的请求数据。</li>
<li>如果当前的响应需要发送给请求方，则会调用 <code>Processor#sendResponse</code> 方法发送响应，并将响应对象记录到 <code>Processor#inflightResponses</code> 字段中，表示该响应对象正在被发送。</li>
<li>如果当前的响应类型表示需要关闭对应的连接，则会调用 <code>Processor#close</code> 方法关闭对应的通道，并更新对应 IP 上的连接数。</li>
</ol>
<p><strong>步骤 3</strong> 会发送步骤 2 缓存的响应请求，并将读取到的请求、已经发送成功的请求，以及断开的连接分别放置到 Selector 的 completedReceives、completedSends 和 disconnected 集合中，而步骤 4 至 6 的逻辑则分别对应处理这 3 个集合。首先看一下 <strong>步骤 4</strong> ，相应实现位于 <code>Processor#processCompletedReceives</code> 方法中：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processCompletedReceives</span></span>() {</span><br><span class="line">    <span class="comment">// 遍历处理接收到的请求</span></span><br><span class="line">    selector.completedReceives.asScala.foreach { receive =&gt;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 获取请求对应的通道</span></span><br><span class="line">            <span class="keyword">val</span> openChannel = selector.channel(receive.source)</span><br><span class="line">            <span class="comment">// 创建通道对应的 Session 对象，用于权限控制</span></span><br><span class="line">            <span class="keyword">val</span> session = {</span><br><span class="line">                <span class="comment">// Only methods that are safe to call on a disconnected channel should be invoked on 'channel'.</span></span><br><span class="line">                <span class="keyword">val</span> channel = <span class="keyword">if</span> (openChannel != <span class="literal">null</span>) openChannel <span class="keyword">else</span> selector.closingChannel(receive.source)</span><br><span class="line">                <span class="type">RequestChannel</span>.<span class="type">Session</span>(<span class="keyword">new</span> <span class="type">KafkaPrincipal</span>(<span class="type">KafkaPrincipal</span>.<span class="type">USER_TYPE</span>, channel.principal.getName), channel.socketAddress)</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 封装请求信息为 Request 对象</span></span><br><span class="line">            <span class="keyword">val</span> req = <span class="type">RequestChannel</span>.<span class="type">Request</span>(</span><br><span class="line">                processor = id,</span><br><span class="line">                connectionId = receive.source,</span><br><span class="line">                session = session,</span><br><span class="line">                buffer = receive.payload,</span><br><span class="line">                startTimeMs = time.milliseconds,</span><br><span class="line">                listenerName = listenerName,</span><br><span class="line">                securityProtocol = securityProtocol)</span><br><span class="line">            <span class="comment">// 将请求对象放入请求队列中，等待 Handler 线程处理</span></span><br><span class="line">            requestChannel.sendRequest(req)</span><br><span class="line">            <span class="comment">// 取消注册的 OP_READ 事件，处理期间不再接收新的请求（即不读取新的请求数据）</span></span><br><span class="line">            selector.mute(receive.source)</span><br><span class="line">        } <span class="keyword">catch</span> {</span><br><span class="line">            <span class="keyword">case</span> e@(_: <span class="type">InvalidRequestException</span> | _: <span class="type">SchemaException</span>) =&gt;</span><br><span class="line">                <span class="comment">// note that even though we got an exception, we can assume that receive.source is valid. Issues with constructing a valid receive object were handled earlier</span></span><br><span class="line">                error(<span class="string">s"Closing socket for <span class="subst">${receive.source}</span> because of error"</span>, e)</span><br><span class="line">                close(selector, receive.source)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>这一步会遍历处理 Selector 的 completedReceives 集合，对于收到的请求对象会读取请求数据，并封装成 Request 对象记录到请求队列 <code>Processor#requestChannel</code> 中，等待 Handler 线程处理，同时取消之前注册到对应通道的 <code>OP_READ</code> 事件，在处理完成之前不再读取新的请求数据。这里调用了 <code>RequestChannel#sendRequest</code> 方法将 Request 对象放置到一个被 Processor 共享的请求队列中，后续 Handler 线程会消费该队列处理对应的请求。</p>
<p><strong>步骤 5</strong> 会遍历处理 Selector 的 completedSends 集合，其中存放了已经发送成功的响应，对于这些响应可以从 <code>Processor#inflightResponses</code> 中移除，实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processCompletedSends</span></span>() {</span><br><span class="line">    <span class="comment">// 遍历处理已经完全发送出去的请求</span></span><br><span class="line">    selector.completedSends.asScala.foreach { send =&gt;</span><br><span class="line">        <span class="comment">// 因为当前响应已经发送成功，从 inflightResponses 中移除，不需要客户端确认</span></span><br><span class="line">        <span class="keyword">val</span> resp = inflightResponses.remove(send.destination).getOrElse {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"Send for <span class="subst">${send.destination}</span> completed, but not in `inflightResponses`"</span>)</span><br><span class="line">        }</span><br><span class="line">        resp.request.updateRequestMetrics()</span><br><span class="line">        <span class="comment">// 注册 OP_READ 事件，继续读取请求数据</span></span><br><span class="line">        selector.unmute(send.destination)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>步骤 6</strong> 会遍历处理 Selector 的 disconnected 集合，对于已经断开的连接，将本地记录的待发送完成的响应对象从 <code>Processor#inflightResponses</code> 中移除，同时更新对应 IP 上的连接数，实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processDisconnected</span></span>() {</span><br><span class="line">    <span class="comment">// 遍历处理已经断开的连接</span></span><br><span class="line">    selector.disconnected.asScala.foreach { connectionId =&gt;</span><br><span class="line">        <span class="keyword">val</span> remoteHost = <span class="type">ConnectionId</span>.fromString(connectionId).getOrElse {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"connectionId has unexpected format: <span class="subst">$connectionId</span>"</span>)</span><br><span class="line">        }.remoteHost</span><br><span class="line">        <span class="comment">// 将连接对应的所有响应从 inflightResponses 中移除</span></span><br><span class="line">        inflightResponses.remove(connectionId).foreach(_.request.updateRequestMetrics())</span><br><span class="line">        <span class="comment">// 对应的通道已经被关闭，所以需要减少对应 IP 上的连接数</span></span><br><span class="line">        connectionQuotas.dec(<span class="type">InetAddress</span>.getByName(remoteHost))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="Handler-组件">
          <a href="#Handler-组件" class="heading-link"><i class="fas fa-link"></i></a>Handler 组件</h3>
      <p>Processor 在将对应的 Request 请求对象记录到全局共享的请求队列之后，Handler 线程会消费该队列并处理对应的请求，同时将处理完成的请求对应的响应对象写入到之前读取该请求的 Processor 的响应队列中。Handler 的实现由 KafkaRequestHandler 和 KafkaRequestHandlerPool 两个类构成，其中 KafkaRequestHandlerPool 是对 KafkaRequestHandler 的封装，提供了对 Handler 线程的管理。KafkaRequestHandlerPool 的实现比较简单，我们主要来看一下 KafkaRequestHandler 的实现。KafkaRequestHandler 实现了 Runnable 接口，其 <code>KafkaRequestHandler#run</code> 方法实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">var</span> req: <span class="type">RequestChannel</span>.<span class="type">Request</span> = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">while</span> (req == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">val</span> startSelectTime = time.nanoseconds</span><br><span class="line">                <span class="comment">// 从请求队列中获取 Processor 封装的请求</span></span><br><span class="line">                req = requestChannel.receiveRequest(<span class="number">300</span>)</span><br><span class="line">                <span class="keyword">val</span> idleTime = time.nanoseconds - startSelectTime</span><br><span class="line">                aggregateIdleMeter.mark(idleTime / totalHandlerThreads)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是 AllDone 请求，则退出当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (req eq <span class="type">RequestChannel</span>.<span class="type">AllDone</span>) {</span><br><span class="line">                debug(<span class="string">"Kafka request handler %d on broker %d received shut down command"</span>.format(id, brokerId))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            }</span><br><span class="line">            req.requestDequeueTimeMs = time.milliseconds</span><br><span class="line">            trace(<span class="string">"Kafka request handler %d on broker %d handling request %s"</span>.format(id, brokerId, req))</span><br><span class="line">            <span class="comment">// 处理请求，将响应写回到对应 Processor 的响应队列中，并唤醒 Processor 线程</span></span><br><span class="line">            apis.handle(req)</span><br><span class="line">        } <span class="keyword">catch</span> {</span><br><span class="line">            <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Exception when handling request"</span>, e)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法诠释了 Handler 的全部运行逻辑，首先调用 <code>RequestChannel#receiveRequest</code> 方法超时等待从全局请求队列中获取请求对象，如果获取到的请求对象是 <code>RequestChannel.AllDone</code> 类型，则说明当前请求退出相应线程，否则 Handler 线程会调用 <code>KafkaApis#handle</code> 方法对请求进行处理，并将响应结果写入到对应 Processor 的响应队列中。</p>
<p>KafkaApis 类是 Kafka 中的一个核心类实现，用于分发各种类型的请求给到相应的组件，针对每一种请求都定义了相应的方法进行处理，上面调用 <code>KafkaApis#handle</code> 方法实现如下：</p>
<figure class="highlight scala"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        trace(<span class="string">"Handling request:%s from connection %s;securityProtocol:%s,principal:%s"</span>.</span><br><span class="line">                format(request.requestDesc(<span class="literal">true</span>), request.connectionId, request.securityProtocol, request.session.principal))</span><br><span class="line">        <span class="comment">// 依据请求类型分发请求</span></span><br><span class="line">        <span class="type">ApiKeys</span>.forId(request.requestId) <span class="keyword">match</span> {</span><br><span class="line">            <span class="comment">// 处理 ProduceRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">PRODUCE</span> =&gt; handleProducerRequest(request)</span><br><span class="line">            <span class="comment">// 处理 FetchRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">FETCH</span> =&gt; handleFetchRequest(request)</span><br><span class="line">            <span class="comment">// 处理 ListOffsetRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LIST_OFFSETS</span> =&gt; handleOffsetRequest(request)</span><br><span class="line">            <span class="comment">// 处理 MetadataRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">METADATA</span> =&gt; handleTopicMetadataRequest(request)</span><br><span class="line">            <span class="comment">// 处理 LeaderAndIsrRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LEADER_AND_ISR</span> =&gt; handleLeaderAndIsrRequest(request)</span><br><span class="line">            <span class="comment">// 处理 StopReplicaRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">STOP_REPLICA</span> =&gt; handleStopReplicaRequest(request)</span><br><span class="line">            <span class="comment">// 处理 UpdateMetadataRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">UPDATE_METADATA_KEY</span> =&gt; handleUpdateMetadataRequest(request)</span><br><span class="line">            <span class="comment">// 处理 ControlledShutdownRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">CONTROLLED_SHUTDOWN_KEY</span> =&gt; handleControlledShutdownRequest(request)</span><br><span class="line">            <span class="comment">// 处理 OffsetCommitRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">OFFSET_COMMIT</span> =&gt; handleOffsetCommitRequest(request)</span><br><span class="line">            <span class="comment">// 处理 OffsetFetchRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">OFFSET_FETCH</span> =&gt; handleOffsetFetchRequest(request)</span><br><span class="line">            <span class="comment">// 处理 GroupCoordinatorRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">GROUP_COORDINATOR</span> =&gt; handleGroupCoordinatorRequest(request)</span><br><span class="line">            <span class="comment">// 处理 JoinGroupRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">JOIN_GROUP</span> =&gt; handleJoinGroupRequest(request)</span><br><span class="line">            <span class="comment">// 处理 HeartbeatRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">HEARTBEAT</span> =&gt; handleHeartbeatRequest(request)</span><br><span class="line">            <span class="comment">// 处理 LeaveGroupRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LEAVE_GROUP</span> =&gt; handleLeaveGroupRequest(request)</span><br><span class="line">            <span class="comment">// 处理 SyncGroupRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">SYNC_GROUP</span> =&gt; handleSyncGroupRequest(request)</span><br><span class="line">            <span class="comment">// 处理 DescribeGroupsRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">DESCRIBE_GROUPS</span> =&gt; handleDescribeGroupRequest(request)</span><br><span class="line">            <span class="comment">// 处理 ListGroupsRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LIST_GROUPS</span> =&gt; handleListGroupsRequest(request)</span><br><span class="line">            <span class="comment">// 处理 SaslHandshakeRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">SASL_HANDSHAKE</span> =&gt; handleSaslHandshakeRequest(request)</span><br><span class="line">            <span class="comment">// 处理 ApiVersionsRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">API_VERSIONS</span> =&gt; handleApiVersionsRequest(request)</span><br><span class="line">            <span class="comment">// 处理 CreateTopicsRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">CREATE_TOPICS</span> =&gt; handleCreateTopicsRequest(request)</span><br><span class="line">            <span class="comment">// 处理 DeleteTopicsRequest 请求</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">DELETE_TOPICS</span> =&gt; handleDeleteTopicsRequest(request)</span><br><span class="line">            <span class="keyword">case</span> requestId =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KafkaException</span>(<span class="string">"Unknown api code "</span> + requestId)</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> {</span><br><span class="line">        <span class="comment">// ... 省略异常处理</span></span><br><span class="line">    } <span class="keyword">finally</span></span><br><span class="line">        request.apiLocalCompleteTimeMs = time.milliseconds</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>枚举类 ApiKeys 为每一种请求类型定义了一个唯一的标识，KafkaApis 会依据具体的请求类型，将请求委托给对应的 <code>handle*</code> 方法进行处理，这些方法基本的执行逻辑可以概括为：</p>
<ol>
<li>解析获取相应类型的请求对象；</li>
<li>权限校验；</li>
<li>委托对应的组件处理请求；</li>
<li>发送响应，或定义响应回调函数，并由具体的组件回调执行。</li>
</ol>
<p>相应的实现这里先不展开，后续分析具体组件时再针对性介绍。</p>

        <h3 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>本文我们分析了 Kafka 的网络交互模型设计与实现，考虑到客户端与集群之间，以及 broker 节点之间的交互均基于请求进行通信，所以必须保证网络交互这一块的低延迟和高性能。相比于传统的“thread-per-connection”线程模型，Kafka 采用了 reactor 模式以满足实际的需求，并借助于 java NIO 进行实现。整个网络交互模型主要分为 Acceptor、Processor 和 Handler 三大组件，其中 Acceptor 负责接收请求，Processor 负责解析请求并发送响应，而具体的请求处理过程则交由 Handler 负责，其中的设计思想值得我们在开发自己的项目中借鉴。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2019/06/21/kafka/kafka-reactor/">https://plotor.github.io/2019/06/21/kafka/kafka-reactor/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/Kafka/">Kafka</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2019/06/22/kafka/kafka-log-manage/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Kafka 源码解析：日志数据存储机制</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2019/06/20/kafka/kafka-broker/"><span class="paginator-prev__text">Kafka 源码解析：Broker 节点的启动与关闭</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketServer-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">
          SocketServer 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Acceptor-%E7%BB%84%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">
          Acceptor 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Processor-%E7%BB%84%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">
          Processor 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler-%E7%BB%84%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">
          Handler 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">
          总结</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">95</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2024</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>