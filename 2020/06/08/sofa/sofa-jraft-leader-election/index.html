<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="主节点选举（Leader Election）是 Raft 算法的核心组成部分，也是 Raft 算法库的主要应用场景之一。Raft 算法设计了 term 和 logIndex 两个属性，分别用于表示 Leader 节点的任期，以及集群运行期间接收到的指令对应的日志条目的 ID，这两个属性都是单调递增的。一个 Leader 节点在任期内会始终向其管理的所有 Follower 节点宣示主权，以避免这些">
<meta property="og:type" content="article">
<meta property="og:title" content="SOFA-JRaft 源码解析：主节点选举机制">
<meta property="og:url" content="https://plotor.github.io/2020/06/08/sofa/sofa-jraft-leader-election/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="主节点选举（Leader Election）是 Raft 算法的核心组成部分，也是 Raft 算法库的主要应用场景之一。Raft 算法设计了 term 和 logIndex 两个属性，分别用于表示 Leader 节点的任期，以及集群运行期间接收到的指令对应的日志条目的 ID，这两个属性都是单调递增的。一个 Leader 节点在任期内会始终向其管理的所有 Follower 节点宣示主权，以避免这些">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-08T08:12:08.000Z">
<meta property="article:modified_time" content="2024-12-09T05:12:58.118Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="Raft">
<meta property="article:tag" content="SOFA-JRaft">
<meta name="twitter:card" content="summary"><title>SOFA-JRaft 源码解析：主节点选举机制 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2020/06/08/sofa/sofa-jraft-leader-election/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">SOFA-JRaft 源码解析：主节点选举机制</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-06-08</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">9.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">46分</span></span></div></header><div class="post-body"><p>主节点选举（Leader Election）是 Raft 算法的核心组成部分，也是 Raft 算法库的主要应用场景之一。Raft 算法设计了 term 和 logIndex 两个属性，分别用于表示 Leader 节点的任期，以及集群运行期间接收到的指令对应的日志条目的 ID，这两个属性都是单调递增的。一个 Leader 节点在任期内会始终向其管理的所有 Follower 节点宣示主权，以避免这些 Follower 节点发动革命，推翻自己的政权，成为新的 Leader 节点。然而，世事无常，如果 Leader 节点因为某些原因不能或未能即时向某些 Follower 节点宣示自己的主权，则这些 Follower 节点在等待一段随机的时间之后就会尝试竞选成为新的 Leader 节点。</p>
<p>之所以这里采用随机化的等待时间，是为了避免两个或多个 Follower 节点同时发起选举进程，进而出现这些节点都没有赢得过半数的选票。于是，这些节点又在同一时间发起下一轮选举进程，延长了集群无 Leader 节点的时间，而通过随机化各个 Follower 节点等待的时间则能够很好的解决此类问题。<a id="more"></a></p>
<p>当然，也并不是所有的 Follower 节点都有参选的资格，Raft 算法要求节点在给参选节点投票时必须保证参选节点满足以下两个条件之一：</p>
<ol>
<li>参选节点的 term 值大于投票节点，否则拒绝为其投票。</li>
<li>如果参选节点与投票节点的 term 值相同，则需要保证参选节点的 logIndex 值不小于投票节点。</li>
</ol>
<p>这两个条件的目的都在于保证当前参选节点本地的日志数据不能比投票节点要陈旧。</p>
<p>上一篇我们分析了 JRaft 算法库的整体架构和节点的初始化启动过程，当一个节点启动之后即会启动对应的预选举计时器，不断检查 Leader 节点的有效性，并随时准备发动新一轮的选举革命，本文我们就针对 JRaft 关于主节点选举的实现展开分析。</p>

        <h3 id="Leader-选举">
          <a href="#Leader-选举" class="heading-link"><i class="fas fa-link"></i></a>Leader 选举</h3>
      <p>JRaft 在设计层面将选举的过程拆分为预选举和正式选举两个过程，之所以这样设计是为了避免无效的选举进程递增 term 值，进而造成浪费，同时也会导致正常运行的 Leader 节点执行角色降级。Raft 算法要求当节点接收到 term 值更大的请求时需要递增本地的 term 值，以此实现集群中 term 值的同步。对于 Leader 节点而言，当收到 term 值更大的请求时，该节点会认为集群中有新的 Leader 节点生成，于是需要执行角色降级。这一机制能够保证在出现网络分区等问题时，在网络恢复时能够促使 term 值较小的 Leader 节点退位为 Follower 节点，从而实现让集群达到一个新的平稳状态。然而，如果集群中某个 Follower 节点因为某些原因未能接收到 Leader 节点的主权宣示指令，就会一直尝试发动新一轮的选举革命，进而递增 term 值，导致 Leader 节点执行角色降级，最终影响整个集群的正常运行。</p>
<p>预选举的引入则能够很好的解决此类问题，当一个 Follower 节点尝试发起一轮新的选举革命时，该节点不会立即递增 term 值，而是尝试将 term 值加 1 去试探性的征集选票，只有当集群中过半数的节点同意投票的前提下才会进入正式投票的环节，这样对于无效选举而言一般只会停留在预选举阶段，不会对集群的正常运行造成影响。</p>
<p>下面来看一下 JRaft 关于预选举和正式选举的具体实现。</p>

        <h4 id="预选举">
          <a href="#预选举" class="heading-link"><i class="fas fa-link"></i></a>预选举</h4>
      <p>当启动一个 JRaft 节点时，如果初始化集群节点配置不为空，则节点会调用 <code>NodeImpl#stepDown</code> 方法执行角色降级操作。所谓角色降级实际上是一个宽泛的说法，因为 <code>NodeImpl#stepDown</code> 方法会在多种场景下被调用。而这里调用该方法的背景是一个 FOLLOWER 节点刚刚启动的时候，所以除了初始化一些本地状态之外，整个角色降级过程重点做的一件事就是启动预选举计时器 electionTimer。</p>
<p>预选举计时器 electionTimer 是一个典型的 RepeatedTimer 应用，关于 RepeatedTimer 的实现和运行机制我们在上一篇已经介绍过，本小节我们重点关注在预选举场景下该计时器针对 <code>RepeatedTimer#onTrigger</code> 方法的实现。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.electionTimer = <span class="keyword">new</span> RepeatedTimer(name, <span class="keyword">this</span>.options.getElectionTimeoutMs(),</span><br><span class="line">        TIMER_FACTORY.getElectionTimer(<span class="keyword">this</span>.options.isSharedElectionTimer(), name)) {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onTrigger</span><span class="params">()</span> </span>{</span><br><span class="line">        handleElectionTimeout();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">adjustTimeout</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> timeoutMs)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> randomTimeout(timeoutMs);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法 <code>RepeatedTimer#onTrigger</code> 会被计时器周期性调度，而具体的执行逻辑则委托给 <code>NodeImpl#handleElectionTimeout</code> 方法执行。为了尽量避免多个节点同时发起预选举请求，计时器 electionTimer 覆盖实现了 <code>RepeatedTimer#adjustTimeout</code> 方法，以实现对于调度周期进行随机化处理，默认随机区间为 1~2s。</p>
<p>方法 <code>NodeImpl#handleElectionTimeout</code> 是预选举的入口，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleElectionTimeout</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 预选举必须由 Follower 节点发起</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_FOLLOWER) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与当前 Leader 节点的租约还有效，暂不发起预选举</span></span><br><span class="line">        <span class="keyword">if</span> (isCurrentLeaderValid()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 尝试开始发起预选举 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空本地记录的 leaderId</span></span><br><span class="line">        resetLeaderId(PeerId.emptyPeer(),</span><br><span class="line">                <span class="keyword">new</span> Status(RaftError.ERAFTTIMEDOUT, <span class="string">"Lost connection from leader %s."</span>, <span class="keyword">this</span>.leaderId));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于节点优先级判断是否继续发起预选举</span></span><br><span class="line">        <span class="keyword">if</span> (!allowLaunchElection()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        doUnlock = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 发起预选举</span></span><br><span class="line">        preVote();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) {</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的执行流程可以概括如下：</p>
<ol>
<li>如果当前节点不是 FOLLOWER 角色，则放弃预选举；</li>
<li>否则，如果当前节点与 Leader 节点之间的租约仍然有效，则放弃预选举；</li>
<li>否则，清空本地记录的 Leader 节点 ID，回调 <code>FSMCaller#onStopFollowing</code> 方法；</li>
<li>基于节点优先级判断是否允许发起预选举，如果允许则发起预选举进程。</li>
</ol>
<p>Follower 节点会在本地记录最近一次收到来自 Leader 节点的 RPC 请求时间戳，如果该时间戳距离当前时间小于选举超时时间，则说明当前节点与 Leader 节点之间的租约仍然有效，无需继续发起预选举。</p>
<p>方法 <code>NodeImpl#resetLeaderId</code> 会清空本地记录的 Leader 节点 ID，如果当前节点不是 Leader 角色，并且正在追随某个 Leader 节点，则该方法会回调 <code>FSMCaller#onStopFollowing</code> 方法将停止追随的事件透传给状态机。业务可以通过覆盖实现 <code>StateMachine#onStopFollowing</code> 方法捕获这一事件。</p>
<p>如果当前节点的优先级允许当前节点继续发起预选举，则接下去会调用 <code>NodeImpl#preVote</code> 方法发起预选举进程，具体实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preVote</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> oldTerm;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        LOG.info(<span class="string">"Node {} term {} start preVote."</span>, getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">        <span class="comment">// 当前节点正在安装快照，则放弃预选举</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.snapshotExecutor != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.snapshotExecutor.isInstallingSnapshot()) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} term {} doesn't do preVote when installing snapshot as the configuration may be out of date."</span>,</span><br><span class="line">                    getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 当前节点不是一个有效的节点</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.conf.contains(<span class="keyword">this</span>.serverId)) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} can't do preVote as it is not in conf &lt;{}&gt;."</span>, getNodeId(), <span class="keyword">this</span>.conf);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        oldTerm = <span class="keyword">this</span>.currTerm;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从本地磁盘获取最新的 LogId</span></span><br><span class="line">    <span class="keyword">final</span> LogId lastLogId = <span class="keyword">this</span>.logManager.getLastLogId(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// pre_vote need defense ABA after unlock&amp;writeLock</span></span><br><span class="line">        <span class="keyword">if</span> (oldTerm != <span class="keyword">this</span>.currTerm) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} raise term {} when get lastLogId."</span>, getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化预选举选票</span></span><br><span class="line">        <span class="keyword">this</span>.prevVoteCtx.init(<span class="keyword">this</span>.conf.getConf(), <span class="keyword">this</span>.conf.isStable() ? <span class="keyword">null</span> : <span class="keyword">this</span>.conf.getOldConf());</span><br><span class="line">        <span class="comment">// 遍历向除自己以外的所有连通节点发送 RequestVote RPC 请求，以征集选票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> PeerId peer : <span class="keyword">this</span>.conf.listPeers()) {</span><br><span class="line">            <span class="keyword">if</span> (peer.equals(<span class="keyword">this</span>.serverId)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.rpcService.connect(peer.getEndpoint())) {</span><br><span class="line">                LOG.warn(<span class="string">"Node {} channel init failed, address={}."</span>, getNodeId(), peer.getEndpoint());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">final</span> OnPreVoteRpcDone done = <span class="keyword">new</span> OnPreVoteRpcDone(peer, <span class="keyword">this</span>.currTerm);</span><br><span class="line">            done.request = RequestVoteRequest.newBuilder() <span class="comment">//</span></span><br><span class="line">                    .setPreVote(<span class="keyword">true</span>) <span class="comment">// it's a pre-vote request. 标记为预选举</span></span><br><span class="line">                    .setGroupId(<span class="keyword">this</span>.groupId) <span class="comment">//</span></span><br><span class="line">                    .setServerId(<span class="keyword">this</span>.serverId.toString()) <span class="comment">//</span></span><br><span class="line">                    .setPeerId(peer.toString()) <span class="comment">//</span></span><br><span class="line">                    .setTerm(<span class="keyword">this</span>.currTerm + <span class="number">1</span>) <span class="comment">// next term，预选举阶段不会真正递增 term 值</span></span><br><span class="line">                    .setLastLogIndex(lastLogId.getIndex()) <span class="comment">//</span></span><br><span class="line">                    .setLastLogTerm(lastLogId.getTerm()) <span class="comment">//</span></span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            <span class="keyword">this</span>.rpcService.preVote(peer.getEndpoint(), done.request, done);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 自己给自己投上一票</span></span><br><span class="line">        <span class="keyword">this</span>.prevVoteCtx.grant(<span class="keyword">this</span>.serverId);</span><br><span class="line">        <span class="comment">// 检查是否赢得选票</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.prevVoteCtx.isGranted()) {</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果赢得选票，则继续发起选举进程</span></span><br><span class="line">            electSelf();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) {</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>预选举的整体执行流程可以概括如下：</p>
<ol>
<li>校验当前节点是否正在安装快照，如果是则放弃预选举；</li>
<li>校验当前节点是否位于节点配置列表中，如果不是则说明当前节点不是一个有效节点，放弃预选举；</li>
<li>从本地磁盘获取最新的 LogId，包含 logIndex 和 term 值；</li>
<li>初始化预选举选票 Ballot 实例；</li>
<li>遍历向除自己以外的所有连通节点发送 RequestVote RPC 请求，以征集选票，同时给自己投上一票；</li>
<li>如果票数过半，则执行 <code>NodeImpl#electSelf</code> 操作进入正式投票环节。</li>
</ol>
<p>整体流程比较直观，其中方法 <code>NodeImpl#electSelf</code> 属于正式投票环境，我们将在下一小节展开分析，本小节我们继续关注以下两个方面：</p>
<ol>
<li>LogManager 加载最新 logIndex 和对应 term 值的过程。</li>
<li>节点对于 RequestVote RPC 预选举请求的处理过程。</li>
</ol>

        <h5 id="加载最新-LogId-数据">
          <a href="#加载最新-LogId-数据" class="heading-link"><i class="fas fa-link"></i></a>加载最新 LogId 数据</h5>
      <p>上一篇我们分析了 LogManager 的初始化过程，本小节我们继续分析 LogManager 是如何从本地加载返回最新的 logIndex 和对应 term 值数据的，即 <code>LogManager#getLastLogId</code> 方法。该方法接收一个 boolean 类型参数，用于设置是否需要将内存中的数据刷盘，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LogId <span class="title">getLastLogId</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isFlush)</span> </span>{</span><br><span class="line">    LastLogIdClosure c;</span><br><span class="line">    <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 直接返回内存中记录的 lastLogIndex，以及对应的 term 值</span></span><br><span class="line">        <span class="keyword">if</span> (!isFlush) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lastLogIndex &gt;= <span class="keyword">this</span>.firstLogIndex) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> LogId(<span class="keyword">this</span>.lastLogIndex, unsafeGetTerm(<span class="keyword">this</span>.lastLogIndex));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.lastSnapshotId;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将内存中的数据刷盘，并返回最新的 logIndex 和对应的 term 值</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 生成快照之后未产生新的数据</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lastLogIndex == <span class="keyword">this</span>.lastSnapshotId.getIndex()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.lastSnapshotId;</span><br><span class="line">            }</span><br><span class="line">            c = <span class="keyword">new</span> LastLogIdClosure();</span><br><span class="line">            <span class="comment">// 往消息队列中发布一个 LAST_LOG_ID 事件</span></span><br><span class="line">            offerEvent(c, EventType.LAST_LOG_ID);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待刷盘完成</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        c.await();</span><br><span class="line">    } <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException e) {</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> c.lastLogId;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>前面在分析 LogManager 初始化过程时我们介绍了 LogManager 在初始化期间会启动一个 Disruptor 消息队列，并对其运行流程进行了简单的介绍。上述方法如果设置 <code>isFlush = true</code> 则会往该队列提交一个 <code>LAST_LOG_ID</code> 类型事件，并阻塞等待该事件处理完成。方法 <code>StableClosureEventHandler#onEvent</code> 中实现了对 Disruptor 中消息的处理逻辑，并定义了一个 AppendBatcher 类型的属性用于缓存收集到的 LogEntry 数据。在响应 <code>LAST_LOG_ID</code> 事件之前，StableClosureEventHandler 会调用 <code>AppendBatcher#flush</code> 方法将收集到的 LogEntry 数据刷盘，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LogId <span class="title">flush</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 将数据落盘，并返回最新的 LogId</span></span><br><span class="line">        <span class="keyword">this</span>.lastId = appendToStorage(<span class="keyword">this</span>.toAppend);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) {</span><br><span class="line">            <span class="comment">// 清空缓存的 LogEntry 数据</span></span><br><span class="line">            <span class="keyword">this</span>.storage.get(i).getEntries().clear();</span><br><span class="line">            Status st = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (LogManagerImpl.<span class="keyword">this</span>.hasError) {</span><br><span class="line">                    <span class="comment">// LogManager 运行异常</span></span><br><span class="line">                    st = <span class="keyword">new</span> Status(RaftError.EIO, <span class="string">"Corrupted LogStorage"</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    st = Status.OK();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 回调响应</span></span><br><span class="line">                <span class="keyword">this</span>.storage.get(i).run(st);</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">                LOG.error(<span class="string">"Fail to run closure with status: {}."</span>, st, t);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.toAppend.clear();</span><br><span class="line">        <span class="keyword">this</span>.storage.clear();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.bufferSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.lastId;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> LogId <span class="title">appendToStorage</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; toAppend)</span> </span>{</span><br><span class="line">    LogId lastId = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasError) {</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> entriesCount = toAppend.size();</span><br><span class="line">        <span class="keyword">this</span>.nodeMetrics.recordSize(<span class="string">"append-logs-count"</span>, entriesCount);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// ... metrics</span></span><br><span class="line">            <span class="comment">// 将 LogEntry 写入 RocksDB</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> nAppent = <span class="keyword">this</span>.logStorage.appendEntries(toAppend);</span><br><span class="line">            <span class="keyword">if</span> (nAppent != entriesCount) {</span><br><span class="line">                LOG.error(<span class="string">"**Critical error**, fail to appendEntries, nAppent={}, toAppend={}"</span>, nAppent, toAppend.size());</span><br><span class="line">                reportError(RaftError.EIO.getNumber(), <span class="string">"Fail to append log entries"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 获取最新的 LogId</span></span><br><span class="line">            <span class="keyword">if</span> (nAppent &gt; <span class="number">0</span>) {</span><br><span class="line">                lastId = toAppend.get(nAppent - <span class="number">1</span>).getId();</span><br><span class="line">            }</span><br><span class="line">            toAppend.clear();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">this</span>.nodeMetrics.recordLatency(<span class="string">"append-logs"</span>, Utils.monotonicMs() - startMs);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lastId;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现最终会调用 <code>LogStorage#appendEntries</code> 方法将数据落盘，并返回最新的 LogId 实例。LogStorage 默认的实现是 RocksDBLogStorage 类，即将数据写入 RocksDB 存储引擎，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">appendEntries</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (entries == <span class="keyword">null</span> || entries.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesCount = entries.size();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ret = executeBatch(batch -&gt; {</span><br><span class="line">        <span class="keyword">final</span> WriteContext writeCtx = newWriteContext();</span><br><span class="line">        <span class="comment">// 遍历分类型将 LogEntry 写入 RocksDB</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entriesCount; i++) {</span><br><span class="line">            <span class="keyword">final</span> LogEntry entry = entries.get(i);</span><br><span class="line">            <span class="comment">// 配置类型的 LogEntry，编码之后写入 default 和 conf column family</span></span><br><span class="line">            <span class="keyword">if</span> (entry.getType() == EntryType.ENTRY_TYPE_CONFIGURATION) {</span><br><span class="line">                addConfBatch(entry, batch);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 其它类型的 LogEntry，编码之后写入 default column family</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                writeCtx.startJob();</span><br><span class="line">                addDataBatch(entry, batch, writeCtx);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        writeCtx.joinAll();</span><br><span class="line">        <span class="comment">// 模板方法</span></span><br><span class="line">        doSync();</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) {</span><br><span class="line">        <span class="keyword">return</span> entriesCount;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上一篇曾介绍过 RocksDBLogStorage 设置了两个 column family，即 conf family 和 data family，其中后者复用了 RocksDB 提供的默认 column family。由上述实现可以看到，JRaft 针对配置类型的 LogEntry 会同时写入这两个 family 中，而其它类型的 LogEntry 仅会写入到 data family 中。</p>

        <h5 id="RequestVote-预选举请求处理">
          <a href="#RequestVote-预选举请求处理" class="heading-link"><i class="fas fa-link"></i></a>RequestVote 预选举请求处理</h5>
      <p>发起预选举的节点会以 RPC 的方式向集群中的其它节点发送 RequestVote RPC 请求，以征集选票，各节点会基于本地的运行状态决定是否为其投上自己的一票。需要注意的两点是：</p>
<ol>
<li>预选举阶段的 RequestVote 请求会设置 <code>preVote = true</code>，以标识自己是一个预选举请求，用来与正式投票阶段的 RequestVote 请求请求相区别。</li>
<li>为了避免 term 值无谓的递增，预选举阶段不会真正递增 term 值，而只是将 term 加 1 进行试探性的发起投票。</li>
</ol>
<p>方法 <code>RaftServerService#handlePreVoteRequest</code> 实现了对于预选举阶段 RequestVote 请求的处理逻辑：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">handlePreVoteRequest</span><span class="params">(<span class="keyword">final</span> RequestVoteRequest request)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 当前节点处于非活跃状态，响应错误</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.state.isActive()) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} is not in active state, currTerm={}."</span>, getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">return</span> RpcFactoryHelper <span class="comment">//</span></span><br><span class="line">                    .responseFactory() <span class="comment">//</span></span><br><span class="line">                    .newResponse(RequestVoteResponse.getDefaultInstance(), RaftError.EINVAL,</span><br><span class="line">                            <span class="string">"Node %s is not in active state, state %s."</span>, getNodeId(), <span class="keyword">this</span>.state.name());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 解析发起投票的节点 ID</span></span><br><span class="line">        <span class="keyword">final</span> PeerId candidateId = <span class="keyword">new</span> PeerId();</span><br><span class="line">        <span class="keyword">if</span> (!candidateId.parse(request.getServerId())) {</span><br><span class="line">            <span class="comment">// 解析错误，响应错误</span></span><br><span class="line">            LOG.warn(<span class="string">"Node {} received PreVoteRequest from {} serverId bad format."</span>, getNodeId(), request.getServerId());</span><br><span class="line">            <span class="keyword">return</span> RpcFactoryHelper <span class="comment">//</span></span><br><span class="line">                    .responseFactory() <span class="comment">//</span></span><br><span class="line">                    .newResponse(RequestVoteResponse.getDefaultInstance(), RaftError.EINVAL,</span><br><span class="line">                            <span class="string">"Parse candidateId failed: %s."</span>, request.getServerId());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">boolean</span> granted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="comment">// 当前节点与对应 leader 节点之间的租约仍然有效，拒绝投票</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.leaderId != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.leaderId.isEmpty() &amp;&amp; isCurrentLeaderValid()) {</span><br><span class="line">                LOG.info(<span class="string">"Node {} ignore PreVoteRequest from {}, term={}, currTerm={}, because the leader {}'s lease is still valid."</span>,</span><br><span class="line">                        getNodeId(), request.getServerId(), request.getTerm(), <span class="keyword">this</span>.currTerm, <span class="keyword">this</span>.leaderId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 发起投票节点的 term 值小于当前节点，拒绝投票</span></span><br><span class="line">            <span class="keyword">if</span> (request.getTerm() &lt; <span class="keyword">this</span>.currTerm) {</span><br><span class="line">                LOG.info(<span class="string">"Node {} ignore PreVoteRequest from {}, term={}, currTerm={}."</span>,</span><br><span class="line">                        getNodeId(), request.getServerId(), request.getTerm(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">                <span class="comment">// A follower replicator may not be started when this node become leader, so we must check it.</span></span><br><span class="line">                <span class="comment">// 如果当前节点是 leader 节点，检查与发起投票节点之间的复制关系</span></span><br><span class="line">                checkReplicator(candidateId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (request.getTerm() == <span class="keyword">this</span>.currTerm + <span class="number">1</span>) {</span><br><span class="line">                <span class="comment">// A follower replicator may not be started when this node become leader, so we must check it.</span></span><br><span class="line">                <span class="comment">// check replicator state</span></span><br><span class="line">                checkReplicator(candidateId);</span><br><span class="line">            }</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取本地最新的 LogId</span></span><br><span class="line">            <span class="keyword">final</span> LogId lastLogId = <span class="keyword">this</span>.logManager.getLastLogId(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            doUnlock = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">            <span class="comment">// 封装请求中的 logIndex 和 term 值</span></span><br><span class="line">            <span class="keyword">final</span> LogId requestLastLogId = <span class="keyword">new</span> LogId(request.getLastLogIndex(), request.getLastLogTerm());</span><br><span class="line">            <span class="comment">// 如果请求的 term 值更大，或者在 term 值相等的前提下，请求的 logIndex 不小于当前节点的 logIndex 值，</span></span><br><span class="line">            <span class="comment">// 则投上自己的一票</span></span><br><span class="line">            granted = requestLastLogId.compareTo(lastLogId) &gt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            LOG.info(</span><br><span class="line">                    <span class="string">"Node {} received PreVoteRequest from {}, term={}, currTerm={}, granted={}, requestLastLogId={}, lastLogId={}."</span>,</span><br><span class="line">                    getNodeId(), request.getServerId(), request.getTerm(), <span class="keyword">this</span>.currTerm, granted, requestLastLogId,</span><br><span class="line">                    lastLogId);</span><br><span class="line">        } <span class="keyword">while</span> (<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        <span class="keyword">return</span> RequestVoteResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                .setGranted(granted) <span class="comment">//</span></span><br><span class="line">                .build();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) {</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>整体响应预选举 RequestVote 请求的执行流程可以概括为：</p>
<ol>
<li>如果当前节点处于非活跃状态，则响应错误；</li>
<li>否则，解析候选节点的节点 ID，如果解析出错，则响应错误；</li>
<li>否则，如果当前节点与对应 Leader 节点之间的租约仍然有效，则拒绝投票；</li>
<li>否则，如果候选节点的 term 值相较于当前节点小，则拒绝投票；如果当前节点正好是 Leader 节点，还需要检查候选节点与当前节点之间的复制关系；</li>
<li>否则，获取本地最新的 logIndex 和对应的 term 值，如果候选节点的 term 和 logIndex 值更新，则同意投票，否则拒绝投票。</li>
</ol>
<p>如果当前节点是 Leader 节点，但是仍然有节点发起预选举进程，则说明当前节点与目标节点之间的复制关系存在问题，需要重新建立复制关系，并启动对应的复制器 Replicator。关于 Replicator，我们将会在后面介绍日志复制机制时再深入分析，这里暂且跳过。</p>
<p>发起预选举的节点在发送 RequestVote RPC 请求时会为每个请求绑定一个 OnPreVoteRpcDone 回调，当目标节点返回响应时会应用该回调以处理 RequestVote 响应。具体的处理过程由 <code>NodeImpl#handlePreVoteResponse</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePreVoteResponse</span><span class="params">(<span class="keyword">final</span> PeerId peerId, <span class="keyword">final</span> <span class="keyword">long</span> term, <span class="keyword">final</span> RequestVoteResponse response)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 当前节点已经不是 FOLLOWER 角色，可能已经预选举成功了，忽略响应</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_FOLLOWER) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} received invalid PreVoteResponse from {}, "</span> +</span><br><span class="line">                    <span class="string">"state not in STATE_FOLLOWER but {}."</span>, getNodeId(), peerId, <span class="keyword">this</span>.state);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 当前节点的 term 值已经发生变化，忽略响应</span></span><br><span class="line">        <span class="keyword">if</span> (term != <span class="keyword">this</span>.currTerm) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} received invalid PreVoteResponse from {}, "</span> +</span><br><span class="line">                    <span class="string">"term={}, currTerm={}."</span>, getNodeId(), peerId, term, <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 目标节点的 term 值较当前节点更大，需要 stepdown，主要是更新本地的 term 值</span></span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; <span class="keyword">this</span>.currTerm) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} received invalid PreVoteResponse from {}, term {}, expect={}."</span>,</span><br><span class="line">                    getNodeId(), peerId, response.getTerm(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">            stepDown(response.getTerm(), <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                    <span class="string">"Raft node receives higher term pre_vote_response."</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        LOG.info(<span class="string">"Node {} received PreVoteResponse from {}, term={}, granted={}."</span>,</span><br><span class="line">                getNodeId(), peerId, response.getTerm(), response.getGranted());</span><br><span class="line">        <span class="comment">// check granted quorum?</span></span><br><span class="line">        <span class="keyword">if</span> (response.getGranted()) {</span><br><span class="line">            <span class="comment">// 目标节点同意投票</span></span><br><span class="line">            <span class="keyword">this</span>.prevVoteCtx.grant(peerId);</span><br><span class="line">            <span class="comment">// 检查是否预选举成功</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.prevVoteCtx.isGranted()) {</span><br><span class="line">                doUnlock = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 进入正式投票环境</span></span><br><span class="line">                electSelf();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) {</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于预选举 RequestVote 响应的整体处理流程可以概括如下：</p>
<ol>
<li>校验当前节点是否仍然是 FOLLOWER 角色，如果不是则忽略响应，可能已经预选举成功了；</li>
<li>否则，校验当前节点的 term 值是否发生变化，如果是则忽略响应；</li>
<li>否则，如果目标节点的 term 值较当前节点更大，则忽略响应，并执行 stepdown；</li>
<li>否则，如果目标节点拒绝投票，则忽略响应；</li>
<li>否则，如果目标节点同意投票，则更新得票数，并检查是否预选举成功，如果是则进入正式投票环节。</li>
</ol>
<p>如果当前节点在预选举期间收到 term 值更大的 RequestVote 响应，则会执行 stepdown 逻辑。此时节点的角色仍然是 FOLLOWER，所以除了重置本地状态和再次启动预选举计时器之外，一个重要的工作就是更新当前节点的 term 值，以保证与当前集群已知的最大 term 值看齐。</p>
<p>JRaft 在实现层面大量应用了回调机制，例如上述在处理预选举响应时会让每个目标节点的响应在同意投票的前提下都会回调触发一次 <code>Ballot#grant</code> 操作以更新得票数，并调用 <code>Ballot#isGranted</code> 方法检查得票数是否过半，如果是则进入正式投票的环节。此类异步回调机制在整个 JRaft 设计和实现中比较常见，其思想值得借鉴，不过重度依赖回调可能会让程序陷入 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://callbackhell.com/">Callback Hell</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，需要把控尺度。</p>

        <h4 id="正式选举">
          <a href="#正式选举" class="heading-link"><i class="fas fa-link"></i></a>正式选举</h4>
      <p>当预选举成功之后，节点接下去会执行 <code>NodeImpl#electSelf</code> 方法进入正式选举进程。实际上，正式选举与预选举在执行流程上基本相同，但是仍然有些细微的差别，本小节一起来分析一下。</p>
<p>触发正式选举进程，除了发生在预选举成功之后之外，主要还包括另外两个场景：</p>
<ol>
<li>在只有一个节点的情况下，此时该节点一定能够竞选成功，所以没有进行预选举的必要。</li>
<li>正式选举阶段超时，此时需要再次发起一轮新的正式选举进程，这也是正式选举计时器 voteTimer 的职责。</li>
</ol>
<p>方法 <code>NodeImpl#electSelf</code> 的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">electSelf</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> oldTerm;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        LOG.info(<span class="string">"Node {} start vote and grant vote self, term={}."</span>, getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">        <span class="comment">// 当前节点不是一个合法节点</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.conf.contains(<span class="keyword">this</span>.serverId)) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} can't do electSelf as it is not in {}."</span>, getNodeId(), <span class="keyword">this</span>.conf);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 当前节点第一次尝试正式选举，需要暂时停止预选举计时器，避免期间再次触发预选举</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state == State.STATE_FOLLOWER) {</span><br><span class="line">            LOG.debug(<span class="string">"Node {} stop election timer, term={}."</span>, getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">this</span>.electionTimer.stop();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 清空本地记录的 Leader 节点 ID</span></span><br><span class="line">        resetLeaderId(PeerId.emptyPeer(), <span class="keyword">new</span> Status(RaftError.ERAFTTIMEDOUT,</span><br><span class="line">                <span class="string">"A follower's leader_id is reset to NULL as it begins to request_vote."</span>));</span><br><span class="line">        <span class="comment">// 切换角色为 CANDIDATE</span></span><br><span class="line">        <span class="keyword">this</span>.state = State.STATE_CANDIDATE;</span><br><span class="line">        <span class="comment">// 正式投票环境真正递增 term 值，而预选举阶段不会</span></span><br><span class="line">        <span class="keyword">this</span>.currTerm++;</span><br><span class="line">        <span class="comment">// 更新 votedId 字段，标记投票给自己</span></span><br><span class="line">        <span class="keyword">this</span>.votedId = <span class="keyword">this</span>.serverId.copy();</span><br><span class="line">        LOG.debug(<span class="string">"Node {} start vote timer, term={} ."</span>, getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">        <span class="comment">// 启动正式选举计时器，当选举超时会再次触发正式选举进程</span></span><br><span class="line">        <span class="keyword">this</span>.voteTimer.start();</span><br><span class="line">        <span class="comment">// 初始化正式选举选票</span></span><br><span class="line">        <span class="keyword">this</span>.voteCtx.init(<span class="keyword">this</span>.conf.getConf(), <span class="keyword">this</span>.conf.isStable() ? <span class="keyword">null</span> : <span class="keyword">this</span>.conf.getOldConf());</span><br><span class="line">        oldTerm = <span class="keyword">this</span>.currTerm;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从本地加载最新的 logIndex 和对应的 term 值</span></span><br><span class="line">    <span class="keyword">final</span> LogId lastLogId = <span class="keyword">this</span>.logManager.getLastLogId(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// vote need defense ABA after unlock&amp;writeLock</span></span><br><span class="line">        <span class="keyword">if</span> (oldTerm != <span class="keyword">this</span>.currTerm) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} raise term {} when getLastLogId."</span>, getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 遍历向除自己以外的所有连通节点发送 RequestVote RPC 请求，以征集选票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> PeerId peer : <span class="keyword">this</span>.conf.listPeers()) {</span><br><span class="line">            <span class="keyword">if</span> (peer.equals(<span class="keyword">this</span>.serverId)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.rpcService.connect(peer.getEndpoint())) {</span><br><span class="line">                LOG.warn(<span class="string">"Node {} channel init failed, address={}."</span>, getNodeId(), peer.getEndpoint());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">final</span> OnRequestVoteRpcDone done = <span class="keyword">new</span> OnRequestVoteRpcDone(peer, <span class="keyword">this</span>.currTerm, <span class="keyword">this</span>);</span><br><span class="line">            done.request = RequestVoteRequest.newBuilder() <span class="comment">//</span></span><br><span class="line">                    .setPreVote(<span class="keyword">false</span>) <span class="comment">// It's not a pre-vote request. 标记是正式选举</span></span><br><span class="line">                    .setGroupId(<span class="keyword">this</span>.groupId) <span class="comment">//</span></span><br><span class="line">                    .setServerId(<span class="keyword">this</span>.serverId.toString()) <span class="comment">//</span></span><br><span class="line">                    .setPeerId(peer.toString()) <span class="comment">//</span></span><br><span class="line">                    .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">// 这里是递增后的 term 值</span></span><br><span class="line">                    .setLastLogIndex(lastLogId.getIndex()) <span class="comment">//</span></span><br><span class="line">                    .setLastLogTerm(lastLogId.getTerm()) <span class="comment">//</span></span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 发送 RPC 请求</span></span><br><span class="line">            <span class="keyword">this</span>.rpcService.requestVote(peer.getEndpoint(), done.request, done);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更本地元数据信息</span></span><br><span class="line">        <span class="keyword">this</span>.metaStorage.setTermAndVotedFor(<span class="keyword">this</span>.currTerm, <span class="keyword">this</span>.serverId);</span><br><span class="line">        <span class="comment">// 给自己投上一票</span></span><br><span class="line">        <span class="keyword">this</span>.voteCtx.grant(<span class="keyword">this</span>.serverId);</span><br><span class="line">        <span class="comment">// 检查是否竞选成功</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.voteCtx.isGranted()) {</span><br><span class="line">            <span class="comment">// 成为 leader 节点</span></span><br><span class="line">            becomeLeader();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>正式选举进程的整体执行流程可以概括如下：</p>
<ol>
<li>校验当前节点是否是合法节点，即属于集群节点配置集合中的一员，如果不是则放弃参选；</li>
<li>如果当前节点是 FOLLOWER 角色，说明是刚刚从预选举阶段过渡而来，需要停止预选举计时器 electionTimer，避免期间再次发起新的预选举进程；</li>
<li>重置本地记录的 leader 节点的 ID；</li>
<li>切换节点为 CANDIDATE 角色、递增 term 值，以及更新 votedId 为当前节点 ID；</li>
<li>启动正式选举计时器 voteTimer，用于当正式选举超时时，再次发起一轮新的正式选举进程；</li>
<li>初始化正式选票 Ballot 实例；</li>
<li>获取本地最新的 logIndex 和对应的 term 值；</li>
<li>遍历向除自己以外的所有连通节点发送 RequestVote RPC 请求，以征集选票，同时给自己投上一票；</li>
<li>更新本地元数据信息，即 term 值和 votedId 值；</li>
<li>如果票数过半，则执行 <code>NodeImpl#becomeLeader</code> 操作以切换角色为 LEADER，即竞选成功。</li>
</ol>
<p>总的来说，正式选举与预选举阶段的执行流程基本相同，不过在正式选举阶段会真正递增 term 值。</p>
<p>下面来看一下节点对于正式选举 RequestVote RPC 请求的处理过程，实现位于 <code>NodeImpl#handleRequestVoteRequest</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">handleRequestVoteRequest</span><span class="params">(<span class="keyword">final</span> RequestVoteRequest request)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 节点处于非活跃状态，响应错误</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.state.isActive()) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} is not in active state, currTerm={}."</span>, getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">return</span> RpcFactoryHelper <span class="comment">//</span></span><br><span class="line">                    .responseFactory() <span class="comment">//</span></span><br><span class="line">                    .newResponse(RequestVoteResponse.getDefaultInstance(), RaftError.EINVAL,</span><br><span class="line">                            <span class="string">"Node %s is not in active state, state %s."</span>, getNodeId(), <span class="keyword">this</span>.state.name());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 解析发起正式选举的节点 ID</span></span><br><span class="line">        <span class="keyword">final</span> PeerId candidateId = <span class="keyword">new</span> PeerId();</span><br><span class="line">        <span class="comment">// 解析失败，响应错误</span></span><br><span class="line">        <span class="keyword">if</span> (!candidateId.parse(request.getServerId())) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} received RequestVoteRequest from {} serverId bad format."</span>, getNodeId(), request.getServerId());</span><br><span class="line">            <span class="keyword">return</span> RpcFactoryHelper <span class="comment">//</span></span><br><span class="line">                    .responseFactory() <span class="comment">//</span></span><br><span class="line">                    .newResponse(RequestVoteResponse.getDefaultInstance(), RaftError.EINVAL,</span><br><span class="line">                            <span class="string">"Parse candidateId failed: %s."</span>, request.getServerId());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="comment">// check term</span></span><br><span class="line">            <span class="keyword">if</span> (request.getTerm() &gt;= <span class="keyword">this</span>.currTerm) {</span><br><span class="line">                LOG.info(<span class="string">"Node {} received RequestVoteRequest from {}, term={}, currTerm={}."</span>,</span><br><span class="line">                        getNodeId(), request.getServerId(), request.getTerm(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">                <span class="comment">// 候选节点的 term 值大于当前节点，执行 stepdown</span></span><br><span class="line">                <span class="keyword">if</span> (request.getTerm() &gt; <span class="keyword">this</span>.currTerm) {</span><br><span class="line">                    <span class="comment">// increase current term, change state to follower</span></span><br><span class="line">                    stepDown(request.getTerm(), <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                            <span class="string">"Raft node receives higher term RequestVoteRequest."</span>));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 候选节点的 term 值小于当前节点，拒绝投票</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// ignore older term</span></span><br><span class="line">                LOG.info(<span class="string">"Node {} ignore RequestVoteRequest from {}, term={}, currTerm={}."</span>,</span><br><span class="line">                        getNodeId(), request.getServerId(), request.getTerm(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从本地获取最新的 logIndex 和对应的 term 值</span></span><br><span class="line">            <span class="keyword">final</span> LogId lastLogId = <span class="keyword">this</span>.logManager.getLastLogId(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            doUnlock = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">            <span class="comment">// vote need ABA check after unlock&amp;writeLock</span></span><br><span class="line">            <span class="keyword">if</span> (request.getTerm() != <span class="keyword">this</span>.currTerm) {</span><br><span class="line">                LOG.warn(<span class="string">"Node {} raise term {} when get lastLogId."</span>, getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 logIsOk，则说明候选节点的 term 值大于当前节点，或者 term 相同，但是候选节点的 logIndex 不比当前节点小</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logIsOk = <span class="keyword">new</span> LogId(request.getLastLogIndex(), request.getLastLogTerm())</span><br><span class="line">                    .compareTo(lastLogId) &gt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 logIsOk，且当前节点目前没有投票给其它节点</span></span><br><span class="line">            <span class="keyword">if</span> (logIsOk &amp;&amp; (<span class="keyword">this</span>.votedId == <span class="keyword">null</span> || <span class="keyword">this</span>.votedId.isEmpty())) {</span><br><span class="line">                stepDown(request.getTerm(), <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.EVOTEFORCANDIDATE,</span><br><span class="line">                        <span class="string">"Raft node votes for some candidate, step down to restart election_timer."</span>));</span><br><span class="line">                <span class="keyword">this</span>.votedId = candidateId.copy();</span><br><span class="line">                <span class="comment">// 更新本地元数据信息</span></span><br><span class="line">                <span class="keyword">this</span>.metaStorage.setVotedFor(candidateId);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">while</span> (<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送 RequestVote RPC 响应</span></span><br><span class="line">        <span class="keyword">return</span> RequestVoteResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                .setGranted(request.getTerm() == <span class="keyword">this</span>.currTerm &amp;&amp; candidateId.equals(<span class="keyword">this</span>.votedId)) <span class="comment">//</span></span><br><span class="line">                .build();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) {</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>响应正式选举 RequestVote 请求的整体执行流程可以概括为：</p>
<ol>
<li>如果当前节点处于非活跃状态，则响应错误；</li>
<li>否则，解析候选节点的节点 ID，如果解析出错则响应错误；</li>
<li>否则，如果候选节点的 term 值小于当前节点，则拒绝投票；</li>
<li>否则，如果候选节点的 term 值大于当前节点，则需要执行 stepdown；</li>
<li>如果候选节点的 term 值更新，或者 term 值相同但是对应的 logIndex 不小于当前节点，且当前节点未投票给其它节点，则同意投票，同时更新本地元数据信息；</li>
<li>否则，拒绝投票。</li>
</ol>
<p>关于步骤 4，此时处理 RequestVote RPC 请求的节点角色仍然是 FOLLOWER，所以除了重置本地状态和再次启动预选举计时器之外，一个重要的工作就是更新当前节点的 term 值，以保证与当前集群已知的最大 term 值看齐。</p>
<p>发起正式选举请求的节点在发送 RequestVote RPC 请求时会为每个请求绑定一个 OnRequestVoteRpcDone 回调，当目标节点返回响应时会应用该回调以处理 RequestVote 响应。具体的处理过程由 <code>NodeImpl#handleRequestVoteResponse</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequestVoteResponse</span><span class="params">(<span class="keyword">final</span> PeerId peerId, <span class="keyword">final</span> <span class="keyword">long</span> term, <span class="keyword">final</span> RequestVoteResponse response)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 当前节点已经不是 CANDIDATE 角色，可能以及竞选成功，或者被打回 FOLLOWER 角色了，忽略响应</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_CANDIDATE) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} received invalid RequestVoteResponse from {}, state not in STATE_CANDIDATE but {}."</span>,</span><br><span class="line">                    getNodeId(), peerId, <span class="keyword">this</span>.state);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 期间 term 值已经发生变化，忽略响应</span></span><br><span class="line">        <span class="keyword">if</span> (term != <span class="keyword">this</span>.currTerm) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} received stale RequestVoteResponse from {}, term={}, currTerm={}."</span>,</span><br><span class="line">                    getNodeId(), peerId, term, <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标节点的 term 值比当前节点大，需要执行 stepdown</span></span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; <span class="keyword">this</span>.currTerm) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} received invalid RequestVoteResponse from {}, term={}, expect={}."</span>,</span><br><span class="line">                    getNodeId(), peerId, response.getTerm(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">            stepDown(response.getTerm(), <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                    <span class="string">"Raft node receives higher term request_vote_response."</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// check granted quorum?</span></span><br><span class="line">        <span class="keyword">if</span> (response.getGranted()) {</span><br><span class="line">            <span class="keyword">this</span>.voteCtx.grant(peerId);</span><br><span class="line">            <span class="comment">// 如果票数过半，则竞选成功</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.voteCtx.isGranted()) {</span><br><span class="line">                becomeLeader();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于正式选举 RequestVote 响应的整体处理流程可以概括如下：</p>
<ol>
<li>校验当前节点是不是 CANDIDATE 角色，如果不是则可能已经竞选成功，或者被打回成了 FOLLOWER 角色，忽略响应；</li>
<li>否则，校验等待响应期间节点的 term 值是否发生变化，如果是则忽略响应；</li>
<li>否则，如果目标节点的 term 值相较于当前节点更大，则需要忽略响应，并执行 stepdown；</li>
<li>否则，如果目标节点同意投票，则更新选票计数，否则忽略响应；</li>
<li>如果票数过半，则执行 <code>NodeImpl#becomeLeader</code> 方法成为 LEADER 角色。</li>
</ol>
<p>关于步骤 3，当前节点角色为 CANDIDATE，所以执行 stepdown 会让当前节点停止正式选举计时器，并切换角色为 FOLLOWER，并再次启动预选举计时器。此外，还会更新当前节点的 term 值，以保证与当前集群已知的最大 term 值看齐。</p>
<p>如果当前节点票数过半，则接下去会调用 <code>NodeImpl#becomeLeader</code> 方法执行从 CANDIDATE 到 LEADER 的角色转变，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">becomeLeader</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 前置角色必须是 CANDIDATE</span></span><br><span class="line">    Requires.requireTrue(<span class="keyword">this</span>.state == State.STATE_CANDIDATE, <span class="string">"Illegal state: "</span> + <span class="keyword">this</span>.state);</span><br><span class="line">    LOG.info(<span class="string">"Node {} become leader of group, term={}, conf={}, oldConf={}."</span>,</span><br><span class="line">            getNodeId(), <span class="keyword">this</span>.currTerm, <span class="keyword">this</span>.conf.getConf(), <span class="keyword">this</span>.conf.getOldConf());</span><br><span class="line">    <span class="comment">// 停止正式选举计时器</span></span><br><span class="line">    stopVoteTimer();</span><br><span class="line">    <span class="comment">// 切换角色为 LEADER</span></span><br><span class="line">    <span class="keyword">this</span>.state = State.STATE_LEADER;</span><br><span class="line">    <span class="comment">// 更新本地记录的 leader 节点 ID</span></span><br><span class="line">    <span class="keyword">this</span>.leaderId = <span class="keyword">this</span>.serverId.copy();</span><br><span class="line">    <span class="comment">// 设置复制器组的 term 值</span></span><br><span class="line">    <span class="keyword">this</span>.replicatorGroup.resetTerm(<span class="keyword">this</span>.currTerm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 Follower 节点：遍历将集群中除自己以外的 Follower 节点纳为自己的 Follower，并建立到这些节点的复制关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> PeerId peer : <span class="keyword">this</span>.conf.listPeers()) {</span><br><span class="line">        <span class="keyword">if</span> (peer.equals(<span class="keyword">this</span>.serverId)) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        LOG.debug(<span class="string">"Node {} add a replicator, term={}, peer={}."</span>, getNodeId(), <span class="keyword">this</span>.currTerm, peer);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.replicatorGroup.addReplicator(peer)) {</span><br><span class="line">            LOG.error(<span class="string">"Fail to add a replicator, peer={}."</span>, peer);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 Learner 节点：遍历将集群中除自己以外的 Learner 节点纳为自己的 Learner，并建立到这些节点的复制关系</span></span><br><span class="line">    <span class="comment">// Learner 节点只是复制日志，不会对日志的提交做决策</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> PeerId peer : <span class="keyword">this</span>.conf.listLearners()) {</span><br><span class="line">        LOG.debug(<span class="string">"Node {} add a learner replicator, term={}, peer={}."</span>, getNodeId(), <span class="keyword">this</span>.currTerm, peer);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.replicatorGroup.addReplicator(peer, ReplicatorType.Learner)) {</span><br><span class="line">            LOG.error(<span class="string">"Fail to add a learner replicator, peer={}."</span>, peer);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置选票箱</span></span><br><span class="line">    <span class="keyword">this</span>.ballotBox.resetPendingIndex(<span class="keyword">this</span>.logManager.getLastLogIndex() + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Register _conf_ctx to reject configuration changing before the first log is committed.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.confCtx.isBusy()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 将当前集群配置信息写入日志</span></span><br><span class="line">    <span class="keyword">this</span>.confCtx.flush(<span class="keyword">this</span>.conf.getConf(), <span class="keyword">this</span>.conf.getOldConf());</span><br><span class="line">    <span class="comment">// 启动 stepdown 计时器</span></span><br><span class="line">    <span class="keyword">this</span>.stepDownTimer.start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>整体的执行流程可以概括为：</p>
<ol>
<li>校验当前节点角色是否为 CANDIDATE，LEADER 角色的前置角色必须是 CANDIDATE；</li>
<li>停止正式选举计时器 voteTimer；</li>
<li>切换节点角色为 LEADER；</li>
<li>建立到除自己以外的所有节点之间的复制关系，包括 Follower 和 Learner；</li>
<li>重置选票箱 BallotBox；</li>
<li>将当前集群的节点配置信息记录到日志中；</li>
<li>启动 stepdown 计时器 stepDownTimer。</li>
</ol>
<p>JRaft 中的节点区分 Learner 和非 Learner 角色，官方对于 Learner 角色的说明如下：</p>
<blockquote>
<p>Learner 节点也叫只读节点，只读节点类似于 Follower 节点，将从 Leader 复制日志并应用到本地状态机中，但是不参与选举，复制日志成功也不会被认为是多数派的一员。简而言之，除了复制日志以外，只读成员不参与其他任何 Raft 算法过程。一般应用在为某个服务创建一个只读服务的时候，实现类似读写分离的效果，或者数据冷备等场景。</p>
</blockquote>
<p>当一个节点竞选成功成为 LEADER 角色之后，按照 Raft 的强 Leader 约束，所有集群中的其它节点将成为该 Leader 节点的 Follower 节点。所以，Leader 节点需要建立到这些节点的复制关系，包括 Learner 和非 Learner 节点。关于 <code>ReplicatorGroup#addReplicator</code> 的实现将在后面介绍日志复制机制时再展开分析。</p>
<p>方法 <code>ConfigurationCtx#flush</code> 会将当前集群的节点配置信息作为当前节点成为 LEADER 角色之后的第一条日志同步给集群中的 Follower 节点，关于日志复制机制这里先不展开，后面将用一篇文章针对性介绍。这里需要关注的一点是 Leader 节点在将日志数据同步出去之前会设置一个 ConfigurationChangeDone 回调，并在日志数据被 committed 之后触发执行 <code>ConfigurationChangeDone#run</code> 方法。实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (status.isOk()) {</span><br><span class="line">        <span class="comment">// 尝试让集群节点配置趋于稳定</span></span><br><span class="line">        onConfigurationChangeDone(<span class="keyword">this</span>.term);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.leaderStart) {</span><br><span class="line">            <span class="comment">// 回调状态机 StateMachine#onLeaderStart 逻辑</span></span><br><span class="line">            getOptions().getFsm().onLeaderStart(<span class="keyword">this</span>.term);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        LOG.error(<span class="string">"Fail to run ConfigurationChangeDone, status: {}."</span>, status);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法在节点成为 Leader 时会回调由应用程序实现的 <code>StateMachine#onLeaderStart</code> 方法。此外，方法 <code>NodeImpl#onConfigurationChangeDone</code> 则尝试让集群节点配置趋于稳定，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChangeDone</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> term)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 期间 term 值发生变更，或者当前节点已经不是 Leader，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (term != <span class="keyword">this</span>.currTerm || <span class="keyword">this</span>.state.compareTo(State.STATE_TRANSFERRING) &gt; <span class="number">0</span>) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} process onConfigurationChangeDone at term {} while state={}, currTerm={}."</span>,</span><br><span class="line">                    getNodeId(), term, <span class="keyword">this</span>.state, <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将集群配置状态切换到下一个阶段</span></span><br><span class="line">        <span class="keyword">this</span>.confCtx.nextStage();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>在 Leader 选举场景下，集群节点配置上下文 ConfigurationCtx 的 stage 分为 <code>STAGE_STABLE</code> 和 <code>STAGE_JOINT</code> 两类，前者表示集群配置已经趋于稳定，而后者则表示集群目前存在新老配置过渡的情况。ConfigurationCtx 针对这两类 stage 的处理逻辑实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alipay.sofa.jraft.core.NodeImpl.ConfigurationCtx#nextStage</span></span><br><span class="line"><span class="keyword">case</span> STAGE_JOINT:</span><br><span class="line">    <span class="keyword">this</span>.stage = Stage.STAGE_STABLE;</span><br><span class="line">    <span class="comment">// 再次应用配置变更，剔除老的配置信息</span></span><br><span class="line">    <span class="keyword">this</span>.node.unsafeApplyConfiguration(<span class="keyword">new</span> Configuration(<span class="keyword">this</span>.newPeers, <span class="keyword">this</span>.newLearners), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STAGE_STABLE:</span><br><span class="line">    <span class="comment">// 当前集群节点配置是否包含当前节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldStepDown = !<span class="keyword">this</span>.newPeers.contains(<span class="keyword">this</span>.node.serverId);</span><br><span class="line">    reset(<span class="keyword">new</span> Status());</span><br><span class="line">    <span class="keyword">if</span> (shouldStepDown) {</span><br><span class="line">        <span class="keyword">this</span>.node.stepDown(<span class="keyword">this</span>.node.currTerm, <span class="keyword">true</span>,</span><br><span class="line">                <span class="keyword">new</span> Status(RaftError.ELEADERREMOVED, <span class="string">"This node was removed."</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></div></figure>
<p>具体执行逻辑如上述代码注释。关于 Raft 算法的集群节点配置变更算是一个相对复杂的问题，这里不打算展开说明，后续考虑用一篇文章针对性介绍。</p>
<p>此外，在节点成为 LEADER 角色之后会将集群配置信息作为第一条日志进行提交，还有另外一个考虑。当一个节点刚刚竞选成为 LEADER 角色时，此时该节点本地的 committedIndex 值并不一定是当前整个系统范围内最新的 committedIndex 值，这会影响线性一致性读结果的准确性，而通过提交日志操作则能够保证新的 Leader 节点的 committedIndex 被更新为集群范围内的最新值。</p>

        <h3 id="Leader-让权">
          <a href="#Leader-让权" class="heading-link"><i class="fas fa-link"></i></a>Leader 让权</h3>
      <p>Leader 节点需要定期检查自己的权威是否持续有效，即集群中过半数的 Follower 节点都能响应自己的心跳请求，如果不是则需要让权。这一过程由 stepdown 计时器 stepDownTimer 负责，由前面 <code>NodeImpl#becomeLeader</code> 方法的实现也可以看到在节点成为 LEADER 角色之后会启动 stepdown 计时器。该计时器的核心逻辑由 <code>NodeImpl#handleStepDownTimeout</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStepDownTimeout</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 当前节点不是 LEADER 角色，无需让权</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state.compareTo(State.STATE_TRANSFERRING) &gt; <span class="number">0</span>) {</span><br><span class="line">            LOG.debug(<span class="string">"Node {} stop step-down timer, term={}, state={}."</span>, getNodeId(), <span class="keyword">this</span>.currTerm, <span class="keyword">this</span>.state);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> monotonicNowMs = Utils.monotonicMs();</span><br><span class="line">        <span class="comment">// 检查集群中是否有超过半数的 Follower 节点仍然在响应自己的心跳请求，如果不是则执行让权操作</span></span><br><span class="line">        checkDeadNodes(<span class="keyword">this</span>.conf.getConf(), monotonicNowMs);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.conf.getOldConf().isEmpty()) {</span><br><span class="line">            checkDeadNodes(<span class="keyword">this</span>.conf.getOldConf(), monotonicNowMs);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkDeadNodes</span><span class="params">(<span class="keyword">final</span> Configuration conf, <span class="keyword">final</span> <span class="keyword">long</span> monotonicNowMs)</span> </span>{</span><br><span class="line">    <span class="comment">// Check learner replicators at first.</span></span><br><span class="line">    <span class="keyword">for</span> (PeerId peer : conf.getLearners()) {</span><br><span class="line">        <span class="comment">// 确定到所有 Learner 节点的复制关系都建立了</span></span><br><span class="line">        checkReplicator(peer);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Ensure quorum nodes alive.</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;PeerId&gt; peers = conf.listPeers();</span><br><span class="line">    <span class="keyword">final</span> Configuration deadNodes = <span class="keyword">new</span> Configuration();</span><br><span class="line">    <span class="comment">// 如果集群中认同当前 Leader 节点的 Follower 节点数过半，则无需让权</span></span><br><span class="line">    <span class="keyword">if</span> (checkDeadNodes0(peers, monotonicNowMs, <span class="keyword">true</span>, deadNodes)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    LOG.warn(<span class="string">"Node {} steps down when alive nodes don't satisfy quorum, "</span> +</span><br><span class="line">            <span class="string">"term={}, deadNodes={}, conf={}."</span>, getNodeId(), <span class="keyword">this</span>.currTerm, deadNodes, conf);</span><br><span class="line">    <span class="keyword">final</span> Status status = <span class="keyword">new</span> Status();</span><br><span class="line">    status.setError(RaftError.ERAFTTIMEDOUT, <span class="string">"Majority of the group dies: %d/%d"</span>, deadNodes.size(), peers.size());</span><br><span class="line">    <span class="comment">// 集群中认同当前 Leader 节点的 Follower 节点数小于一半，执行让权操作</span></span><br><span class="line">    stepDown(<span class="keyword">this</span>.currTerm, <span class="keyword">false</span>, status);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>其中方法 <code>NodeImpl#checkDeadNodes0</code> 会检查目标 Follower 节点与当前 Leader 节点最近一次的 RPC 请求时间戳，以此决定对应的租约是否仍然有效，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkDeadNodes0</span><span class="params">(<span class="keyword">final</span> List&lt;PeerId&gt; peers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> <span class="keyword">long</span> monotonicNowMs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> <span class="keyword">boolean</span> checkReplicator,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> Configuration deadNodes)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取租约时长，默认为选举超时的 90%</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> leaderLeaseTimeoutMs = <span class="keyword">this</span>.options.getLeaderLeaseTimeoutMs();</span><br><span class="line">    <span class="keyword">int</span> aliveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录向所有活跃节点发送 RPC 请求的最小时间戳</span></span><br><span class="line">    <span class="keyword">long</span> startLease = Long.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 遍历逐个检查目标 Follower 节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> PeerId peer : peers) {</span><br><span class="line">        <span class="keyword">if</span> (peer.equals(<span class="keyword">this</span>.serverId)) {</span><br><span class="line">            aliveCount++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 检查到目标节点之间的复制关系，避免因为缺失复制关系而误将目标节点判为死亡</span></span><br><span class="line">        <span class="keyword">if</span> (checkReplicator) {</span><br><span class="line">            checkReplicator(peer);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获取最近一次成功向目标节点发送 RPC 请求的时间戳</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> lastRpcSendTimestamp = <span class="keyword">this</span>.replicatorGroup.getLastRpcSendTimestamp(peer);</span><br><span class="line">        <span class="comment">// 到目标节点的租约仍然有效，则视目标节点仍然活跃</span></span><br><span class="line">        <span class="keyword">if</span> (monotonicNowMs - lastRpcSendTimestamp &lt;= leaderLeaseTimeoutMs) {</span><br><span class="line">            aliveCount++; <span class="comment">// 活跃节点数加 1</span></span><br><span class="line">            <span class="comment">// 更新向所有活跃节点发送 RPC 请求的最小时间戳</span></span><br><span class="line">            <span class="keyword">if</span> (startLease &gt; lastRpcSendTimestamp) {</span><br><span class="line">                startLease = lastRpcSendTimestamp;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 记录死亡节点</span></span><br><span class="line">        <span class="keyword">if</span> (deadNodes != <span class="keyword">null</span>) {</span><br><span class="line">            deadNodes.addPeer(peer);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 活跃节点数过半，说明当前 Leader 节点仍然有效，更新时间戳（向所有活跃节点发送 RPC 请求的最小时间戳）</span></span><br><span class="line">    <span class="keyword">if</span> (aliveCount &gt;= peers.size() / <span class="number">2</span> + <span class="number">1</span>) {</span><br><span class="line">        updateLastLeaderTimestamp(startLease);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果过半数的 Follower 节点对应的租约都失效，则当前 Leader 节点需要执行让权操作，因为集群有可能正在或已经选举出新的 Leader 节点。如果过半数的 Follower 节点对应的租约仍然有效，则上述操作会使用 <code>NodeImpl#lastLeaderTimestamp</code> 字段记录向这些 Follower 节点成功发送 RPC 请求的最早时间。该字段对于 Leader 节点而言用于在 LeaseRead 策略的线性一致性读场景下判断当前 Leader 节点是否仍然有效，具体将在后面介绍线性一致性读机制的文章中展开介绍。</p>
<p>让权操作的过程由 <code>NodeImpl#stepDown</code> 方法实现，该方法我们在前面已经多次遇到过，只是每次调用时节点的状态不同而已。此时，节点以 LEADER 角色调用该方法，除了将角色切换成 FOLLOWER、初始化本地状态，以及启动预选举计时器 electionTimer 之外，在此之前还会执行如下一段逻辑：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止 stepdown 计时器</span></span><br><span class="line">stopStepDownTimer();</span><br><span class="line"><span class="comment">// 清空选票箱</span></span><br><span class="line"><span class="keyword">this</span>.ballotBox.clearPendingTasks();</span><br><span class="line"><span class="comment">// signal fsm leader stop immediately</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.state == State.STATE_LEADER) {</span><br><span class="line">    <span class="comment">// 向状态机调度器发布 LEADER_STOP 事件</span></span><br><span class="line">    onLeaderStop(status);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>状态机调度器的运行机制我们在前面已经介绍过，<code>LEADER_STOP</code> 状态机事件会触发 FSMCaller 回调应用程序实现的 <code>StateMachine#onLeaderStop</code> 方法，这与我们前面介绍的回调应用程序实现的 <code>StateMachine#onLeaderStart</code> 方法相呼应。</p>

        <h3 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>主节点选举是 Raft 算法的核心组成部分，是支持 Raft 集群运行所不可或缺的一部分。Raft 算法采用 Strong Leader 的设计，要求整个 Raft 集群必须只有一个 Leader 节点，所有其它 Follower 节点必须服从于 Leader 节点。这为简化共识算法的设计和实现起到了积极的作用，但我们也不能否认 Leader 节点在整个 Raft 算法的运行过程中负担了太多。</p>
<p>本文我们从源码层面分析了 JRaft 算法库关于主节点选举机制的实现。有别于 Raft 算法，JRaft 将主节点选举拆分为预选举和正式选举两个阶段，以此避免无效的选举影响 Leader 节点的正常运行，进而最终影响整个集群的稳定性。此外，通过实现我们也能感受到计时器在 Raft 算法设计中的重要地位，而随机化计时时间这么一个小小的优化则解决了协议运行所面临的重大隐患。</p>

        <h3 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h3>
      <ol>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://raft.github.io/">Raft Consensus Algorithm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.sofastack.tech/projects/sofa-jraft/overview/">SOFA-JRaft 官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.sofastack.tech/blog/sofa-jraft-election-mechanism/">SOFA-JRaft：选举机制剖析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2020/06/08/sofa/sofa-jraft-leader-election/">https://plotor.github.io/2020/06/08/sofa/sofa-jraft-leader-election/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/Raft/">Raft</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/SOFA-JRaft/">SOFA-JRaft</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/06/15/sofa/sofa-jraft-log-replication/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">SOFA-JRaft 源码解析：日志复制机制</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/06/01/sofa/sofa-jraft-node-startup/"><span class="paginator-prev__text">SOFA-JRaft 源码解析：节点的启动过程</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Leader-%E9%80%89%E4%B8%BE"><span class="toc-number">1.</span> <span class="toc-text">
          Leader 选举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E9%80%89%E4%B8%BE"><span class="toc-number">1.1.</span> <span class="toc-text">
          预选举</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%80%E6%96%B0-LogId-%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          加载最新 LogId 数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RequestVote-%E9%A2%84%E9%80%89%E4%B8%BE%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          RequestVote 预选举请求处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%BC%8F%E9%80%89%E4%B8%BE"><span class="toc-number">1.2.</span> <span class="toc-text">
          正式选举</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leader-%E8%AE%A9%E6%9D%83"><span class="toc-number">2.</span> <span class="toc-text">
          Leader 让权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">
          总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">95</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2024</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>