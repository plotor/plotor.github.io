<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="与上一篇介绍的主节点选举一样，日志复制（Log Replication）同样是 Raft 算法的核心组成部分，是支撑 Raft 节点达成共识的基础。Raft 中的日志主要可以分为两类：一类是协议自身运行所生成的日志，例如集群节点配置变更信息；另外一类就是用户向集群提交的指令所生成的日志。为了让集群中的各个节点达成共识，Leader 节点需要将日志数据复制给集群中的各个节点，并采用投票机制让这些节点">
<meta property="og:type" content="article">
<meta property="og:title" content="SOFA-JRaft 源码解析：日志复制机制">
<meta property="og:url" content="https://plotor.github.io/2020/06/15/sofa/sofa-jraft-log-replication/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="与上一篇介绍的主节点选举一样，日志复制（Log Replication）同样是 Raft 算法的核心组成部分，是支撑 Raft 节点达成共识的基础。Raft 中的日志主要可以分为两类：一类是协议自身运行所生成的日志，例如集群节点配置变更信息；另外一类就是用户向集群提交的指令所生成的日志。为了让集群中的各个节点达成共识，Leader 节点需要将日志数据复制给集群中的各个节点，并采用投票机制让这些节点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://plotor.github.io/images/2020/jraft-log-replication-pipeline.png">
<meta property="article:published_time" content="2020-06-15T09:03:50.000Z">
<meta property="article:modified_time" content="2024-07-19T07:51:44.373Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="Raft">
<meta property="article:tag" content="SOFA-JRaft">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://plotor.github.io/images/2020/jraft-log-replication-pipeline.png"><title>SOFA-JRaft 源码解析：日志复制机制 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2020/06/15/sofa/sofa-jraft-log-replication/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">SOFA-JRaft 源码解析：日志复制机制</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-06-15</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">15.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">78分</span></span></div></header><div class="post-body"><p>与上一篇介绍的主节点选举一样，日志复制（Log Replication）同样是 Raft 算法的核心组成部分，是支撑 Raft 节点达成共识的基础。Raft 中的日志主要可以分为两类：一类是协议自身运行所生成的日志，例如集群节点配置变更信息；另外一类就是用户向集群提交的指令所生成的日志。为了让集群中的各个节点达成共识，Leader 节点需要将日志数据复制给集群中的各个节点，并采用投票机制让这些节点决定是否许可日志对应的操作。对于被许可的操作日志，各个节点会严格按照相同的顺序在本地进行存储，并重放日志对应的操作，以此实现节点之间的共识。</p>
<p>JRaft 在设计和实现层面为每个 Follower 和 Learner 节点都绑定了一个复制器 Replicator 实例，由 Replicator 负责向目标节点复制日志数据，Replicator 实例之间彼此相互隔离，互不影响，并由 ReplicatorGroup 进行统一管理。日志复制需要涉及到集群中节点之间的频繁通信和数据传输，所以需要保证复制操作的高性能，并且不允许出现乱序和断层。为此，JRaft 引入了多种优化策略，包括：Follower 节点之间并发复制、批量发送，以及 Pipeline 机制等。<a id="more"></a></p>
<p>日志复制从广义层面而言除了复制单条的 LogEntry 外，还包含向目标节点复制快照数据。本文我们重点关注对于 LogEntry 的复制，而对于快照数据的复制则留到下一篇介绍快照机制时再展开分析。</p>

        <h3 id="日志生成">
          <a href="#日志生成" class="heading-link"><i class="fas fa-link"></i></a>日志生成</h3>
      <p>在开始分析日志复制的运行机制之前，我打算先用一小节的篇幅介绍一下 JRaft 生成日志的过程。毕竟日志生成和复制是紧密关联的，了解 JRaft 如何生成一条日志有利于更好的理解后续复制日志的过程。前面曾介绍过，JRaft 中的日志主要可以分为两大类：一类是系统内部运行产生的日志；另外一类是用户主动往 JRaft 集群提交指令所产生的日志。本小节我们以后者为例，介绍 JRaft 日志从生成到写入本地存储系统的过程。</p>
<p>JRaft 提供了 <code>Node#apply</code> 交互接口以让业务向 JRaft 集群提交操作指令，这些指令以 Task 的形式在集群中流转，并以日志的形式记录到 Leader 节点中，同时同步给集群中所有的 Follower 节点，并最终透传给所有成功完成日志复制的集群节点状态机。</p>
<p>方法 <code>Node#apply</code> 的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Task task)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前节点被关闭</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownLatch != <span class="keyword">null</span>) {</span><br><span class="line">        Utils.runClosureInThread(task.getDone(), <span class="keyword">new</span> Status(RaftError.ENODESHUTDOWN, <span class="string">"Node is shutting down."</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Node is shutting down"</span>);</span><br><span class="line">    }</span><br><span class="line">    Requires.requireNonNull(task, <span class="string">"Null task"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 LogEntry 对象，用于封装 Task 中的数据</span></span><br><span class="line">    <span class="keyword">final</span> LogEntry entry = <span class="keyword">new</span> LogEntry();</span><br><span class="line">    entry.setData(task.getData());</span><br><span class="line">    <span class="keyword">int</span> retryTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 将 Task 及其对应的 LogEntry 对象以事件的形式投递给 Disruptor 队列</span></span><br><span class="line">        <span class="keyword">final</span> EventTranslator&lt;LogEntryAndClosure&gt; translator = (event, sequence) -&gt; {</span><br><span class="line">            event.reset();</span><br><span class="line">            event.done = task.getDone();</span><br><span class="line">            event.entry = entry;</span><br><span class="line">            event.expectedTerm = task.getExpectedTerm();</span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.applyQueue.tryPublishEvent(translator)) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 重试 3 次</span></span><br><span class="line">                retryTimes++;</span><br><span class="line">                <span class="keyword">if</span> (retryTimes &gt; MAX_APPLY_RETRY_TIMES) {</span><br><span class="line">                    Utils.runClosureInThread(task.getDone(),</span><br><span class="line">                            <span class="keyword">new</span> Status(RaftError.EBUSY, <span class="string">"Node is busy, has too many tasks."</span>));</span><br><span class="line">                    LOG.warn(<span class="string">"Node {} applyQueue is overload."</span>, getNodeId());</span><br><span class="line">                    <span class="keyword">this</span>.metrics.recordTimes(<span class="string">"apply-task-overload-times"</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                ThreadHelper.onSpinWait();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) {</span><br><span class="line">        LOG.error(<span class="string">"Fail to apply task."</span>, e);</span><br><span class="line">        Utils.runClosureInThread(task.getDone(), <span class="keyword">new</span> Status(RaftError.EPERM, <span class="string">"Node is down."</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现只是简单的将承载用户操作指令的 Task 封装成 LogEntry 对象，并以事件的形式投递给 Disruptor 队列进行异步处理，用户可以通过 Task 的 <code>Task#done</code> 字段感知任务被状态机处理的响应状态。LogEntryAndClosureHandler 实现了 EventHandler 接口，用于消费 Disruptor 队列中的事件，具体的处理逻辑由 <code>NodeImpl#executeApplyingTasks</code> 方法完成：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeApplyingTasks</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntryAndClosure&gt; tasks)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = tasks.size();</span><br><span class="line">        <span class="comment">// 只有 Leader 节点允许处理 Task</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_LEADER) {</span><br><span class="line">            <span class="keyword">final</span> Status st = <span class="keyword">new</span> Status();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_TRANSFERRING) {</span><br><span class="line">                st.setError(RaftError.EPERM, <span class="string">"Is not leader."</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                st.setError(RaftError.EBUSY, <span class="string">"Is transferring leadership."</span>);</span><br><span class="line">            }</span><br><span class="line">            LOG.debug(<span class="string">"Node {} can't apply, status={}."</span>, getNodeId(), st);</span><br><span class="line">            <span class="keyword">final</span> List&lt;LogEntryAndClosure&gt; savedTasks = <span class="keyword">new</span> ArrayList&lt;&gt;(tasks);</span><br><span class="line">            <span class="comment">// 快速失败</span></span><br><span class="line">            Utils.runInThread(() -&gt; {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                    savedTasks.get(i).done.run(st);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> List&lt;LogEntry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">        <span class="comment">// 遍历处理 Task 集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="keyword">final</span> LogEntryAndClosure task = tasks.get(i);</span><br><span class="line">            <span class="comment">// 如果 Task 期望校验 term 值，则校验当前节点的 term 值是否是期望的 term 值</span></span><br><span class="line">            <span class="keyword">if</span> (task.expectedTerm != -<span class="number">1</span> &amp;&amp; task.expectedTerm != <span class="keyword">this</span>.currTerm) {</span><br><span class="line">                LOG.debug(<span class="string">"Node {} can't apply task whose expectedTerm={} doesn't match currTerm={}."</span>,</span><br><span class="line">                        getNodeId(), task.expectedTerm, <span class="keyword">this</span>.currTerm);</span><br><span class="line">                <span class="keyword">if</span> (task.done != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">final</span> Status st = <span class="keyword">new</span> Status(RaftError.EPERM,</span><br><span class="line">                            <span class="string">"expected_term=%d doesn't match current_term=%d"</span>, task.expectedTerm, <span class="keyword">this</span>.currTerm);</span><br><span class="line">                    Utils.runClosureInThread(task.done, st);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 为每个 task 创建并初始化对应的选票，用于决策对应的 LogEntry 是否允许被提交</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.ballotBox.appendPendingTask(<span class="keyword">this</span>.conf.getConf(),</span><br><span class="line">                    <span class="keyword">this</span>.conf.isStable() ? <span class="keyword">null</span> : <span class="keyword">this</span>.conf.getOldConf(), task.done)) {</span><br><span class="line">                Utils.runClosureInThread(task.done, <span class="keyword">new</span> Status(RaftError.EINTERNAL, <span class="string">"Fail to append task."</span>));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// set task entry info before adding to list.</span></span><br><span class="line">            task.entry.getId().setTerm(<span class="keyword">this</span>.currTerm);</span><br><span class="line">            task.entry.setType(EnumOutter.EntryType.ENTRY_TYPE_DATA);</span><br><span class="line">            entries.add(task.entry);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 追加日志数据到本地文件系统，完成之后回调 LeaderStableClosure</span></span><br><span class="line">        <span class="keyword">this</span>.logManager.appendEntries(entries, <span class="keyword">new</span> LeaderStableClosure(entries));</span><br><span class="line">        <span class="comment">// update conf.first</span></span><br><span class="line">        checkAndSetConfiguration(<span class="keyword">true</span>);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于往 Raft 集群提交的指令只允许由 Leader 节点进行处理，这点无可厚非。上述实现会对 Task 进行简单的校验，主要是验证当前节点的 term 值是否是 Task 期望的 term 值，对于通过校验的 Task 则会为其创建并初始化对应的选票，并转化为 LogEntry 对象写入本地存储系统。因为每个 Task 最终都会被转换为对应的日志复制给集群中的所有节点，所以需要创建对应的选票，以实现当集群中的大部分节点都成功完成对该日志的复制操作之后，将对应的日志标记为 committed。创建并初始化选票的过程由 <code>BallotBox#appendPendingTask</code> 方法实现，后续我们会再次提及该方法，这里暂且跳过。</p>
<p>将日志数据写入本地存储系统的过程则由 <code>LogManager#appendEntries</code> 方法实现，该方法接收一个 LeaderStableClosure 类型的回调，当数据被处理完成之后会触发执行该回调。下面来看一下 <code>LogManager#appendEntries</code> 方法的执行流程，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendEntries</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries, <span class="keyword">final</span> StableClosure done)</span> </span>{</span><br><span class="line">    Requires.requireNonNull(done, <span class="string">"done"</span>);</span><br><span class="line">    <span class="comment">// 运行发生错误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasError) {</span><br><span class="line">        entries.clear();</span><br><span class="line">        Utils.runClosureInThread(done, <span class="keyword">new</span> Status(RaftError.EIO, <span class="string">"Corrupted LogStorage"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 对于 Leader 节点而言，基于本地 lastLogIndex 值设置各个 LogEntry 的 logIndex</span></span><br><span class="line">        <span class="comment">// 对于 Follower 节点而言，检查待复制的日志与本地已有的日志是否存在冲突，如果存在冲突则强行覆盖本地日志</span></span><br><span class="line">        <span class="keyword">if</span> (!entries.isEmpty() &amp;&amp; !checkAndResolveConflict(entries, done)) {</span><br><span class="line">            <span class="comment">// If checkAndResolveConflict returns false, the done will be called in it.</span></span><br><span class="line">            entries.clear();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entries.size(); i++) {</span><br><span class="line">            <span class="keyword">final</span> LogEntry entry = entries.get(i);</span><br><span class="line">            <span class="comment">// Set checksum after checkAndResolveConflict</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.raftOptions.isEnableLogEntryChecksum()) {</span><br><span class="line">                <span class="comment">// 设置 checksum 值</span></span><br><span class="line">                entry.setChecksum(entry.checksum());</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于 ENTRY_TYPE_CONFIGURATION 类型的 LogEntry，记录集群配置信息</span></span><br><span class="line">            <span class="keyword">if</span> (entry.getType() == EntryType.ENTRY_TYPE_CONFIGURATION) {</span><br><span class="line">                Configuration oldConf = <span class="keyword">new</span> Configuration();</span><br><span class="line">                <span class="keyword">if</span> (entry.getOldPeers() != <span class="keyword">null</span>) {</span><br><span class="line">                    oldConf = <span class="keyword">new</span> Configuration(entry.getOldPeers(), entry.getOldLearners());</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">final</span> ConfigurationEntry conf = <span class="keyword">new</span> ConfigurationEntry(entry.getId(),</span><br><span class="line">                        <span class="keyword">new</span> Configuration(entry.getPeers(), entry.getLearners()), oldConf);</span><br><span class="line">                <span class="keyword">this</span>.configManager.add(conf);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新内存数据</span></span><br><span class="line">        <span class="keyword">if</span> (!entries.isEmpty()) {</span><br><span class="line">            done.setFirstLogIndex(entries.get(<span class="number">0</span>).getId().getIndex());</span><br><span class="line">            <span class="keyword">this</span>.logsInMemory.addAll(entries);</span><br><span class="line">        }</span><br><span class="line">        done.setEntries(entries);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将修正后的 LogEntry 数据封装成事件投递给 Disruptor 队列，事件类型为 OTHER</span></span><br><span class="line">        <span class="keyword">int</span> retryTimes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> EventTranslator&lt;StableClosureEvent&gt; translator = (event, sequence) -&gt; {</span><br><span class="line">            event.reset();</span><br><span class="line">            event.type = EventType.OTHER;</span><br><span class="line">            event.done = done;</span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (tryOfferEvent(done, translator)) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                retryTimes++;</span><br><span class="line">                <span class="comment">// 最大重试 50 次</span></span><br><span class="line">                <span class="keyword">if</span> (retryTimes &gt; APPEND_LOG_RETRY_TIMES) {</span><br><span class="line">                    reportError(RaftError.EBUSY.getNumber(), <span class="string">"LogManager is busy, disk queue overload."</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                ThreadHelper.onSpinWait();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        doUnlock = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 尝试触发等待新的可复制数据的回调，以继续向目标 Follower 节点发送数据</span></span><br><span class="line">        <span class="keyword">if</span> (!wakeupAllWaiter(<span class="keyword">this</span>.writeLock)) {</span><br><span class="line">            notifyLastLogIndexListeners();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) {</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>往本地追加日志数据的操作除了会被 Leader 节点执行，也会被 Follower 或 Learner 节点所执行，所以上述方法会在各个节点上被调用。因为 Leader 节点的更替，这其中免不了会存在日志数据的冲突，而解决冲突的 <code>LogManagerImpl#checkAndResolveConflict</code> 方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAndResolveConflict</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries, <span class="keyword">final</span> StableClosure done)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> LogEntry firstLogEntry = ArrayDeque.peekFirst(entries);</span><br><span class="line">    <span class="comment">// Leader 节点，基于 lastLogIndex 设置 logIndex 值</span></span><br><span class="line">    <span class="keyword">if</span> (firstLogEntry.getId().getIndex() == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// Node is currently the leader and |entries| are from the user who</span></span><br><span class="line">        <span class="comment">// don't know the correct indexes the logs should assign to.</span></span><br><span class="line">        <span class="comment">// So we have to assign indexes to the appending entries</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entries.size(); i++) {</span><br><span class="line">            entries.get(i).getId().setIndex(++<span class="keyword">this</span>.lastLogIndex);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Follower 节点</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Node is currently a follower and |entries| are from the leader.</span></span><br><span class="line">        <span class="comment">// We should check and resolve the conflicts between the local logs and |entries|</span></span><br><span class="line">        <span class="keyword">if</span> (firstLogEntry.getId().getIndex() &gt; <span class="keyword">this</span>.lastLogIndex + <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 待写入的日志与本地已有的日志之间存在断层</span></span><br><span class="line">            Utils.runClosureInThread(done, <span class="keyword">new</span> Status(RaftError.EINVAL,</span><br><span class="line">                    <span class="string">"There's gap between first_index=%d and last_log_index=%d"</span>,</span><br><span class="line">                    firstLogEntry.getId().getIndex(), <span class="keyword">this</span>.lastLogIndex));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待写入的所有日志的 logIndex 都小于已经应用的日志的最大 logIndex，直接返回</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> appliedIndex = <span class="keyword">this</span>.appliedId.getIndex();</span><br><span class="line">        <span class="keyword">final</span> LogEntry lastLogEntry = ArrayDeque.peekLast(entries);</span><br><span class="line">        <span class="keyword">if</span> (lastLogEntry.getId().getIndex() &lt;= appliedIndex) {</span><br><span class="line">            LOG.warn(</span><br><span class="line">                    <span class="string">"Received entries of which the lastLog={} is not greater than appliedIndex={}, return immediately with nothing changed."</span>,</span><br><span class="line">                    lastLogEntry.getId().getIndex(), appliedIndex);</span><br><span class="line">            <span class="comment">// Replicate old logs before appliedIndex should be considered successfully, response OK.</span></span><br><span class="line">            Utils.runClosureInThread(done);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待追加的日志与本地已有的日志之前正好衔接上，直接更新 lastLogIndex</span></span><br><span class="line">        <span class="keyword">if</span> (firstLogEntry.getId().getIndex() == <span class="keyword">this</span>.lastLogIndex + <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// fast path</span></span><br><span class="line">            <span class="keyword">this</span>.lastLogIndex = lastLogEntry.getId().getIndex();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 说明待追加的日志与本地已有的日志之间存在交叉</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Appending entries overlap the local ones. We should find if there</span></span><br><span class="line">            <span class="comment">// is a conflicting index from which we should truncate the local ones.</span></span><br><span class="line">            <span class="keyword">int</span> conflictingIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 从头开始遍历寻找第一个 term 值不匹配的 logIndex</span></span><br><span class="line">            <span class="keyword">for</span> (; conflictingIndex &lt; entries.size(); conflictingIndex++) {</span><br><span class="line">                <span class="keyword">if</span> (unsafeGetTerm(entries.get(conflictingIndex).getId().getIndex())</span><br><span class="line">                        != entries.get(conflictingIndex).getId().getTerm()) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 日志数据存在冲突，将本地冲突之后的日志数据阶段</span></span><br><span class="line">            <span class="keyword">if</span> (conflictingIndex != entries.size()) {</span><br><span class="line">                <span class="keyword">if</span> (entries.get(conflictingIndex).getId().getIndex() &lt;= <span class="keyword">this</span>.lastLogIndex) {</span><br><span class="line">                    <span class="comment">// Truncate all the conflicting entries to make local logs consensus with the leader.</span></span><br><span class="line">                    unsafeTruncateSuffix(entries.get(conflictingIndex).getId().getIndex() - <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">this</span>.lastLogIndex = lastLogEntry.getId().getIndex();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// else this is a duplicated AppendEntriesRequest, we have nothing to do besides releasing all the entries</span></span><br><span class="line">            <span class="comment">// 将已经写入本地的日志数据从请求中剔除</span></span><br><span class="line">            <span class="keyword">if</span> (conflictingIndex &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// Remove duplication</span></span><br><span class="line">                entries.subList(<span class="number">0</span>, conflictingIndex).clear();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于 Leader 节点而言，因为 Raft 算法的强 Leader 设计，所以 Leader 的日志数据是整个集群日志数据的标杆，不存在冲突一说。因此，对于 Leader 节点而言，上述实现只是简单的为当前 LogEntry 对象修正对应的 logIndex 值，但是对于 Follower 和 Learner 节点而言则免不了出现日志数据冲突，分为以下几种情况：</p>
<ul>
<li>待写入的日志数据与本地已有的日志数据存在断层，此时只能返回错误。</li>
<li>待写入的日志数据相对于本地已有的日志数据更老，即最大的 logIndex 小于等于本地已经写入的日志数据的 logIndex，直接忽略。</li>
<li>待写入的日志数据与本地已有的日志数据正好衔接上，直接递增 lastLogIndex 即可。</li>
<li>待写入的日志数据与本地已有的日志数据存在重叠，此时需要判断是否存在冲突，并强行覆盖本地存在冲突的数据。</li>
</ul>
<p>完成对于冲突数据的处理，LogManager 会先将日志数据写入内存，并将日志数据以 <code>OTHER</code> 类型事件的形式提交给 Disruptor 队列，用于实现异步刷盘。方法 <code>LogManagerImpl#wakeupAllWaiter</code> 用于通知那些等待新数据到达的复制器 Replicator 实例，这些 Replicator 在向目标 Follower 或 Learner 节点复制日志数据时可能出现没有数据可以复制的情况，此时这些复制器 Replicator 会注册一个回调监听新的数据到来，而通知这些监听器的时机则位于此，关于这一部分的具体流程留到下一小节再展开介绍。</p>
<p>下面来看一下对于 Disruptor 队列中 <code>OTHER</code> 类型事件的处理过程，即异步刷盘的过程，由 StableClosureEventHandler 实现。StableClosureEventHandler 定义了一个 AppendBatcher 类型的字段，用于缓存待写入的数据。方法 <code>AppendBatcher#flush</code> 用于执行将缓存的数据写入存储系统，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LogId <span class="title">flush</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 将数据落盘，并返回最新的 LogId</span></span><br><span class="line">        <span class="keyword">this</span>.lastId = appendToStorage(<span class="keyword">this</span>.toAppend);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) {</span><br><span class="line">            <span class="comment">// 清空缓存的 LogEntry 数据</span></span><br><span class="line">            <span class="keyword">this</span>.storage.get(i).getEntries().clear();</span><br><span class="line">            Status st = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (LogManagerImpl.<span class="keyword">this</span>.hasError) {</span><br><span class="line">                    <span class="comment">// LogManager 运行异常</span></span><br><span class="line">                    st = <span class="keyword">new</span> Status(RaftError.EIO, <span class="string">"Corrupted LogStorage"</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    st = Status.OK();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 应用回调</span></span><br><span class="line">                <span class="keyword">this</span>.storage.get(i).run(st);</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">                LOG.error(<span class="string">"Fail to run closure with status: {}."</span>, st, t);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.toAppend.clear();</span><br><span class="line">        <span class="keyword">this</span>.storage.clear();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.bufferSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.lastId;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>具体执行过程如上述代码注释，其中方法 <code>LogManagerImpl#appendToStorage</code> 实现了将数据写入存储系统的逻辑，默认也就是写入 RocksDB 存储引擎，实现比较直观，不再展开。</p>
<p>在完成对一个批次日志数据的处理之后，下面来看一下针对回调 LeaderStableClosure 的处理逻辑，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (status.isOk()) {</span><br><span class="line">        NodeImpl.<span class="keyword">this</span>.ballotBox.commitAt(</span><br><span class="line">                <span class="keyword">this</span>.firstLogIndex, <span class="keyword">this</span>.firstLogIndex + <span class="keyword">this</span>.nEntries - <span class="number">1</span>, NodeImpl.<span class="keyword">this</span>.serverId);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        LOG.error(<span class="string">"Node {} append [{}, {}] failed, status={}."</span>,</span><br><span class="line">                getNodeId(), <span class="keyword">this</span>.firstLogIndex, <span class="keyword">this</span>.firstLogIndex + <span class="keyword">this</span>.nEntries - <span class="number">1</span>, status);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果响应状态是 OK，则上述回调会执行 <code>BallotBox#commitAt</code> 方法检查该批次中的日志数据是否被过半数的节点所成功复制，如果存在复制成功的日志数据，则递增 lastCommittedIndex 值，并向状态机发布 <code>COMMITTED</code> 事件。方法 <code>BallotBox#commitAt</code> 实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commitAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> firstLogIndex, <span class="keyword">final</span> <span class="keyword">long</span> lastLogIndex, <span class="keyword">final</span> PeerId peer)</span> </span>{</span><br><span class="line">    <span class="comment">// TODO  use lock-free algorithm here?</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> stamp = <span class="keyword">this</span>.stampedLock.writeLock();</span><br><span class="line">    <span class="keyword">long</span> lastCommittedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pendingIndex == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (lastLogIndex &lt; <span class="keyword">this</span>.pendingIndex) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastLogIndex &gt;= <span class="keyword">this</span>.pendingIndex + <span class="keyword">this</span>.pendingMetaQueue.size()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startAt = Math.max(<span class="keyword">this</span>.pendingIndex, firstLogIndex);</span><br><span class="line">        Ballot.PosHint hint = <span class="keyword">new</span> Ballot.PosHint();</span><br><span class="line">        <span class="comment">// 遍历检查当前批次中的 LogEntry 是否有成功被过半数节点复制的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> logIndex = startAt; logIndex &lt;= lastLogIndex; logIndex++) {</span><br><span class="line">            <span class="keyword">final</span> Ballot bl = <span class="keyword">this</span>.pendingMetaQueue.get((<span class="keyword">int</span>) (logIndex - <span class="keyword">this</span>.pendingIndex));</span><br><span class="line">            hint = bl.grant(peer, hint);</span><br><span class="line">            <span class="comment">// 当前 LogEntry 被过半数节点成功复制，记录 lastCommittedIndex</span></span><br><span class="line">            <span class="keyword">if</span> (bl.isGranted()) {</span><br><span class="line">                lastCommittedIndex = logIndex;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 没有一条日志被过半数节点所成功复制，先返回</span></span><br><span class="line">        <span class="keyword">if</span> (lastCommittedIndex == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// When removing a peer off the raft group which contains even number of peers,</span></span><br><span class="line">        <span class="comment">// the quorum would decrease by 1, e.g. 3 of 4 changes to 2 of 3. In this case,</span></span><br><span class="line">        <span class="comment">// the log after removal may be committed before some previous logs,</span></span><br><span class="line">        <span class="comment">// since we use the new configuration to deal the quorum of the removal request,</span></span><br><span class="line">        <span class="comment">// we think it's safe to commit all the uncommitted previous logs, which is not well proved right now</span></span><br><span class="line">        <span class="comment">// 剔除已经被过半数节点复制的 LogIndex 对应的选票，</span></span><br><span class="line">        <span class="comment">// Raft 保证一个 LogEntry 被提交之后，在此之前的 LogEntry 一定是 committed 状态</span></span><br><span class="line">        <span class="keyword">this</span>.pendingMetaQueue.removeFromFirst((<span class="keyword">int</span>) (lastCommittedIndex - <span class="keyword">this</span>.pendingIndex) + <span class="number">1</span>);</span><br><span class="line">        LOG.debug(<span class="string">"Committed log fromIndex={}, toIndex={}."</span>, <span class="keyword">this</span>.pendingIndex, lastCommittedIndex);</span><br><span class="line">        <span class="keyword">this</span>.pendingIndex = lastCommittedIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 更新集群的 lastCommittedIndex 值</span></span><br><span class="line">        <span class="keyword">this</span>.lastCommittedIndex = lastCommittedIndex;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.stampedLock.unlockWrite(stamp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向状态机发布 COMMITTED 事件</span></span><br><span class="line">    <span class="keyword">this</span>.waiter.onCommitted(lastCommittedIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>可能读者会疑惑这里只有 Leader 节点执行了写入日志操作，当前日志怎么可能会被 granted 呢？读者需要明白的一点是，Leader 节点在将数据写入内存之后，即通知对应的复制器 Replicator 开始往目标 Follower 节点复制数据（Replicator 优先从内存中读取待复制的日志数据）。到日志数据在 Leader 节点被落盘之后回调上述 <code>BallotBox#commitAt</code> 方法这中间是有一个时间差的，所以此时 Leader 节点执行 <code>BallotBox#commitAt</code> 操作有可能对应的日志数据已被过半数节点所复制。此外，方法 <code>BallotBox#commitAt</code> 除了会被 Leader 节点调用，也会在 Follower 节点完成日志数据复制的 AppendEntries 请求响应处理期间被调用，此时也会触发检查 granted 操作，具体在下一小节介绍日志复制机制时会展开说明。</p>
<p>关于日志生成的过程到这里也就基本介绍完了，本小节的最后我们来看一下 <code>FSMCaller#onCommitted</code> 方法到底做了哪些事情。该方法接收一个 committedIndex 参数，在 LogEntry 被提交时触发，会向对应的 Disruptor 队列中发布一个 <code>COMMITTED</code> 类型的事件，关于该事件的处理由 <code>FSMCallerImpl#doCommitted</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommitted</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> committedIndex)</span> </span>{</span><br><span class="line">    <span class="comment">// 状态机调度器运行异常</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.error.getStatus().isOk()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取最新被状态机应用的 LogEntry 对应的 logIndex 值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lastAppliedIndex = <span class="keyword">this</span>.lastAppliedIndex.get();</span><br><span class="line">    <span class="comment">// We can tolerate the disorder of committed_index</span></span><br><span class="line">    <span class="keyword">if</span> (lastAppliedIndex &gt;= committedIndex) {</span><br><span class="line">        <span class="comment">// 当前 committedIndex 对应的 LogEntry 已经被处理过，无需重复处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">final</span> List&lt;Closure&gt; closures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> List&lt;TaskClosure&gt; taskClosures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取 committedIndex 之前的 Task 的回调列表，填充到 closures 集合中，</span></span><br><span class="line">        <span class="comment">// 如果是 TaskClosure 类型，则顺便记录到 taskClosures 中，主要是为了回调 TaskClosure#onCommitted 方法</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> firstClosureIndex = <span class="keyword">this</span>.closureQueue.popClosureUntil(committedIndex, closures, taskClosures);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于 TaskClosure 类型的 Task 回调，应用 TaskClosure#onCommitted 方法</span></span><br><span class="line">        onTaskCommitted(taskClosures);</span><br><span class="line"></span><br><span class="line">        Requires.requireTrue(firstClosureIndex &gt;= <span class="number">0</span>, <span class="string">"Invalid firstClosureIndex"</span>);</span><br><span class="line">        <span class="comment">// 迭代器，用于迭代 LogEntry</span></span><br><span class="line">        <span class="keyword">final</span> IteratorImpl iterImpl = <span class="keyword">new</span> IteratorImpl(</span><br><span class="line">                <span class="keyword">this</span>.fsm, <span class="keyword">this</span>.logManager, closures, firstClosureIndex, lastAppliedIndex, committedIndex, <span class="keyword">this</span>.applyingIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是 good，则说明还有可以继续处理的日志</span></span><br><span class="line">        <span class="keyword">while</span> (iterImpl.isGood()) {</span><br><span class="line">            <span class="comment">// 获取当前待处理的 LogEntry 对象</span></span><br><span class="line">            <span class="keyword">final</span> LogEntry logEntry = iterImpl.entry();</span><br><span class="line">            <span class="comment">// 系统内部的 LogEntry 对象</span></span><br><span class="line">            <span class="keyword">if</span> (logEntry.getType() != EnumOutter.EntryType.ENTRY_TYPE_DATA) {</span><br><span class="line">                <span class="keyword">if</span> (logEntry.getType() == EnumOutter.EntryType.ENTRY_TYPE_CONFIGURATION) {</span><br><span class="line">                    <span class="keyword">if</span> (logEntry.getOldPeers() != <span class="keyword">null</span> &amp;&amp; !logEntry.getOldPeers().isEmpty()) {</span><br><span class="line">                        <span class="comment">// Joint stage is not supposed to be noticeable by end users.</span></span><br><span class="line">                        <span class="keyword">this</span>.fsm.onConfigurationCommitted(<span class="keyword">new</span> Configuration(iterImpl.entry().getPeers()));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (iterImpl.done() != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// For other entries, we have nothing to do besides flush the</span></span><br><span class="line">                    <span class="comment">// pending tasks and run this closure to notify the caller that the</span></span><br><span class="line">                    <span class="comment">// entries before this one were successfully committed and applied.</span></span><br><span class="line">                    iterImpl.done().run(Status.OK());</span><br><span class="line">                }</span><br><span class="line">                iterImpl.next();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连续处理一批业务操作产生的日志，应用 StateMachine#onApply 方法</span></span><br><span class="line">            doApplyTasks(iterImpl);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发生错误，将错误透传给业务和当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (iterImpl.hasError()) {</span><br><span class="line">            setError(iterImpl.getError());</span><br><span class="line">            iterImpl.runTheRestClosureWithError();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> lastIndex = iterImpl.getIndex() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> lastTerm = <span class="keyword">this</span>.logManager.getTerm(lastIndex);</span><br><span class="line">        <span class="keyword">final</span> LogId lastAppliedId = <span class="keyword">new</span> LogId(lastIndex, lastTerm);</span><br><span class="line">        <span class="comment">// 更新最新应用的日志对应的 logIndex 和 term 值</span></span><br><span class="line">        <span class="keyword">this</span>.lastAppliedIndex.set(lastIndex);</span><br><span class="line">        <span class="keyword">this</span>.lastAppliedTerm = lastTerm;</span><br><span class="line">        <span class="comment">// 通知 LogManager，这些已经被应用的 LogEntry 可以从内存中移除了</span></span><br><span class="line">        <span class="keyword">this</span>.logManager.setAppliedId(lastAppliedId);</span><br><span class="line">        notifyLastAppliedIndexUpdated(lastIndex);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.nodeMetrics.recordLatency(<span class="string">"fsm-commit"</span>, Utils.monotonicMs() - startMs);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>业务向 JRaft 集群提交的 Task 在被转换成日志并成功复制给集群中的过半数以上节点（即对应的日志被提交）之后，接下去就需要将这些日志中存储的指令透传给业务状态机，相应的实现由上述方法完成。</p>
<p>FSMCaller 本地维护了一个 lastAppliedIndex 字段，用于记录已经被应用（即已将日志中的指令透传给业务状态机）的 LogEntry 对应的 logIndex 值。因为 Raft 算法能够保证某个 committedIndex 之前的所有 LogEntry 都是被提交的，所以即使 committedIndex 的到达顺序出现乱序也不会影响正常的运行逻辑。</p>
<p>我们在调用 <code>Node#apply</code> 方法向 JRaft 集群提交 Task 时，一般都会给 Task 设置一个回调，即给 <code>Task#done</code> 字段赋值。所以，FSMCaller 对于给定的 committedIndex，首先会调用 <code>ClosureQueueImpl#popClosureUntil</code> 方法获取到这些已经被提交的 LogEntry 对应的 Task 的回调。这些回调最终会透传给业务状态机，由业务决定是响应成功还是失败。那么这些回调是什么时候被记录的呢？</p>
<p>还记得我们在介绍 JRaft 节点初始化过程时曾提及过 FSMCaller 和 BallotBox 所持有的 ClosureQueue 实例是同一个吗？这些 Task 回调正是在前面调用 <code>BallotBox#appendPendingTask</code> 方法时记录的，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">appendPendingTask</span><span class="params">(<span class="keyword">final</span> Configuration conf, <span class="keyword">final</span> Configuration oldConf, <span class="keyword">final</span> Closure done)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建并初始化选票</span></span><br><span class="line">    <span class="keyword">final</span> Ballot bl = <span class="keyword">new</span> Ballot();</span><br><span class="line">    <span class="keyword">if</span> (!bl.init(conf, oldConf)) {</span><br><span class="line">        LOG.error(<span class="string">"Fail to init ballot."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> stamp = <span class="keyword">this</span>.stampedLock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 节点成功 Leader 之后必须调用 BallotBox#resetPendingIndex 方法重置 pendingIndex 值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pendingIndex &lt;= <span class="number">0</span>) {</span><br><span class="line">            LOG.error(<span class="string">"Fail to appendingTask, pendingIndex={}."</span>, <span class="keyword">this</span>.pendingIndex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 记录选票，用于检查是否赢得过半数选票</span></span><br><span class="line">        <span class="keyword">this</span>.pendingMetaQueue.add(bl);</span><br><span class="line">        <span class="comment">// 记录 Task 的回调 done 对象，当对应的日志被 committed 时触发执行</span></span><br><span class="line">        <span class="keyword">this</span>.closureQueue.appendPendingClosure(done);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.stampedLock.unlockWrite(stamp);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>接下来，FSMCaller 采用了迭代器模式将需要处理的日志封装成迭代器对象，并对于业务操作产生的日志调用 <code>FSMCallerImpl#doApplyTasks</code> 方法将一批连续的 <code>ENTRY_TYPE_DATA</code> 类型日志透传给状态机：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doApplyTasks</span><span class="params">(<span class="keyword">final</span> IteratorImpl iterImpl)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> IteratorWrapper iter = <span class="keyword">new</span> IteratorWrapper(iterImpl);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startApplyMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startIndex = iter.getIndex();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 应用 StateMachine#onApply 方法</span></span><br><span class="line">        <span class="keyword">this</span>.fsm.onApply(iter);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.nodeMetrics.recordLatency(<span class="string">"fsm-apply-tasks"</span>, Utils.monotonicMs() - startApplyMs);</span><br><span class="line">        <span class="keyword">this</span>.nodeMetrics.recordSize(<span class="string">"fsm-apply-tasks-count"</span>, iter.getIndex() - startIndex);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 迭代器中的日志还没有被处理完，但是业务已经退出了 onApply 方法</span></span><br><span class="line">    <span class="keyword">if</span> (iter.hasNext()) {</span><br><span class="line">        LOG.error(<span class="string">"Iterator is still valid, did you return before iterator reached the end?"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Try move to next in case that we pass the same log twice.</span></span><br><span class="line">    iter.next();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>而状态机 StateMachine 的核心方法 <code>StateMachine#onApply</code> 也正是在此处被调用。</p>

        <h3 id="日志复制">
          <a href="#日志复制" class="heading-link"><i class="fas fa-link"></i></a>日志复制</h3>
      <p>上一小节我们以业务操作日志为例，从 Leader 节点视角分析了 JRaft 是如何产生和处理一条日志的。在将用户操作指令封装成 LogEntry 写入内存之后，日志复制的进程即开始了，与此同时，Leader 节点会以异步的方式将数据落盘。日志复制仍然采用投票机制，当一条日志被集群中过半数以上的节点成功复制之后，这条日志会被打上 committed 标签。此类日志中承载的操作指令最后会被透传给状态机，由业务负责执行。</p>
<p>本小节侧重于分析 Leader 节点将日志数据复制给集群中的 Follower 节点的运行机制。Leader 节点针对每个 Follower 节点都会在本地为其创建并启动一个复制器 Replicator 实例，而日志复制的过程则全权由 Replicator 负责，各 Replicator 之间相互独立，彼此互不影响。</p>
<p>JRaft 还设计了 ReplicatorGroup 类，由名称我们可以推断出该类用于实现对于同一个 group 下的所有 Replicator 实例进行管理，例如启停到目标 Follower 或 Learner 节点的 Replicator 实例、检查到目标 Follower 或 Learner 节点的复制关系，以及主动向目标节点发送心跳请求等。</p>

        <h4 id="Pipeline-机制">
          <a href="#Pipeline-机制" class="heading-link"><i class="fas fa-link"></i></a>Pipeline 机制</h4>
      <p>Leader 节点将日志数据复制给 Follower 节点的过程必须保证日志数据的顺序性和连续性，这一点是毋庸置疑的。为了达到此目的，最简单的交互模式就是“request -&gt; response -&gt; request”，即每次发送出去一个请求之后必须等待接收并处理完对应的响应之后再发送下一个请求，从交互上保证日志复制的严格串行化。这一设计的优点在于实现简单，但是性能上却不尽如人意。</p>
<p>日志数据复制在 Raft 算法的运行过程中是一项频繁的操作，为了在保证日志复制顺序和连续的前提下尽量提升复制的性能，除了并发的向各个 Follower 或 Learner 节点批量发送数据之外，JRaft 在实现上还引入了 pipeline 机制。这一机制简单而言就是将请求和响应从串行改为并行，请求和响应彼此之间互不阻塞。Leader 节点可以连续的向 Follower 节点发送请求，对于那些已经发送出去还未收到响应的请求，或者已经收到但是还没来得及处理的响应对应的请求将其标记为 inflight，并在成功处理完对应的响应之后去除请求的 inflight 标记。如果期间发生错误或者 Leader 节点宕机，对于这些 inflight 请求会尝试重新发送，以此保证日志数据在复制期间不会漏传给 Follower 节点。Pipeline 机制与 TCP 协议中的滑动窗口算法思想相通，是分布式系统中提升吞吐量的惯用策略，例如 Kafka 生产者在往服务端发送消息时同样采用了类似的机制。</p>
<p>然而，我们也看到这一机制可能会导致同一个 LogEntry 被多次复制给 Follower 节点，好在 Raft 算法要求日志中的指令必须是幂等的，同时 Raft 算法针对日志数据的冲突解决机制能够保证重复复制的 LogEntry 能够被最后一次复制的 LogEntry 所覆盖。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2020/jraft-log-replication-pipeline.png" alt="image">
      </p>
<p>上图描绘了 JRaft Pipeline 机制的设计，其中 inflight request queue 中的青色实心圆点表示已经发送出去还未接收到响应的请求（即 inflight 请求），而 pending response queue 中的黄色实心圆点表示已经收到的响应，黄色空心圆点表示还未收到的响应。对于响应而言，由于网络原因到达顺序不一定与请求顺序相吻合，JRaft 对于提前到达的响应会先将其缓存起来，并按照请求的顺序对响应按顺序进行处理。如果因为等待的某个响应迟迟不能到达导致 inflight 请求越积越多，或者某个响应异常，则 Leader 节点会清空 inflight request queue 中的请求，并重新发送这些请求。这一机制能够实现将发送请求和处理响应并行化，并且由于 Raft 算法要求日志承载的指令必须是幂等的，所以重试策略不会破坏数据的最终状态。</p>
<p>下面来看一下 JRaft 对于 pipeline 机制的实现。首先来了解几个相关的字段定义，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 记录最近的 inflight RPC 请求 */</span></span><br><span class="line"><span class="keyword">private</span> Inflight rpcInFly;</span><br><span class="line"><span class="comment">/** FIFO 队列，记录 inflight RPC 请求列表 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;Inflight&gt; inflights = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="comment">/** 请求序列 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> reqSeq = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** 期望的响应序列 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> requiredNextSeq = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** 状态版本，当重置 inflight 请求队列时会递增，以实现忽略版本不匹配的 inflight 请求响应 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> version = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录已经收到但是还没有被处理的响应，按照请求序列从小到大排序，</span></span><br><span class="line"><span class="comment"> * 响应的顺序是未知的，但是需要保证处理的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;RpcResponse&gt; pendingResponses = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">50</span>);</span><br></pre></td></tr></tbody></table></div></figure>
<p>各字段的作用如代码注释，其中 Inflight 类用于描述一个 inflight 请求，定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inflight</span> </span>{</span><br><span class="line">    <span class="comment">/** 请求中的 LogEntry 数目 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">/** 请求对应的起始 nextIndex 值 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startIndex;</span><br><span class="line">    <span class="comment">/** LogEntry 的总字节长度 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">/** RPC future */</span></span><br><span class="line">    <span class="keyword">final</span> Future&lt;Message&gt; rpcFuture;</span><br><span class="line">    <span class="comment">/** 请求类型：复制日志 or 安装快照 */</span></span><br><span class="line">    <span class="keyword">final</span> RequestType requestType;</span><br><span class="line">    <span class="comment">/** 请求序列，用于匹配请求和响应，保证按照请求的顺序处理响应 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> seq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略构造函数和 toString 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSendingLogEntries</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.requestType == RequestType.AppendEntries &amp;&amp; <span class="keyword">this</span>.count &gt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Replicator 在成功发送一个 RPC 请求之后会调用 <code>Replicator#addInflight</code> 方法将请求相关的信息封装成 Inflight 对象记录到 inflight 队列中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addInflight</span><span class="params">(<span class="keyword">final</span> RequestType reqType,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> <span class="keyword">long</span> startIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> Future&lt;Message&gt; rpcInfly)</span> </span>{</span><br><span class="line">    <span class="comment">// 更新本地记录的最近一次发送的 inflight RPC 请求</span></span><br><span class="line">    <span class="keyword">this</span>.rpcInFly = <span class="keyword">new</span> Inflight(reqType, startIndex, count, size, seq, rpcInfly);</span><br><span class="line">    <span class="comment">// 标记当前请求为 inflight</span></span><br><span class="line">    <span class="keyword">this</span>.inflights.add(<span class="keyword">this</span>.rpcInFly);</span><br><span class="line">    <span class="keyword">this</span>.nodeMetrics.recordSize(<span class="string">"replicate-inflights-count"</span>, <span class="keyword">this</span>.inflights.size());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>当接收到请求对应的响应时，Replicator 会执行 <code>Replicator#onRpcReturned</code> 方法处理响应，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onRpcReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> RequestType reqType,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> Status status,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> Message request,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> Message response,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> <span class="keyword">int</span> stateVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = Utils.nowMs();</span><br><span class="line">    Replicator r;</span><br><span class="line">    <span class="comment">// 获取当前 Replicator 对应的不可重入锁</span></span><br><span class="line">    <span class="keyword">if</span> ((r = (Replicator) id.lock()) == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态版本发生变化，说明 inflight 队列被重置过，忽略重置之前请求对应的响应</span></span><br><span class="line">    <span class="keyword">if</span> (stateVersion != r.version) {</span><br><span class="line">        LOG.debug(<span class="string">"Replicator {} ignored old version response {}, current version is {}, request is {}\n, and response is {}\n, status is {}."</span>,</span><br><span class="line">                r, stateVersion, r.version, request, response, status);</span><br><span class="line">        id.unlock();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取等待处理的响应优先级队列，按照请求序列从小到大排序</span></span><br><span class="line">    <span class="keyword">final</span> PriorityQueue&lt;RpcResponse&gt; holdingQueue = r.pendingResponses;</span><br><span class="line">    holdingQueue.add(<span class="keyword">new</span> RpcResponse(reqType, seq, status, request, response, rpcSendTime));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 太多等待处理的响应（默认为 256 个），而期望请求序列对应的响应迟迟不来，重置请求 inflight 队列，重新发送探针请求</span></span><br><span class="line">    <span class="keyword">if</span> (holdingQueue.size() &gt; r.raftOptions.getMaxReplicatorInflightMsgs()) {</span><br><span class="line">        LOG.warn(<span class="string">"Too many pending responses {} for replicator {}, maxReplicatorInflightMsgs={}"</span>,</span><br><span class="line">                holdingQueue.size(), r.options.getPeerId(), r.raftOptions.getMaxReplicatorInflightMsgs());</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标识是否继续发送 AppendEntries 请求</span></span><br><span class="line">    <span class="keyword">boolean</span> continueSendEntries = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isLogDebugEnabled = LOG.isDebugEnabled();</span><br><span class="line">    StringBuilder sb = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLogDebugEnabled) {</span><br><span class="line">        sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Replicator "</span>).append(r).append(<span class="string">" is processing RPC responses, "</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 记录已经处理的响应数</span></span><br><span class="line">        <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历处理响应</span></span><br><span class="line">        <span class="keyword">while</span> (!holdingQueue.isEmpty()) {</span><br><span class="line">            <span class="comment">// 获取收到的请求序列最小的响应</span></span><br><span class="line">            <span class="keyword">final</span> RpcResponse queuedPipelinedResponse = holdingQueue.peek();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sequence mismatch, waiting for next response.</span></span><br><span class="line">            <span class="comment">// 响应乱序，继续等待期望序列的响应</span></span><br><span class="line">            <span class="keyword">if</span> (queuedPipelinedResponse.seq != r.requiredNextSeq) {</span><br><span class="line">                <span class="keyword">if</span> (processed &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (isLogDebugEnabled) {</span><br><span class="line">                        sb.append(<span class="string">"has processed "</span>).append(processed).append(<span class="string">" responses, "</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// Do not processed any responses, UNLOCK id and return.</span></span><br><span class="line">                    continueSendEntries = <span class="keyword">false</span>;</span><br><span class="line">                    id.unlock();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 开始处理请求对应的响应 */</span></span><br><span class="line"></span><br><span class="line">            holdingQueue.remove();</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="comment">// 获取 inflight 请求</span></span><br><span class="line">            <span class="keyword">final</span> Inflight inflight = r.pollInflight();</span><br><span class="line">            <span class="keyword">if</span> (inflight == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 响应对应的请求已经被清除，忽略当前响应</span></span><br><span class="line">                <span class="keyword">if</span> (isLogDebugEnabled) {</span><br><span class="line">                    sb.append(<span class="string">"ignore response because request not found: "</span>).append(queuedPipelinedResponse).append(<span class="string">",\n"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 请求序列与响应中记录的请求序列匹配不上，重置请求 inflight 队列，阻塞一会后重新发送探针请求</span></span><br><span class="line">            <span class="keyword">if</span> (inflight.seq != queuedPipelinedResponse.seq) {</span><br><span class="line">                <span class="comment">// reset state</span></span><br><span class="line">                LOG.warn(<span class="string">"Replicator {} response sequence out of order, expect {}, but it is {}, reset state to try again."</span>,</span><br><span class="line">                        r, inflight.seq, queuedPipelinedResponse.seq);</span><br><span class="line">                r.resetInflights();</span><br><span class="line">                r.state = State.Probe;</span><br><span class="line">                continueSendEntries = <span class="keyword">false</span>;</span><br><span class="line">                r.block(Utils.nowMs(), RaftError.EREQUEST.getNumber());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 依据响应类型分别处理</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">switch</span> (queuedPipelinedResponse.requestType) {</span><br><span class="line">                    <span class="comment">// 处理 AppendEntries 请求</span></span><br><span class="line">                    <span class="keyword">case</span> AppendEntries:</span><br><span class="line">                        continueSendEntries = onAppendEntriesReturned(</span><br><span class="line">                                id,</span><br><span class="line">                                inflight,</span><br><span class="line">                                queuedPipelinedResponse.status,</span><br><span class="line">                                (AppendEntriesRequest) queuedPipelinedResponse.request,</span><br><span class="line">                                (AppendEntriesResponse) queuedPipelinedResponse.response,</span><br><span class="line">                                rpcSendTime,</span><br><span class="line">                                startTimeMs,</span><br><span class="line">                                r);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 处理 InstallSnapshot 请求</span></span><br><span class="line">                    <span class="keyword">case</span> Snapshot:</span><br><span class="line">                        continueSendEntries = onInstallSnapshotReturned(</span><br><span class="line">                                id,</span><br><span class="line">                                r,</span><br><span class="line">                                queuedPipelinedResponse.status,</span><br><span class="line">                                (InstallSnapshotRequest) queuedPipelinedResponse.request,</span><br><span class="line">                                (InstallSnapshotResponse) queuedPipelinedResponse.response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">if</span> (continueSendEntries) {</span><br><span class="line">                    <span class="comment">// Success, increase the response sequence.</span></span><br><span class="line">                    r.getAndIncrementRequiredNextSeq();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// The id is already unlocked in onAppendEntriesReturned/onInstallSnapshotReturned, we SHOULD break out.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (isLogDebugEnabled) {</span><br><span class="line">            sb.append(<span class="string">"after processed, continue to send entries: "</span>).append(continueSendEntries);</span><br><span class="line">            LOG.debug(sb.toString());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 继续发送 AppendEntries 请求</span></span><br><span class="line">        <span class="keyword">if</span> (continueSendEntries) {</span><br><span class="line">            <span class="comment">// unlock in sendEntries.</span></span><br><span class="line">            r.sendEntries();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由上述实现我们可以总结 pipeline 机制在处理响应时需要考虑以下几点：</p>
<ul>
<li>因为 inflight 请求本质上是一种未完成的请求，有重试的可能，所以当重新发送请求时，之前请求对应的响应即使收到了也应该被忽略。</li>
<li>响应的顺序是未知的，但是需要保证处理的顺序，所以对于提前收到的响应需要先缓存起来，必须按照请求发送的顺序而非响应到达的顺序进行处理。</li>
<li>需要保证请求序列和响应序列相匹配。</li>
</ul>
<p>针对上述中的第一点，JRaft 在实现上通过版本策略予以实现。Replicator 定义了一个 <code>Replicator#version</code> 字段，用于标识当前 inflight 队列的版本。当重置 inflight 队列时会自增该版本号，并清空 inflight 队列和响应队列等。Replicator 执行此操作的目的在于丢弃那些 inflight 请求以重新发送，但是这些已经发送出去的 inflight 请求对应的响应可能正在赶来的路上，当节点收到这些响应时需要予以忽略，而忽略的依据就是版本不匹配。</p>

        <h4 id="发送探针">
          <a href="#发送探针" class="heading-link"><i class="fas fa-link"></i></a>发送探针</h4>
      <p>完成了对于 Pipeline 机制的介绍，下面开始分析 JRaft 复制日志数据的过程。上一篇曾介绍过，当一个节点竞选 Leader 成功之后会调用 <code>ReplicatorGroup#addReplicator</code> 方法建立到各个 Follower 节点之间的复制关系，本文我们将从这里切入分析 JRaft 的日志复制机制。</p>
<p>方法 <code>ReplicatorGroup#addReplicator</code> 接收两个参数，用于指定目标 Follower 或 Learner 节点，以及节点类型，具体实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addReplicator</span><span class="params">(<span class="keyword">final</span> PeerId peer, // 目标 Follower 或 Learner 节点</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> ReplicatorType replicatorType // 节点类型</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>{</span><br><span class="line">    <span class="comment">// 在此之前应该先调用 ReplicatorGroup#resetTerm 方法</span></span><br><span class="line">    Requires.requireTrue(<span class="keyword">this</span>.commonOptions.getTerm() != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.failureReplicators.remove(peer);</span><br><span class="line">    <span class="comment">// 已建立复制关系，避免重复</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.replicatorMap.containsKey(peer)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> ReplicatorOptions opts = <span class="keyword">this</span>.commonOptions == <span class="keyword">null</span> ? <span class="keyword">new</span> ReplicatorOptions() : <span class="keyword">this</span>.commonOptions.copy();</span><br><span class="line">    opts.setReplicatorType(replicatorType);</span><br><span class="line">    opts.setPeerId(peer);</span><br><span class="line">    <span class="comment">// 创建并启动到目标节点的复制器</span></span><br><span class="line">    <span class="keyword">final</span> ThreadId rid = Replicator.start(opts, <span class="keyword">this</span>.raftOptions);</span><br><span class="line">    <span class="keyword">if</span> (rid == <span class="keyword">null</span>) {</span><br><span class="line">        LOG.error(<span class="string">"Fail to start replicator to peer={}, replicatorType={}."</span>, peer, replicatorType);</span><br><span class="line">        <span class="keyword">this</span>.failureReplicators.put(peer, replicatorType);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replicatorMap.put(peer, rid) == <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现的核心在于调用 <code>Replicator#start</code> 方法创建并启动到目标节点的复制器 Replicator 实例。该方法返回一个 ThreadId 对象，用于为对应的 Replicator 对象提供不可重入锁支持，其中不可重入锁基于 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://www.zhenchao.org/2018/08/24/java/juc-aqs/">AQS</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 实现。</p>
<p>方法 <code>Replicator#start</code> 实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadId <span class="title">start</span><span class="params">(<span class="keyword">final</span> ReplicatorOptions opts, <span class="keyword">final</span> RaftOptions raftOptions)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (opts.getLogManager() == <span class="keyword">null</span> || opts.getBallotBox() == <span class="keyword">null</span> || opts.getNode() == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid ReplicatorOptions."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建复制器 Replicator 对象</span></span><br><span class="line">    <span class="keyword">final</span> Replicator r = <span class="keyword">new</span> Replicator(opts, raftOptions);</span><br><span class="line">    <span class="comment">// 检查到目标节点的连通性</span></span><br><span class="line">    <span class="keyword">if</span> (!r.rpcService.connect(opts.getPeerId().getEndpoint())) {</span><br><span class="line">        LOG.error(<span class="string">"Fail to init sending channel to {}."</span>, opts.getPeerId());</span><br><span class="line">        <span class="comment">// Return and it will be retried later.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... register replicator metric set</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start replication</span></span><br><span class="line">    r.id = <span class="keyword">new</span> ThreadId(r, r);</span><br><span class="line">    <span class="comment">// 获取与当前 Replicator 绑定的不可重入锁</span></span><br><span class="line">    r.id.lock();</span><br><span class="line">    <span class="comment">// 发布 CREATED 事件</span></span><br><span class="line">    notifyReplicatorStatusListener(r, ReplicatorEvent.CREATED);</span><br><span class="line">    LOG.info(<span class="string">"Replicator={}@{} is started"</span>, r.id, r.options.getPeerId());</span><br><span class="line">    r.catchUpClosure = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 更新最近一次发送 RPC 请求的时间戳</span></span><br><span class="line">    r.lastRpcSendTimestamp = Utils.monotonicMs();</span><br><span class="line">    <span class="comment">// 启动心跳超时计时器</span></span><br><span class="line">    r.startHeartbeatTimer(Utils.nowMs());</span><br><span class="line">    <span class="comment">// 发送探针请求，以获取接下去发往目标节点的正确 logIndex 位置，并启动日志复制进程</span></span><br><span class="line">    <span class="comment">// id.unlock in sendEmptyEntries</span></span><br><span class="line">    r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> r.id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>其中方法 <code>Replicator#sendEmptyEntries</code> 用于向目标节点发送一个空的 AppendEntries 请求，此类请求可以是一个探针（probe）请求，也可以是一个心跳请求。关于心跳请求的发送和响应过程，我们将在后面的小节专门介绍，下面来看一下探针请求的发送和响应过程。Leader 节点在通过复制器 Replicator 与目标 Follower 节点建立连接后，需要发送一个探针请求，目的是获取 Follower 节点已经拥有的日志位置，以便于接下去向 Follower 节点发送后续的日志数据。</p>
<p>方法 <code>Replicator#sendEmptyEntries</code> 接收两个参数，当发送探针请求时会设置参数 <code>isHeartbeat = false</code>，同时设置参数 <code>heartBeatClosure = null</code>，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendEmptyEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isHeartbeat,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> RpcResponseClosure&lt;AppendEntriesResponse&gt; heartBeatClosure)</span> </span>{</span><br><span class="line">    <span class="comment">// 构建 AppendEntries 请求</span></span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest.Builder rb = AppendEntriesRequest.newBuilder();</span><br><span class="line">    <span class="comment">// 为 AppendEntries 请求填充基础参数，包括当前节点的 term 值、groupId、节点 ID，以及 committedLogIndex 等等</span></span><br><span class="line">    <span class="comment">// 如果返回 false 说明待发送的部分日志已经变为快照，需要先给目标节点安装快照</span></span><br><span class="line">    <span class="keyword">if</span> (!fillCommonFields(rb, <span class="keyword">this</span>.nextIndex - <span class="number">1</span>, isHeartbeat)) {</span><br><span class="line">        <span class="comment">// id is unlock in installSnapshot</span></span><br><span class="line">        installSnapshot();</span><br><span class="line">        <span class="keyword">if</span> (isHeartbeat &amp;&amp; heartBeatClosure != <span class="keyword">null</span>) {</span><br><span class="line">            RpcUtils.runClosureInThread(heartBeatClosure,</span><br><span class="line">                    <span class="keyword">new</span> Status(RaftError.EAGAIN, <span class="string">"Fail to send heartbeat to peer %s"</span>, <span class="keyword">this</span>.options.getPeerId()));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> monotonicSendTimeMs = Utils.monotonicMs();</span><br><span class="line">        <span class="keyword">final</span> AppendEntriesRequest request = rb.build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 心跳请求</span></span><br><span class="line">        <span class="keyword">if</span> (isHeartbeat) {</span><br><span class="line">            <span class="comment">// ... 省略心跳请求相关实现</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 探针请求</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Sending a probe request.</span></span><br><span class="line">            <span class="keyword">this</span>.statInfo.runningState = RunningState.APPENDING_ENTRIES;</span><br><span class="line">            <span class="keyword">this</span>.statInfo.firstLogIndex = <span class="keyword">this</span>.nextIndex;</span><br><span class="line">            <span class="keyword">this</span>.statInfo.lastLogIndex = <span class="keyword">this</span>.nextIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.appendEntriesCounter++;</span><br><span class="line">            <span class="keyword">this</span>.state = State.Probe;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> stateVersion = <span class="keyword">this</span>.version;</span><br><span class="line">            <span class="comment">// 递增请求序列</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> seq = getAndIncrementReqSeq();</span><br><span class="line">            <span class="comment">// 向目标节点发送 AppendEntries 请求</span></span><br><span class="line">            <span class="keyword">final</span> Future&lt;Message&gt; rpcFuture = <span class="keyword">this</span>.rpcService.appendEntries(</span><br><span class="line">                    <span class="keyword">this</span>.options.getPeerId().getEndpoint(),</span><br><span class="line">                    request,</span><br><span class="line">                    -<span class="number">1</span>,</span><br><span class="line">                    <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() {</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>{</span><br><span class="line">                            <span class="comment">// 处理响应</span></span><br><span class="line">                            onRpcReturned(Replicator.<span class="keyword">this</span>.id,</span><br><span class="line">                                    RequestType.AppendEntries,</span><br><span class="line">                                    status,</span><br><span class="line">                                    request,</span><br><span class="line">                                    getResponse(),</span><br><span class="line">                                    seq,</span><br><span class="line">                                    stateVersion,</span><br><span class="line">                                    monotonicSendTimeMs);</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                    });</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前请求标记为 inflight，并记录到 inflight 队列中</span></span><br><span class="line">            addInflight(RequestType.AppendEntries, <span class="keyword">this</span>.nextIndex, <span class="number">0</span>, <span class="number">0</span>, seq, rpcFuture);</span><br><span class="line">        }</span><br><span class="line">        LOG.debug(<span class="string">"Node {} send HeartbeatRequest to {} term {} lastCommittedIndex {}"</span>,</span><br><span class="line">                <span class="keyword">this</span>.options.getNode().getNodeId(), <span class="keyword">this</span>.options.getPeerId(), <span class="keyword">this</span>.options.getTerm(), request.getCommittedIndex());</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.id.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的核心逻辑在于构造并向目标节点发送 AppendEntries 请求，方法 <code>Replicator#fillCommonFields</code> 会往 AppendEntries 请求对象中填充一些基础数据，包括当前节点的 term 值、groupId、节点 ID、最近一次复制成功的日志对应的 logIndex 和 term 值、目标节点 ID，以及当前节点最新的 committedIndex 值。如果该方法返回 false，则说明需要发送给目标节点的日志已经变为快照形式存储，需要转为走快照机制为目标节点安装快照，关于快照相关的实现我们将在后面用专门的文章进行介绍，这里暂且跳过。</p>
<p>在将 AppendEntries 请求发送出去之后，JRaft 会将请求标记为 inflight 并记录到 inflight 队列中，然后等待目标节点响应，关于请求的 pipeline 机制在前面已经专门介绍过。下面来看一下目标节点对于 AppendEntries 探针请求的处理过程，由 <code>NodeImpl#handleAppendEntriesRequest</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">handleAppendEntriesRequest</span><span class="params">(<span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> RpcRequestClosure done)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesCount = request.getEntriesCount();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 当前节点处于非活跃状态，响应错误</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.state.isActive()) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} is not in active state, currTerm={}."</span>, getNodeId(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">return</span> RpcFactoryHelper <span class="comment">//</span></span><br><span class="line">                    .responseFactory() <span class="comment">//</span></span><br><span class="line">                    .newResponse(AppendEntriesResponse.getDefaultInstance(), RaftError.EINVAL,</span><br><span class="line">                            <span class="string">"Node %s is not in active state, state %s."</span>, getNodeId(), <span class="keyword">this</span>.state.name());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析请求来源节点 ID</span></span><br><span class="line">        <span class="keyword">final</span> PeerId serverId = <span class="keyword">new</span> PeerId();</span><br><span class="line">        <span class="keyword">if</span> (!serverId.parse(request.getServerId())) {</span><br><span class="line">            <span class="comment">// 解析失败，响应错误</span></span><br><span class="line">            LOG.warn(<span class="string">"Node {} received AppendEntriesRequest from {} serverId bad format."</span>, getNodeId(), request.getServerId());</span><br><span class="line">            <span class="keyword">return</span> RpcFactoryHelper <span class="comment">//</span></span><br><span class="line">                    .responseFactory() <span class="comment">//</span></span><br><span class="line">                    .newResponse(AppendEntriesResponse.getDefaultInstance(),</span><br><span class="line">                            RaftError.EINVAL, <span class="string">"Parse serverId failed: %s."</span>, request.getServerId());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验请求中的 term 值，如果小于当前节点，则拒绝请求并返回自己当前的 term 值</span></span><br><span class="line">        <span class="keyword">if</span> (request.getTerm() &lt; <span class="keyword">this</span>.currTerm) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} ignore stale AppendEntriesRequest from {}, term={}, currTerm={}."</span>,</span><br><span class="line">                    getNodeId(), request.getServerId(), request.getTerm(), <span class="keyword">this</span>.currTerm);</span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                    .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                    .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                    .build();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于请求和节点本地状态判断是否需要执行 stepdown</span></span><br><span class="line">        checkStepDown(request.getTerm(), serverId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求来源节点并不是当前节点所知道的 Leader 节点，</span></span><br><span class="line">        <span class="comment">// 可能出现网络分区，尝试将 term 值加 1，以触发 Leader 节点 stepdown</span></span><br><span class="line">        <span class="keyword">if</span> (!serverId.equals(<span class="keyword">this</span>.leaderId)) {</span><br><span class="line">            LOG.error(<span class="string">"Another peer {} declares that it is the leader at term {} which was occupied by leader {}."</span>,</span><br><span class="line">                    serverId, <span class="keyword">this</span>.currTerm, <span class="keyword">this</span>.leaderId);</span><br><span class="line">            <span class="comment">// Increase the term by 1 and make both leaders step down to minimize the loss of split brain</span></span><br><span class="line">            stepDown(request.getTerm() + <span class="number">1</span>, <span class="keyword">false</span>,</span><br><span class="line">                    <span class="keyword">new</span> Status(RaftError.ELEADERCONFLICT, <span class="string">"More than one leader in the same term."</span>));</span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                    .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                    .setTerm(request.getTerm() + <span class="number">1</span>) <span class="comment">//</span></span><br><span class="line">                    .build();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新本地记录的最近一次收到来自 Leader 节点请求的时间戳</span></span><br><span class="line">        updateLastLeaderTimestamp(Utils.monotonicMs());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前是复制日志的 AppendEntries 请求，但是本地正在安装快照，响应错误</span></span><br><span class="line">        <span class="keyword">if</span> (entriesCount &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.snapshotExecutor != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.snapshotExecutor.isInstallingSnapshot()) {</span><br><span class="line">            LOG.warn(<span class="string">"Node {} received AppendEntriesRequest while installing snapshot."</span>, getNodeId());</span><br><span class="line">            <span class="keyword">return</span> RpcFactoryHelper <span class="comment">//</span></span><br><span class="line">                    .responseFactory() <span class="comment">//</span></span><br><span class="line">                    .newResponse(AppendEntriesResponse.getDefaultInstance(), RaftError.EBUSY,</span><br><span class="line">                            <span class="string">"Node %s:%s is installing snapshot."</span>, <span class="keyword">this</span>.groupId, <span class="keyword">this</span>.serverId);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> prevLogIndex = request.getPrevLogIndex();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> prevLogTerm = request.getPrevLogTerm();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> localPrevLogTerm = <span class="keyword">this</span>.logManager.getTerm(prevLogIndex);</span><br><span class="line">        <span class="comment">// 请求中 logIndex 对应的 term 值与本地不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (localPrevLogTerm != prevLogTerm) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastLogIndex = <span class="keyword">this</span>.logManager.getLastLogIndex();</span><br><span class="line">            LOG.warn(<span class="string">"Node {} reject term_unmatched AppendEntriesRequest from {}, "</span> +</span><br><span class="line">                            <span class="string">"term={}, prevLogIndex={}, prevLogTerm={}, localPrevLogTerm={}, lastLogIndex={}, entriesSize={}."</span>,</span><br><span class="line">                    getNodeId(), request.getServerId(), request.getTerm(), prevLogIndex, prevLogTerm, localPrevLogTerm, lastLogIndex, entriesCount);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                    .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                    .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                    .setLastLogIndex(lastLogIndex) <span class="comment">//</span></span><br><span class="line">                    .build();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 心跳或者探针请求</span></span><br><span class="line">        <span class="keyword">if</span> (entriesCount == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 返回本地当前的 term 值以及对应的 logIndex</span></span><br><span class="line">            <span class="keyword">final</span> AppendEntriesResponse.Builder respBuilder = AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                    .setSuccess(<span class="keyword">true</span>) <span class="comment">//</span></span><br><span class="line">                    .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">//</span></span><br><span class="line">                    .setLastLogIndex(<span class="keyword">this</span>.logManager.getLastLogIndex());</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">            <span class="comment">// see the comments at FollowerStableClosure#run()</span></span><br><span class="line">            <span class="comment">// 基于 Leader 的 committedIndex 更新本地的 lastCommittedIndex 值</span></span><br><span class="line">            <span class="keyword">this</span>.ballotBox.setLastCommittedIndex(Math.min(request.getCommittedIndex(), prevLogIndex));</span><br><span class="line">            <span class="keyword">return</span> respBuilder.build();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 省略复制日志数据请求的处理逻辑</span></span><br><span class="line"></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) {</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ... metrics</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Follower 节点对于探针请求的整体响应流程可以概括为：</p>
<ol>
<li>如果当前节点处于非活跃状态，则响应错误；</li>
<li>否则，解析请求来源节点的节点 ID，如果解析失败则响应错误；</li>
<li>否则，校验请求中的 term 值是否小于当前节点，如果是则拒绝请求；</li>
<li>否则，基于请求和当前节点本地状态判断是否需要执行 stepdown 操作；</li>
<li>判断请求来源节点是否是当前节点所认可的 Leader 节点，如果不是则说明可能出现网络分区，尝试将响应中的 term 值加 1，以触发请求节点执行 stepdown 操作；</li>
<li>否则，更新本地记录的最近一次收到来自 Leader 节点的时间戳；</li>
<li>校验最近一次完成复制的 LogEntry 对应的 term 值是否与本地相匹配，如果不匹配则拒绝请求，并返回本地已知的最新 logIndex 值；</li>
<li>否则，依据请求中的 committedIndex 值更新本地的 committedIndex 值，同时响应请求，返回本地已知的最新 logIndex 和 term 值。</li>
</ol>
<p>通过这一系列的校验过程，Follower 节点会在针对当前探针请求的响应中附上本地已知的最新 logIndex 和 term 值，而 Leader 节点会依据响应选择正确位置的 LogEntry 发送给当前 Follower 节点。</p>
<p>下面来看一下 Leader 节点对于上述 Follower 节点响应的处理过程，因为探针请求本质上是一类 AppendEntries 请求，所以由 <code>Replicator#onAppendEntriesReturned</code> 方法实现（省略了部分 DEBUG 日志打印）：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onAppendEntriesReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">final</span> Inflight inflight,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">final</span> Status status,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">final</span> AppendEntriesRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">final</span> AppendEntriesResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">final</span> Replicator r)</span> </span>{</span><br><span class="line">    <span class="comment">// inflight 请求与响应中记录的请求对应的 logIndex 不匹配，重置请求 inflight 队列，重新发送探针请求</span></span><br><span class="line">    <span class="keyword">if</span> (inflight.startIndex != request.getPrevLogIndex() + <span class="number">1</span>) {</span><br><span class="line">        LOG.warn(<span class="string">"Replicator {} received invalid AppendEntriesResponse, in-flight startIndex={}, request prevLogIndex={}, reset the replicator state and probe again."</span>,</span><br><span class="line">                r, inflight.startIndex, request.getPrevLogIndex());</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        <span class="comment">// unlock id in sendEmptyEntries</span></span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标 Follower 发生错误，重置请求 inflight 队列，重新发送探针请求</span></span><br><span class="line">    <span class="keyword">if</span> (!status.isOk()) {</span><br><span class="line">        <span class="comment">// If the follower crashes, any RPC to the follower fails immediately,</span></span><br><span class="line">        <span class="comment">// so we need to block the follower for a while instead of looping until it comes back or be removed</span></span><br><span class="line">        <span class="comment">// dummy_id is unlock in block</span></span><br><span class="line">        notifyReplicatorStatusListener(r, ReplicatorEvent.ERROR, status);</span><br><span class="line">        <span class="keyword">if</span> (++r.consecutiveErrorTimes % <span class="number">10</span> == <span class="number">0</span>) {</span><br><span class="line">            LOG.warn(<span class="string">"Fail to issue RPC to {}, consecutiveErrorTimes={}, error={}"</span>,</span><br><span class="line">                    r.options.getPeerId(), r.consecutiveErrorTimes, status);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 重置 inflight 队列，阻塞一会儿重新发送探针请求</span></span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        <span class="comment">// unlock in in block</span></span><br><span class="line">        r.block(startTimeMs, status.getCode());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 目标 Follower 节点运行正常 */</span></span><br><span class="line"></span><br><span class="line">    r.consecutiveErrorTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 目标 Follower 节点拒绝响应</span></span><br><span class="line">    <span class="keyword">if</span> (!response.getSuccess()) {</span><br><span class="line">        <span class="comment">// Follower 节点的 term 值更大</span></span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; r.options.getTerm()) {</span><br><span class="line">            <span class="keyword">final</span> NodeImpl node = r.options.getNode();</span><br><span class="line">            r.notifyOnCaughtUp(RaftError.EPERM.getNumber(), <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 销毁当前复制器 Replicator</span></span><br><span class="line">            r.destroy();</span><br><span class="line">            <span class="comment">// 提升当前节点的 term 值，并执行 stepdown</span></span><br><span class="line">            node.increaseTermTo(response.getTerm(), <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                    <span class="string">"Leader receives higher term heartbeat_response from peer:%s"</span>, r.options.getPeerId()));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 更新最近一次向目标节点发送 RPC 请求的时间戳</span></span><br><span class="line">        <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) {</span><br><span class="line">            r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 重置 inflight 队列，调整 nextIndex 之后重新发送探针请求</span></span><br><span class="line">        r.resetInflights();</span><br><span class="line">        <span class="comment">// prev_log_index and prev_log_term doesn't match</span></span><br><span class="line">        <span class="keyword">if</span> (response.getLastLogIndex() + <span class="number">1</span> &lt; r.nextIndex) {</span><br><span class="line">            LOG.debug(<span class="string">"LastLogIndex at peer={} is {}"</span>, r.options.getPeerId(), response.getLastLogIndex());</span><br><span class="line">            <span class="comment">// The peer contains less logs than leader</span></span><br><span class="line">            r.nextIndex = response.getLastLogIndex() + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Follower 节点本地的 logIndex 更大，可能包含老的 Leader 节点复制的日志，</span></span><br><span class="line">        <span class="comment">// 递减 nextIndex 之后重试，直到找到两个节点相同日志的交叉点为止</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// The peer contains logs from old term which should be truncated,</span></span><br><span class="line">            <span class="comment">// decrease _last_log_at_peer by one to test the right index to keep</span></span><br><span class="line">            <span class="keyword">if</span> (r.nextIndex &gt; <span class="number">1</span>) {</span><br><span class="line">                LOG.debug(<span class="string">"logIndex={} dismatch"</span>, r.nextIndex);</span><br><span class="line">                r.nextIndex--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                LOG.error(<span class="string">"Peer={} declares that log at index=0 doesn't match, which is not supposed to happen"</span>, r.options.getPeerId());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// dummy_id is unlock in _send_heartbeat</span></span><br><span class="line">        <span class="comment">// 重新发送探针请求</span></span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 目标 Follower 节点响应成功 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求期间 term 值已经发生变化，当前节点可能已经不是 Leader 节点，清空 inflight 队列</span></span><br><span class="line">    <span class="keyword">if</span> (response.getTerm() != r.options.getTerm()) {</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        LOG.error(<span class="string">"Fail, response term {} dismatch, expect term {}"</span>, response.getTerm(), r.options.getTerm());</span><br><span class="line">        id.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 更新最近一次向目标节点发送 RPC 请求的时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) {</span><br><span class="line">        r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesSize = request.getEntriesCount();</span><br><span class="line">    <span class="comment">// 如果是复制日志请求，当 Follower 节点复制成功之后需要尝试执行 BallotBox#commitAt 以检测当前日志是否被过半数的节点成功复制</span></span><br><span class="line">    <span class="keyword">if</span> (entriesSize &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (r.options.getReplicatorType().isFollower()) {</span><br><span class="line">            <span class="comment">// Only commit index when the response is from follower.</span></span><br><span class="line">            r.options.getBallotBox().commitAt(r.nextIndex, r.nextIndex + entriesSize - <span class="number">1</span>, r.options.getPeerId());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    r.state = State.Replicate;</span><br><span class="line">    r.blockTimer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 更新待发送的下一个 logIndex 位置</span></span><br><span class="line">    r.nextIndex += entriesSize;</span><br><span class="line">    r.hasSucceeded = <span class="keyword">true</span>;</span><br><span class="line">    r.notifyOnCaughtUp(RaftError.SUCCESS.getNumber(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// dummy_id is unlock in _send_entries</span></span><br><span class="line">    <span class="keyword">if</span> (r.timeoutNowIndex &gt; <span class="number">0</span> &amp;&amp; r.timeoutNowIndex &lt; r.nextIndex) {</span><br><span class="line">        r.sendTimeoutNow(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Leader 节点对于 Follower 节点的探针请求响应处理流程可以概括如下：</p>
<ol>
<li>校验 inflight 请求与响应中记录的请求对应的已经完成复制的 logIndex 是否一致，如果不是则需要重置 inflight 队列，并重新发送探针请求；</li>
<li>否则，如果目标 Follower 节点运行异常，则同样需要重置 inflight 队列，并重新发送探针请求；</li>
<li>否则，说明目标 Follower 节点运行正常，但是目标节点可以同意当前请求，也可以拒绝当前请求，需要分别处理。</li>
</ol>
<p><strong>如果目标 Follower 节点拒绝当前请求</strong> ，按照之前对于 Follower 节点处理 AppendEntries 探针请求过程的分析可知可能包含以下原因：</p>
<ol>
<li>Follower 节点本地的 term 值相对于当前 Leader 节点更大。</li>
<li>Follower 节点本地记录的 Leader 节点 ID 并不是当前 Leader 节点，即可能出现网络分区。</li>
<li>Follower 节点与当前 Leader 节点的日志数据存在冲突。</li>
</ol>
<p>针对原因 1 和 2，说明集群中已经有更新的 Leader 节点，此时当前节点需要销毁对应的复制器 Replicator 实例，并执行 stepdown 操作。</p>
<p>针对原因 3 需要分为两类情况：</p>
<ol>
<li>如果目标 Follower 节点本地最新的 logIndex 相对于当前复制器 Replicator 记录的 nextIndex 要小，则需要修正 nextIndex 之后重新发送探针请求。</li>
<li>如果目标 Follower 节点本地最新的 logIndex 相对于当前复制器 Replicator 记录的 nextIndex 相等或更大，说明目标 Follower 节点包含老的 Leader 节点复制的日志，此时需要递减 nextIndex 值并重新发送探针请求，以解决日志冲突问题。</li>
</ol>
<p><strong>如果目标 Follower 节点同意当前请求</strong> ，则说明 Follower 节点确认当前复制器 Replicator 实例记录的 nextIndex 值是正确的，无需修正 nextIndex 值，接下去可以继续执行往目标 Follower 节点复制日志的操作。</p>

        <h4 id="复制日志">
          <a href="#复制日志" class="heading-link"><i class="fas fa-link"></i></a>复制日志</h4>
      <p>上一小节介绍了复制器 Replicator 在启动时会向目标 Follower 节点发送探针请求，以获取目标 Follower 节点已经拥有的日志位置，以便于接下去向 Follower 节点发送后续的日志数据。如果刚刚分析的 <code>Replicator#onAppendEntriesReturned</code> 方法处理探针请求对应的响应正常，即返回 true，那么接下去就会触发日志复制的进程，即调用 <code>Replicator#sendEntries</code> 方法开始往目标 Follower 节点复制日志数据。</p>
<p>方法 <code>Replicator#sendEntries</code> 会尝试计算接下去待发送的 LogEntry 对应的 logIndex 值，如果当前复制器 Replicator 负载较高，则会尝试暂停发送。方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendEntries</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">long</span> prevSendIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="comment">// 获取下一个待发送的 LogEntry 对应的 logIndex 值，如果返回 -1 表示暂停复制</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextSendingIndex = getNextSendIndex();</span><br><span class="line">            <span class="keyword">if</span> (nextSendingIndex &gt; prevSendIndex) {</span><br><span class="line">                <span class="comment">// 向目标节点复制 nextSendingIndex 位置之后的 LogEntry 数据</span></span><br><span class="line">                <span class="keyword">if</span> (sendEntries(nextSendingIndex)) {</span><br><span class="line">                    prevSendIndex = nextSendingIndex;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    doUnlock = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// id already unlock in sendEntries when it returns false.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) {</span><br><span class="line">            <span class="keyword">this</span>.id.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getNextSendIndex</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 没有 inflight 请求，从 nextIndex 开始发送</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.inflights.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nextIndex;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 太多 inflight 请求，暂停发送新的 AppendEntries 请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.inflights.size() &gt; <span class="keyword">this</span>.raftOptions.getMaxReplicatorInflightMsgs()) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Last request should be a AppendEntries request and has some entries.</span></span><br><span class="line">    <span class="comment">// 最近一次发送的 RPC 请求是携带 LogEntry 的 AppendEntries 请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rpcInFly != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.rpcInFly.isSendingLogEntries()) {</span><br><span class="line">        <span class="comment">// 计算并返回接下去待发送的 LogEntry 对应的 logIndex 值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rpcInFly.startIndex + <span class="keyword">this</span>.rpcInFly.count;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法 <code>Replicator#sendEntries</code> 的重载版本 <code>Replicator#sendEntries(long)</code> 用于从指定 logIndex 位置开始从本地获取对应的 LogEntry 数据并复制给目标 Follower 节点，整体过程与前面介绍的发送探针请求 <code>Replicator#sendEmptyEntries</code> 方法基本类似。这里重点关注一下从本地加载日志数据并填充到 AppendEntries 请求对象中的过程，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ByteBufferCollector dataBuf = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 获取单次批量发送 LogEntry 的数目上线</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxEntriesSize = <span class="keyword">this</span>.raftOptions.getMaxEntriesSize();</span><br><span class="line"><span class="keyword">final</span> RecyclableByteBufferList byteBufList = RecyclableByteBufferList.newInstance();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxEntriesSize; i++) {</span><br><span class="line">        <span class="keyword">final</span> RaftOutter.EntryMeta.Builder emb = RaftOutter.EntryMeta.newBuilder();</span><br><span class="line">        <span class="comment">// 获取指定 logIndex 的 LogEntry 数据，填充到 emb 和 byteBufList 中，</span></span><br><span class="line">        <span class="comment">// 如果返回 false 说明容量已满</span></span><br><span class="line">        <span class="keyword">if</span> (!prepareEntry(nextSendingIndex, i, emb, byteBufList)) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        rb.addEntries(emb.build());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未获取到任何 LogEntry 数据，可能目标数据已经变为快照了，也可能是真的没有数据可以复制</span></span><br><span class="line">    <span class="keyword">if</span> (rb.getEntriesCount() == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// nextSendingIndex &lt; firstLogIndex，说明对应区间的数据已变为快照，需要先给目标节点安装快照</span></span><br><span class="line">        <span class="keyword">if</span> (nextSendingIndex &lt; <span class="keyword">this</span>.options.getLogManager().getFirstLogIndex()) {</span><br><span class="line">            installSnapshot();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 说明没有新的数据可以复制，设置一个回调等待新的数据到来之后重新触发 sendEntries 操作</span></span><br><span class="line">        waitMoreEntries(nextSendingIndex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将日志数据填充到 AppendEntries 请求中</span></span><br><span class="line">    <span class="keyword">if</span> (byteBufList.getCapacity() &gt; <span class="number">0</span>) {</span><br><span class="line">        dataBuf = ByteBufferCollector.allocateByRecyclers(byteBufList.getCapacity());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ByteBuffer b : byteBufList) {</span><br><span class="line">            dataBuf.put(b);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buf = dataBuf.getBuffer();</span><br><span class="line">        buf.flip();</span><br><span class="line">        rb.setData(ZeroByteStringHelper.wrap(buf));</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    RecycleUtil.recycle(byteBufList);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>JRaft 在 AppendEntries 请求的设计上采用了将 LogEntry 的元数据和数据体相分离的策略，所以上述从本地加载日志数据的过程会先填充元数据，再填充数据体。实现上使用 RecyclableByteBufferList 作为数据体的载体，RecyclableByteBufferList 可以看做是一个可回收利用的 ByteBuffer 链表，实现层面借鉴了 Netty 的轻量级对象池的设计思想。</p>
<p>下面来看一下从本地加载日志数据并填充 AppendEntries 请求的过程，由 <code>Replicator#prepareEntry</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">prepareEntry</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> nextSendingIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">final</span> <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">final</span> RaftOutter.EntryMeta.Builder emb,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">final</span> RecyclableByteBufferList dataBuffer)</span> </span>{</span><br><span class="line">    <span class="comment">// 数据量已经超过阈值</span></span><br><span class="line">    <span class="keyword">if</span> (dataBuffer.getCapacity() &gt;= <span class="keyword">this</span>.raftOptions.getMaxBodySize()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 基于偏移量计算当前处理的 LogEntry 的 logIndex 值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> logIndex = nextSendingIndex + offset;</span><br><span class="line">    <span class="comment">// 从本地获取对应的 LogEntry 数据</span></span><br><span class="line">    <span class="keyword">final</span> LogEntry entry = <span class="keyword">this</span>.options.getLogManager().getEntry(logIndex);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 将 LogEntry 拆分为元数据和数据体分别填充 EntryMeta 和 RecyclableByteBufferList</span></span><br><span class="line">    emb.setTerm(entry.getId().getTerm());</span><br><span class="line">    <span class="comment">// 设置 checksum</span></span><br><span class="line">    <span class="keyword">if</span> (entry.hasChecksum()) {</span><br><span class="line">        emb.setChecksum(entry.getChecksum()); <span class="comment">// since 1.2.6</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置 LogEntry 类型</span></span><br><span class="line">    emb.setType(entry.getType());</span><br><span class="line">    <span class="keyword">if</span> (entry.getPeers() != <span class="keyword">null</span>) {</span><br><span class="line">        Requires.requireTrue(!entry.getPeers().isEmpty(), <span class="string">"Empty peers at logIndex=%d"</span>, logIndex);</span><br><span class="line">        fillMetaPeers(emb, entry);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        Requires.requireTrue(entry.getType() != EnumOutter.EntryType.ENTRY_TYPE_CONFIGURATION,</span><br><span class="line">                <span class="string">"Empty peers but is ENTRY_TYPE_CONFIGURATION type at logIndex=%d"</span>, logIndex);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置数据长度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> remaining = entry.getData() != <span class="keyword">null</span> ? entry.getData().remaining() : <span class="number">0</span>;</span><br><span class="line">    emb.setDataLen(remaining);</span><br><span class="line">    <span class="comment">// 填充数据到 dataBuffer</span></span><br><span class="line">    <span class="keyword">if</span> (entry.getData() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// should slice entry data</span></span><br><span class="line">        dataBuffer.add(entry.getData().slice());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现依据偏移量计算得到最终的 logIndex 值，然后调用 <code>LogManagerImpl#getEntry</code> 方法从文件系统加载获取到对应的 LogEntry 数据，最后将 LogEntry 中的元数据和数据体拆分后分别填充到 EntryMeta 和 RecyclableByteBufferList 对象中。JRaft 默认采用 RocksDB 作为日志数据的存储引擎，其中 key 就是 LogEntry 对应的 logIndex 值，所以方法 <code>LogManagerImpl#getEntry</code> 的执行过程简单来说就是依据 logIndex 从 RocksDB 中获取对应数据的过程。</p>
<p>如果从本地获取不到 logIndex 对应的日志数据，那么可能存在两种原因：</p>
<ol>
<li>需要复制的数据已经变为快照形式存储。</li>
<li>没有可以复制的数据。</li>
</ol>
<p>针对第一种情况直接给目标 Follower 节点安装快照即可，针对第二种情况则立即退出当前 <code>Replicator#sendEntries</code> 方法，并设置一个回调等待新的日志数据。关于快照机制将在后面用专门的篇章进行介绍，这里我们主要来看一下针对情况二的处理过程，位于 <code>Replicator#waitMoreEntries</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitMoreEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> nextWaitIndex)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        LOG.debug(<span class="string">"Node {} waits more entries"</span>, <span class="keyword">this</span>.options.getNode().getNodeId());</span><br><span class="line">        <span class="comment">// 已经设置过等待</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.waitId &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 设置一个回调，当有可复制日志时触发再次往目标 Follower 节点发送数据</span></span><br><span class="line">        <span class="keyword">this</span>.waitId = <span class="keyword">this</span>.options.getLogManager().wait(</span><br><span class="line">                nextWaitIndex - <span class="number">1</span>,</span><br><span class="line">                (arg, errorCode) -&gt; continueSending((ThreadId) arg, errorCode), <span class="keyword">this</span>.id);</span><br><span class="line">        <span class="keyword">this</span>.statInfo.runningState = RunningState.IDLE;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.id.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.alipay.sofa.jraft.storage.impl.LogManagerImpl#wait</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">wait</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> expectedLastLogIndex, <span class="keyword">final</span> NewLogCallback cb, <span class="keyword">final</span> Object arg)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> WaitMeta wm = <span class="keyword">new</span> WaitMeta(cb, arg, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> notifyOnNewLog(expectedLastLogIndex, wm);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">notifyOnNewLog</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> expectedLastLogIndex, <span class="keyword">final</span> WaitMeta wm)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 已经有新的日志可复制，或者当前 LogManager 已被停止</span></span><br><span class="line">        <span class="keyword">if</span> (expectedLastLogIndex != <span class="keyword">this</span>.lastLogIndex || <span class="keyword">this</span>.stopped) {</span><br><span class="line">            wm.errorCode = <span class="keyword">this</span>.stopped ? RaftError.ESTOP.getNumber() : <span class="number">0</span>;</span><br><span class="line">            Utils.runInThread(() -&gt; runOnNewLog(wm));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.nextWaitId == <span class="number">0</span>) { <span class="comment">//skip 0</span></span><br><span class="line">            ++<span class="keyword">this</span>.nextWaitId;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> waitId = <span class="keyword">this</span>.nextWaitId++;</span><br><span class="line">        <span class="comment">// 记录等待的信息</span></span><br><span class="line">        <span class="keyword">this</span>.waitMap.put(waitId, wm);</span><br><span class="line">        <span class="keyword">return</span> waitId;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现会针对期望的 logIndex 设置一个回调，如果本地最新的 logIndex 超过该期望值则说明有新的日志数据可以被复制，会触发执行 <code>Replicator#continueSending</code> 操作，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">continueSending</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> <span class="keyword">int</span> errCode)</span> </span>{</span><br><span class="line">    <span class="comment">// 当前 Replicator 已被销毁</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// It was destroyed already</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> Replicator r = (Replicator) id.lock();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    r.waitId = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 超时，重新发送探针请求</span></span><br><span class="line">    <span class="keyword">if</span> (errCode == RaftError.ETIMEDOUT.getNumber()) {</span><br><span class="line">        r.blockTimer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Send empty entries after block timeout to check the correct</span></span><br><span class="line">        <span class="comment">// _next_index otherwise the replicator is likely waits in executor.shutdown();</span></span><br><span class="line">        <span class="comment">// _wait_more_entries and no further logs would be replicated even if the</span></span><br><span class="line">        <span class="comment">// last_index of this followers is less than |next_index - 1|</span></span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// LogManager 正常运行，继续尝试向目标 Follower 节点发送数据</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (errCode != RaftError.ESTOP.getNumber()) {</span><br><span class="line">        <span class="comment">// id is unlock in _send_entries</span></span><br><span class="line">        r.sendEntries();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// LogManager 被停止，停止向目标节点发送日志数据</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        LOG.warn(<span class="string">"Replicator {} stops sending entries."</span>, id);</span><br><span class="line">        id.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由此可见，回调逻辑会再次尝试执行前面所介绍的 <code>Replicator#sendEntries</code> 逻辑。上述回调另外一个被触发的场景则在于调用 <code>LogManager#appendEntries</code> 追加新的日志数据的时候，这也是比较容易理解的。</p>
<p>完成了对于 AppendEntries 请求的构造，接下去复制器 Replicator 会采用 RPC 的方式将该请求发送给目标 Follower 节点。下面来看一下 Follower 节点对于复制日志数据 AppendEntries 请求的处理过程，位于 <code>NodeImpl#handleAppendEntriesRequest</code> 方法中。关于该方法我们前面在分析探针请求时已经介绍过，所以下面重点来看一下 Follower 节点针对日志数据复制操作相关的处理逻辑，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse request</span></span><br><span class="line"><span class="keyword">long</span> index = prevLogIndex;</span><br><span class="line"><span class="keyword">final</span> List&lt;LogEntry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(entriesCount);</span><br><span class="line">ByteBuffer allData = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (request.hasData()) {</span><br><span class="line">    allData = request.getData().asReadOnlyByteBuffer();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;RaftOutter.EntryMeta&gt; entriesList = request.getEntriesList();</span><br><span class="line"><span class="comment">// 遍历逐一解析请求中的 LogEntry 数据，记录到 entries 列表中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entriesCount; i++) {</span><br><span class="line">    index++;</span><br><span class="line">    <span class="comment">// 获取 LogEntry 元数据信息</span></span><br><span class="line">    <span class="keyword">final</span> RaftOutter.EntryMeta entry = entriesList.get(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于元数据和数据体构造 LogEntry 对象</span></span><br><span class="line">    <span class="keyword">final</span> LogEntry logEntry = logEntryFromMeta(index, allData, entry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logEntry != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果启用了 checksum 机制，则校验 checksum 值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.raftOptions.isEnableLogEntryChecksum() &amp;&amp; logEntry.isCorrupted()) {</span><br><span class="line">            <span class="comment">// checksum 值不匹配，说明数据可能被篡改</span></span><br><span class="line">            <span class="keyword">long</span> realChecksum = logEntry.checksum();</span><br><span class="line">            LOG.error(</span><br><span class="line">                    <span class="string">"Corrupted log entry received from leader, index={}, term={}, expectedChecksum={}, realChecksum={}"</span>,</span><br><span class="line">                    logEntry.getId().getIndex(), logEntry.getId().getTerm(), logEntry.getChecksum(), realChecksum);</span><br><span class="line">            <span class="keyword">return</span> RpcFactoryHelper <span class="comment">//</span></span><br><span class="line">                    .responseFactory() <span class="comment">//</span></span><br><span class="line">                    .newResponse(AppendEntriesResponse.getDefaultInstance(), RaftError.EINVAL,</span><br><span class="line">                            <span class="string">"The log entry is corrupted, index=%d, term=%d, expectedChecksum=%d, realChecksum=%d"</span>,</span><br><span class="line">                            logEntry.getId().getIndex(), logEntry.getId().getTerm(), logEntry.getChecksum(), realChecksum);</span><br><span class="line">        }</span><br><span class="line">        entries.add(logEntry);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> FollowerStableClosure closure = <span class="keyword">new</span> FollowerStableClosure(request,</span><br><span class="line">        AppendEntriesResponse.newBuilder().setTerm(<span class="keyword">this</span>.currTerm), <span class="keyword">this</span>, done, <span class="keyword">this</span>.currTerm);</span><br><span class="line"><span class="comment">// 将 LogEntry 数据写入本地磁盘</span></span><br><span class="line"><span class="keyword">this</span>.logManager.appendEntries(entries, closure);</span><br><span class="line"><span class="comment">// update configuration after _log_manager updated its memory status</span></span><br><span class="line">checkAndSetConfiguration(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></tbody></table></div></figure>
<p>针对复制日志数据的 AppendEntries 请求，Follower 节点会基于请求中的 LogEntry 元数据和数据体信息逐一解析构造对应的 LogEntry 对象（实现如下），并调用 <code>LogManager#appendEntries</code> 方法批量的将日志数据写入本地存储系统，关于 <code>LogManager#appendEntries</code> 方法已在前面分析过。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LogEntry <span class="title">logEntryFromMeta</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index, <span class="keyword">final</span> ByteBuffer allData, <span class="keyword">final</span> RaftOutter.EntryMeta entry)</span> </span>{</span><br><span class="line">    <span class="comment">// 忽略 ENTRY_TYPE_UNKNOWN 类型的 LogEntry 数据</span></span><br><span class="line">    <span class="keyword">if</span> (entry.getType() != EnumOutter.EntryType.ENTRY_TYPE_UNKNOWN) {</span><br><span class="line">        <span class="comment">// 给 LogEntry 对象填充基本的元数据信息</span></span><br><span class="line">        <span class="keyword">final</span> LogEntry logEntry = <span class="keyword">new</span> LogEntry();</span><br><span class="line">        logEntry.setId(<span class="keyword">new</span> LogId(index, entry.getTerm()));</span><br><span class="line">        logEntry.setType(entry.getType());</span><br><span class="line">        <span class="keyword">if</span> (entry.hasChecksum()) {</span><br><span class="line">            logEntry.setChecksum(entry.getChecksum()); <span class="comment">// since 1.2.6</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于元数据中记录的数据长度获取对应的 LogEntry 数据体，并填充到 LogEntry 对象中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dataLen = entry.getDataLen();</span><br><span class="line">        <span class="keyword">if</span> (dataLen &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) dataLen];</span><br><span class="line">            <span class="keyword">assert</span> allData != <span class="keyword">null</span>;</span><br><span class="line">            allData.get(bs, <span class="number">0</span>, bs.length);</span><br><span class="line">            logEntry.setData(ByteBuffer.wrap(bs));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 针对 ENTRY_TYPE_CONFIGURATION 类型的 LogEntry，解析并填充集群节点配置数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.getPeersCount() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (entry.getType() != EnumOutter.EntryType.ENTRY_TYPE_CONFIGURATION) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Invalid log entry that contains peers but is not ENTRY_TYPE_CONFIGURATION type: "</span> + entry.getType());</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 填充集群节点配置信息</span></span><br><span class="line">            fillLogEntryPeers(entry, logEntry);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (entry.getType() == EnumOutter.EntryType.ENTRY_TYPE_CONFIGURATION) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Invalid log entry that contains zero peers but is ENTRY_TYPE_CONFIGURATION type"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> logEntry;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>日志数据写入磁盘是一个异步的过程，当日志数据成功在 Follower 节点落盘之后，Follower 节点会向 Leader 节点发送 AppendEntries 响应。最后来看一下 Leader 节点针对复制日志数据的 AppendEntries 请求响应的处理过程，由前面对于 JRaft Pipeline 机制的介绍可知这里处理 AppendEntries 请求响应的过程由 <code>Replicator#onAppendEntriesReturned</code> 方法实现。前面在介绍探针请求时同样分析过该方法的实现，针对复制日志数据的 AppendEntries 请求响应的处理重点关注下面这样一段逻辑：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是复制日志请求，当 Follower 节点复制成功之后需要尝试执行 BallotBox#commitAt 以检测当前日志是否被过半数的节点成功复制</span></span><br><span class="line"><span class="keyword">if</span> (entriesSize &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">if</span> (r.options.getReplicatorType().isFollower()) {</span><br><span class="line">        <span class="comment">// Only commit index when the response is from follower.</span></span><br><span class="line">        r.options.getBallotBox().commitAt(r.nextIndex, r.nextIndex + entriesSize - <span class="number">1</span>, r.options.getPeerId());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">        LOG.debug(<span class="string">"Replicated logs in [{}, {}] to peer {}"</span>, r.nextIndex, r.nextIndex + entriesSize - <span class="number">1</span>, r.options.getPeerId());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果是针对复制日志数据的 AppendEntries 请求的响应，如果响应来自 Follower 节点则会触发执行 <code>BallotBox#commitAt</code> 方法以检查当前批次的日志数据是否能够被提交，即是否有超过半数的节点完成了对于该批次日志数据的复制操作，如果是则会触发 Leader 节点将该批次的日志数据标记为 committed。</p>
<p>前面在介绍日志数据生成流程时我们也曾遇到过该方法，当 Leader 节点完成对于该批次日志数据的落盘之后会回调该方法检查该批次的日志数据是否允许被提交，只不过那时是由 Leader 节点触发这一检查的过程，而这里则是由各个 Follower 节点所触发，本质上这也是一种投票机制。关于 <code>BallotBox#commitAt</code> 方法的实现已在前面介绍日志生成流程时分析过，不再重复介绍。</p>

        <h4 id="心跳机制">
          <a href="#心跳机制" class="heading-link"><i class="fas fa-link"></i></a>心跳机制</h4>
      <p>复制器 Replicator 中的字段 <code>Replicator#lastRpcSendTimestamp</code> 用于记录最近一次成功向目标 Follower 节点发送 RPC 请求的时间戳。上一篇我们在分析 JRaft 选主机制时曾介绍过 Leader 节点会基于该时间戳判断目标 Follower 节点是否处于活跃状态，所以我们可以认为该字段是目标 Follower 节点心跳正常的判定标志，对于一个心跳正常的 Follower 节点，该字段的值距离当前时间戳应该始终控制在一个合理的阈值范围内。</p>
<p>前面介绍的探针请求和复制日志数据请求都会在处理请求响应时更新该字段，不过仅靠这两类请求触发时间戳更新显然是不够的，毕竟整个 JRaft 集群不会始终处于频繁的日志数据复制状态。为此，JRaft 还在复制器 Replicator 中实现了一套心跳机制，本小节我们就深入分析这一套心跳机制的执行流程。</p>
<p>当启动一个复制器 Replicator 实例时（即调用 <code>Replicator#start</code> 方法）会执行 <code>Replicator#startHeartbeatTimer</code> 方法启动心跳计时器，该计时器会延迟指定时间（默认为 100ms）执行 <code>Replicator#onTimeout</code> 操作给当前复制器添加一个 <code>ETIMEDOUT</code> 事件，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(<span class="keyword">final</span> ThreadId id)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// ETIMEDOUT 错误会触发再次向目标节点发送心跳请求</span></span><br><span class="line">        id.setError(RaftError.ETIMEDOUT.getNumber());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        LOG.warn(<span class="string">"Replicator id is null when timeout, maybe it's destroyed."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>而复制器 Replicator 对于此类事件的处理逻辑就是调用 <code>Replicator#sendHeartbeat</code> 方法向目标 Follower 节点发送心跳请求：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendHeartbeat</span><span class="params">(<span class="keyword">final</span> ThreadId id)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Replicator r = (Replicator) id.lock();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 向目标 Follower 节点发送心跳请求</span></span><br><span class="line">    r.sendEmptyEntries(<span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由上述实现可以看到，所谓的心跳请求本质上还是一个空的 AppendEntries 请求。关于方法 <code>Replicator#sendEmptyEntries</code> 在前面介绍探针请求时已经分析过，而关于心跳请求的实现逻辑如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isHeartbeat) {</span><br><span class="line">    <span class="comment">// Sending a heartbeat request</span></span><br><span class="line">    <span class="keyword">this</span>.heartbeatCounter++;</span><br><span class="line">    RpcResponseClosure&lt;AppendEntriesResponse&gt; heartbeatDone;</span><br><span class="line">    <span class="comment">// 参数指定的响应回调优先</span></span><br><span class="line">    <span class="keyword">if</span> (heartBeatClosure != <span class="keyword">null</span>) {</span><br><span class="line">        heartbeatDone = heartBeatClosure;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置默认的心跳请求响应回调</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        heartbeatDone = <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() {</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>{</span><br><span class="line">                onHeartbeatReturned(Replicator.<span class="keyword">this</span>.id, status, request, getResponse(), monotonicSendTimeMs);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发送心跳请求</span></span><br><span class="line">    <span class="keyword">this</span>.heartbeatInFly = <span class="keyword">this</span>.rpcService.appendEntries(</span><br><span class="line">            <span class="keyword">this</span>.options.getPeerId().getEndpoint(),</span><br><span class="line">            request,</span><br><span class="line">            <span class="keyword">this</span>.options.getElectionTimeoutMs() / <span class="number">2</span>,</span><br><span class="line">            heartbeatDone);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Follower 节点对于心跳请求的处理逻辑与探针请求一致，所以下面来看一下 Leader 节点对于心跳请求响应的处理流程。对于发送心跳请求而言，JRaft 允许调用方自定义响应回调，目前这一块主要服务于线性一致性读操作，下面来分析一下默认的心跳请求响应回调逻辑，由 <code>Replicator#onHeartbeatReturned</code> 方法实现（省略部分 DEBUG 日志）：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onHeartbeatReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> Status status,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> AppendEntriesRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> AppendEntriesResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime)</span> </span>{</span><br><span class="line">    <span class="comment">// 复制器已经被销毁</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// replicator already was destroyed.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = Utils.nowMs();</span><br><span class="line">    Replicator r;</span><br><span class="line">    <span class="keyword">if</span> ((r = (Replicator) id.lock()) == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// Follower 节点运行异常</span></span><br><span class="line">        <span class="keyword">if</span> (!status.isOk()) {</span><br><span class="line">            r.state = State.Probe;</span><br><span class="line">            notifyReplicatorStatusListener(r, ReplicatorEvent.ERROR, status);</span><br><span class="line">            <span class="keyword">if</span> (++r.consecutiveErrorTimes % <span class="number">10</span> == <span class="number">0</span>) {</span><br><span class="line">                LOG.warn(<span class="string">"Fail to issue RPC to {}, consecutiveErrorTimes={}, error={}"</span>,</span><br><span class="line">                        r.options.getPeerId(), r.consecutiveErrorTimes, status);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 重新启动心跳计时器</span></span><br><span class="line">            r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        r.consecutiveErrorTimes = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 目标 Follower 节点的 term 值更大，说明有新的 Leader 节点</span></span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; r.options.getTerm()) {</span><br><span class="line">            <span class="keyword">final</span> NodeImpl node = r.options.getNode();</span><br><span class="line">            r.notifyOnCaughtUp(RaftError.EPERM.getNumber(), <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 销毁当前复制器</span></span><br><span class="line">            r.destroy();</span><br><span class="line">            <span class="comment">// 递增当前节点的 term 值</span></span><br><span class="line">            node.increaseTermTo(response.getTerm(), <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE,</span><br><span class="line">                    <span class="string">"Leader receives higher term heartbeat_response from peer:%s"</span>, r.options.getPeerId()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Follower 节点拒绝响应，重新发送探针请求，并启动心跳计时器</span></span><br><span class="line">        <span class="keyword">if</span> (!response.getSuccess() &amp;&amp; response.hasLastLogIndex()) {</span><br><span class="line">            LOG.warn(<span class="string">"Heartbeat to peer {} failure, try to send a probe request."</span>, r.options.getPeerId());</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">            r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 RPC 请求时间戳</span></span><br><span class="line">        <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) {</span><br><span class="line">            r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 启动心跳计时器</span></span><br><span class="line">        r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) {</span><br><span class="line">            id.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果目标 Follower 节点运行异常，则不应该更新复制器 Replicator 的 <code>Replicator#lastRpcSendTimestamp</code> 字段，这无可厚非。如果目标 Follower 节点运行正常，但是拒绝当前的心跳请求，按照之前的总结分为以下三种原因：</p>
<ol>
<li>Follower 节点本地的 term 值相对于当前 Leader 节点更大。</li>
<li>Follower 节点本地记录的 Leader 节点 ID 并不是当前 Leader 节点，即可能出现网络分区。</li>
<li>Follower 节点与当前 Leader 节点的日志数据存在冲突。</li>
</ol>
<p>其中只有第三种情况会在响应中携带 Follower 节点的最新 logIndex 值，此时心跳请求会触发向目标 Follower 节点发送探针请求，并在探针请求响应中更新 RPC 发送时间戳。然而，不管是上述哪种原因导致 Follower 节点拒绝响应，亦或是同意响应，复制器 Replicator 都会再次调用 <code>Replicator#startHeartbeatTimer</code> 方法进入下一轮心跳进程。</p>

        <h3 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>本文分析了 JRaft 关于 Raft 算法日志数据复制机制的设计与实现，包括日志的生成过程、探寻待发送的日志位置、复制日志数据、心跳机制，以及 Pipeline 机制等。日志数据复制是 Raft 算法运行的基础，是一项重要且频繁的操作，实现层面的优劣直接影响着 Raft 算法库的运行效率。为此，JRaft 引入了多种优化策略，包括 Follower 节点之间并发复制、批量发送，以及 Pipeline 机制。</p>
<p>关于日志复制，实际上快照机制从广义上来说也属于日志复制范畴，准确来说是对日志复制的有一种优化手段，不过快照机制也有其自身独有的特点和应用场景，并且是一项可选的功能，所以我将其与常规的日志复制区别开来，下一篇将对该机制进行针对性的分析。</p>

        <h3 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h3>
      <ol>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://raft.github.io/">Raft Consensus Algorithm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.sofastack.tech/projects/sofa-jraft/overview/">SOFA-JRaft 官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.sofastack.tech/blog/sofa-jraft-pipeline-principle/">SOFA-JRaft 日志复制：pipeline 实现剖析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2020/06/15/sofa/sofa-jraft-log-replication/">https://plotor.github.io/2020/06/15/sofa/sofa-jraft-log-replication/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/Raft/">Raft</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/SOFA-JRaft/">SOFA-JRaft</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2020/06/22/sofa/sofa-jraft-snapshot/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">SOFA-JRaft 源码解析：快照机制</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2020/06/08/sofa/sofa-jraft-leader-election/"><span class="paginator-prev__text">SOFA-JRaft 源码解析：主节点选举机制</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%94%9F%E6%88%90"><span class="toc-number">1.</span> <span class="toc-text">
          日志生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">
          日志复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipeline-%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">
          Pipeline 机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%8E%A2%E9%92%88"><span class="toc-number">2.2.</span> <span class="toc-text">
          发送探针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-number">2.3.</span> <span class="toc-text">
          复制日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">
          心跳机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">
          总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">95</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2024</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>