<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="到目前为止，我们已经分析了 bean 配置的解析与注册过程。经过这一系列的操作，我们编写在 XML 中的半结构化静态配置已经转换成一个个的 BeanDefinition 实例存在于容器之中，接下来就可以调用 BeanFactory#getBean 方法获取目标 bean 实例。本文我们将从 BeanFactory#getBean 方法出发，探究容器基于 BeanDefinition 创建和初始化">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring IoC 源码解析：创建和初始化 bean 实例">
<meta property="og:url" content="https://plotor.github.io/2017/05/28/spring/spring-ioc-get-bean/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="到目前为止，我们已经分析了 bean 配置的解析与注册过程。经过这一系列的操作，我们编写在 XML 中的半结构化静态配置已经转换成一个个的 BeanDefinition 实例存在于容器之中，接下来就可以调用 BeanFactory#getBean 方法获取目标 bean 实例。本文我们将从 BeanFactory#getBean 方法出发，探究容器基于 BeanDefinition 创建和初始化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/plotor/plotor.github.io/blob/master/images/2017/spring-ioc-bean-factory-flow.png?raw=false">
<meta property="article:published_time" content="2017-05-28T13:56:57.000Z">
<meta property="article:modified_time" content="2025-03-12T02:34:37.287Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/plotor/plotor.github.io/blob/master/images/2017/spring-ioc-bean-factory-flow.png?raw=false"><title>Spring IoC 源码解析：创建和初始化 bean 实例 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2017/05/28/spring/spring-ioc-get-bean/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Spring IoC 源码解析：创建和初始化 bean 实例</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2017-05-28</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">13.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">64分</span></span></div></header><div class="post-body"><p>到目前为止，我们已经分析了 bean 配置的解析与注册过程。经过这一系列的操作，我们编写在 XML 中的半结构化静态配置已经转换成一个个的 BeanDefinition 实例存在于容器之中，接下来就可以调用 <code>BeanFactory#getBean</code> 方法获取目标 bean 实例。本文我们将从 <code>BeanFactory#getBean</code> 方法出发，探究容器基于 BeanDefinition 创建和初始化 bean 实例的过程。<a id="more"></a></p>
<p>下图描绘了从 BeanFactory 中按照 beanName 获取 bean 实例的核心过程：</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://github.com/plotor/plotor.github.io/blob/master/images/2017/spring-ioc-bean-factory-flow.png?raw=false" style="" alt="image">
      </p>
<p>我们可以从整体上将 bean 的生命周期分为 5 个阶段：</p>
<ol>
<li>实例化 bean 对象；</li>
<li>执行属性注入；</li>
<li>执行初始化（调用 <code>InitializingBean#afterPropertiesSet</code> 方法和 <code>init-method</code> 方法）；</li>
<li>使用 bean 实例；</li>
<li>销毁 bean 实例（调用 <code>DisposableBean#destroy</code> 方法和 <code>destroy-method</code> 方法）。</li>
</ol>
<p>Spring 会在 bean 实例的生命周期中设置多个拦截器，主要可以分为以下几类（按照生命周期进行排序）：</p>
<ol>
<li>实例化前置拦截器：我们可以在该拦截器中自定义实例化，从而替换 Spring 自身的实例化操作。</li>
<li>Bean Definition 拦截器：用于在实例化 bean 对象之前对 bean 定义进行拦截修改。</li>
<li>实例化后置拦截器：此时还未执行属性注入，所以我们可以在此实现自定义属性注入逻辑。</li>
<li>属性拦截器：用于在执行属性注入之前对待注入的属性值进行修改。</li>
<li>Aware 拦截器：实现了这类拦截器的 bean 希望在 IoC 容器初始化期间从容器中获取一些属性。</li>
<li>初始化前置拦截器：在执行初始化方法之前对 bean 实例进行拦截处理。</li>
<li>初始化后置拦截器：在执行初始化方法之后对 bean 实例进行拦截处理。</li>
<li>销毁前置拦截器：在销毁 bean 实例之前对 bean 实例进行拦截处理。</li>
</ol>
<p>以上我们从 bean 实例整体生命周期的角度对 IoC 容器从创建到最终销毁一个 bean 实例的过程进行了简单的概括，下面我们将从源码实现的层面去分析 IoC 容器是如何创建并初始化 bean 实例的。</p>
<p>我们从 <code>BeanFactory#getBean</code> 方法切入，Spring 为该方法提供了多种重载和覆盖版本的实现，当我们执行该方法时一般都是由抽象类 AbstractBeanFactory 予以处理。</p>
<p>方法 <code>AbstractBeanFactory#getBean</code> 实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取 name 对应的真正 beanName</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为传入的参数可以是 alias，也可能是 FactoryBean 的 name，所以需要进行解析，包含以下内容：</span></span><br><span class="line"><span class="comment">     * 1. 如果是 FactoryBean，则去掉 “&amp;” 前缀</span></span><br><span class="line"><span class="comment">     * 2. 沿着引用链获取 alias 对应的最终 name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = <span class="keyword">this</span>.transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试从单例集合中获取对应的单实例，</span></span><br><span class="line"><span class="comment">     * 在实例化 bean 的时候可能需要实例化依赖的 bean 对象，Spring 为了避免循环依赖会采用早期引用机制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object sharedInstance = <span class="keyword">this</span>.getSingleton(beanName);</span><br><span class="line">    <span class="comment">// 目标实例已经实例化过</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">                logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 处理 FactoryBean</span></span><br><span class="line">        bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 目标实例不存在</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Fail if we're already creating this bean instance: We're assumably within a circular reference.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isPrototypeCurrentlyInCreation(beanName)) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 只有在单例模式下才会尝试解决循环依赖问题，</span></span><br><span class="line"><span class="comment">             * 对于原型模式，如果存在循环依赖，直接抛出异常</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取父 BeanFactory 实例</span></span><br><span class="line">        BeanFactory parentBeanFactory = <span class="keyword">this</span>.getParentBeanFactory();</span><br><span class="line">        <span class="comment">// 如果已经加载的 bean 定义中不包含目标 bean，则尝试从父 BeanFactory 中获取</span></span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.containsBeanDefinition(beanName)) {</span><br><span class="line">            <span class="comment">// 递归到父 BeanFactory 中进行检索</span></span><br><span class="line">            String nameToLookup = <span class="keyword">this</span>.originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) {</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory)</span><br><span class="line">                        .doGetBean(nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不仅仅是做类型检查，则标记该 bean 即将被创建</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) {</span><br><span class="line">            <span class="keyword">this</span>.markBeanAsCreated(beanName);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 如果存在父 bean，则继承父 bean 定义</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">// 检查 bean 是否是抽象的，如果是则抛出异常</span></span><br><span class="line">            <span class="keyword">this</span>.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加载当前 bean 依赖的 bean 实例</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="comment">// 存在依赖，递归实例化依赖的 bean 实例</span></span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) {</span><br><span class="line">                    <span class="comment">// 检查是否存在循环依赖</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.isDependent(beanName, dep)) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 缓存依赖调用</span></span><br><span class="line">                    <span class="keyword">this</span>.registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="comment">// 初始化依赖的 bean 实例</span></span><br><span class="line">                        <span class="keyword">this</span>.getBean(dep);</span><br><span class="line">                    } <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 创建 bean 实例 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// scope == singleton</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">                sharedInstance = <span class="keyword">this</span>.getSingleton(beanName, () -&gt; {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="comment">// 实例化 bean 对象</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                    } <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        <span class="keyword">this</span>.destroySingleton(beanName); <span class="comment">// 清理工作，从单例缓存中移除</span></span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">                <span class="comment">// 处理 FactoryBean</span></span><br><span class="line">                bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// scope == prototype</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) {</span><br><span class="line">                <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 设置正在创建的状态</span></span><br><span class="line">                    <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">                    <span class="comment">// 创建 bean 实例</span></span><br><span class="line">                    prototypeInstance = <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 处理 FactoryBean</span></span><br><span class="line">                bean = <span class="keyword">this</span>.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// other scope</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; {</span><br><span class="line">                        <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                        } <span class="keyword">finally</span> {</span><br><span class="line">                            <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                    <span class="comment">// 处理 FactoryBean</span></span><br><span class="line">                    bean = <span class="keyword">this</span>.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                } <span class="keyword">catch</span> (IllegalStateException ex) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                            <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>, ex);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">            <span class="keyword">this</span>.cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要求做类型检查，则检查 bean 的实际类型是否是期望的类型，对应 getBean 时指定的 requireType</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 执行类型转换，转换成期望的类型</span></span><br><span class="line">            T convertedBean = <span class="keyword">this</span>.getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        } <span class="keyword">catch</span> (TypeMismatchException ex) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">                logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                        ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>整个方法的执行流程可以概括为：</p>
<ol>
<li>将参数 name 转换成对应的真实 beanName，因为入参可能是 alias，或者是 FactoryBean 的 name；</li>
<li>尝试从单例集合中获取 bean 实例，如果存在则直接返回，否则如果存在循环依赖，则尝试基于提前引用机制予以解决；</li>
<li>如果是获取 prototype 类型对象，则检查依赖关系，防止出现循环依赖；</li>
<li>如果目标 bean 不在当前 BeanFactory 的管辖范围，则尝试从父 BeanFactory 中获取；</li>
<li>如何当前 bean 存在继承关系，则合并父 bean 定义；</li>
<li>如果依赖的 bean 未被实例化，则递归实例化依赖的 bean 对象；</li>
<li>依据 bean 的作用域类型实例化目标 bean 对象；</li>
<li>如果对 bean 类型有要求，则执行类型检查，并按需做类型转换；</li>
<li>返回目标 bean 实例，期间会处理 FactoryBean。</li>
</ol>
<p>接下来我们针对各步骤中的详细过程按照需要进行逐一探究。</p>

        <h3 id="解析-bean-标识">
          <a href="#解析-bean-标识" class="heading-link"><i class="fas fa-link"></i></a>解析 bean 标识</h3>
      <p>我们在调用 <code>BeanFactory#getBean</code> 方法时传递的 name 可以是 bean 的别名，也可以是获取 FactoryBean 实例的 name。所以当我们以 name 为 key 检索 bean 实例的时候，首先需要获取 name 对应的唯一标识 bean 的真正名称 beanName，这一过程位于 <code>AbstractBeanFactory#transformedBeanName</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">transformedBeanName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canonicalName(BeanFactoryUtils.transformedBeanName(name));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现首先会通过 <code>BeanFactoryUtils#transformedBeanName</code> 工具类方法判断是不是获取 FactoryBean 实例，如果是则去掉 name 前面的 <code>&amp;</code> 字符（我们已经在前面的文章中专门介绍了 FactoryBean，不熟悉的读者可以重新回顾一下），然后执行 <code>SimpleAliasRegistry#canonicalName</code> 逻辑：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">canonicalName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">    String canonicalName = name;</span><br><span class="line">    <span class="comment">// Handle aliasing...</span></span><br><span class="line">    String resolvedName;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// 如果是别名，则直接从映射集合中获取对应的 beanName</span></span><br><span class="line">        resolvedName = <span class="keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line">        <span class="keyword">if</span> (resolvedName != <span class="keyword">null</span>) {</span><br><span class="line">            canonicalName = resolvedName;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 遍历寻找真正的 name，可能存在引用链</span></span><br><span class="line">    } <span class="keyword">while</span> (resolvedName != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> canonicalName;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>前面我们在分析默认标签的解析过程时了解到，Spring 会通过调用 <code>SimpleAliasRegistry#registerAlias</code> 方法建立 alias 与 beanName 之间的映射关系，而这一映射关系实际上就是记录在 <code>SimpleAliasRegistry#aliasMap</code> 属性中，所以上述实现实际上就是从该属性中基于 alias 检索 beanName 的过程。</p>
<p>那么，为什么这里当 <code>resolvedName != null</code> 的时候需要继续循环呢？这是因为一个别名所引用的不一定是最终的 beanName，可以是另外一个别名，这个时候就是一个链式引用的场景，我们需要继续沿着引用链往下寻找最终的 beanName。</p>

        <h3 id="检索单实例集合">
          <a href="#检索单实例集合" class="heading-link"><i class="fas fa-link"></i></a>检索单实例集合</h3>
      <p>获取到 beanName 标识之后，容器首先尝试从单例对象集合中获取 bean 实例。我们知道单例对象在容器中只会存在一份，所以首先检查单例集合也符合常理，获取单例对象的方法如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>{</span><br><span class="line">    <span class="comment">// 允许提前引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的第二个参数设置为 true，即 <code>allowEarlyReference=true</code>，表示允许提前引用，此时的 bean 实例虽然已经被创建，但是还未执行初始化。</p>
<p>Spring 中 bean 的依赖关系由开发者控制，具备极大的自由配置空间，如果配置不当可能会导致循环依赖的问题，即 A 依赖于 B，而 B 又依赖于 A。当创建 A 对象的时候，容器检测到引用的 B 还没有实例化，就会转去创建 B 对象；实例化 B 的过程中又会发现 A 还没有实例化完成，从而又回来实例化 A，因此陷入死循环。</p>
<p>Spring 能够解决一些场景下的循环依赖问题，而参数 allowEarlyReference 则在其中起到了关键的作用。方法 <code>DefaultSingletonBeanRegistry#getSingleton(String, boolean)</code> 的具体实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>{</span><br><span class="line">    <span class="comment">// 尝试获取对应的单例对象</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 实例不存在 &amp;&amp; 正在创建中</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) {</span><br><span class="line">            <span class="comment">// 尝试获取早期的实例，此时的实例还未完成初始化</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 如果早期的实例不存在，且允许提前引用，则基于对应的 ObjectFactory 创建</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) {</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) {</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">// earlySingletonObjects 和 singletonFactories 是互斥的</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回目标单例对象，可能为 null</span></span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先尝试从存放单实例的集合 <code>DefaultSingletonBeanRegistry#singletonObjects</code> 中获取实例，这里分为 3 种情况：</p>
<ol>
<li>目标 bean 实例已经存在，说明之前已经实例化过，直接返回即可。</li>
<li>目标 bean 实例不存在，且未处于正在创建中的状态，直接返回 null，接下去会执行实例化进程。</li>
<li>目标 bean 实例不存在，但处于正在创建中的状态，说明存在循环依赖的情况。</li>
</ol>
<p>针对第 3 种情况，Spring 定义了 <code>DefaultSingletonBeanRegistry#earlySingletonObjects</code> 属性，记录那些那些被创建出来还未执行初始化的对象。毕竟，依赖注入的过程是将一个对象的引用赋值给另一个对象的某个属性，并不要求被注入的对象已经完成了初始化。简单而言，就是先把对象间的依赖关系建立好，再去初始化各个对象，这一机制能够在一些场景下破解循环依赖的环路。</p>
<p>以上述 A 和 B 循环引用为例，我们可以先把 A 和 B 的对象先创建完成，期间相互引用的属性先置为 null，这样就不会阻碍这两个对象的创建过程，然后再初始化相互引用的属性值。</p>
<p>由上述实现还可以看到 singletonObjects 和 earlySingletonObjects 这两个属性中记录的实例是互斥的，即一个实例只可能存在于两者中的一个，不可能同时存在，这也是很容易理解的。</p>

        <h3 id="处理-FactoryBean">
          <a href="#处理-FactoryBean" class="heading-link"><i class="fas fa-link"></i></a>处理 FactoryBean</h3>
      <p>如果上一步我们获取到了单例 bean 实例，那么需要接着调用 <code>AbstractBeanFactory#getObjectForBeanInstance</code> 方法处理 FactoryBean。该方法在 <code>AbstractBeanFactory#doGetBean</code> 实现中多次被调用，每次我们获取到 bean 实例之后，不管是从单例集合中获取还是实时创建的各作用域对象，都需执行一次该方法对获取到的实例进行最后的处理。该方法的主要目的是判断当前 bean 实例是否是 FactoryBean，如果是 FactoryBean 实例，且用户又希望获取由该 FactoryBean 所创建的最终 bean 实例，此时就需要调用 <code>FactoryBean#getObject</code> 方法创建最终 bean 实例。</p>
<p>方法 <code>AbstractBeanFactory#getObjectForBeanInstance</code> 的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(Object beanInstance, // bean 实例</span></span></span><br><span class="line"><span class="function"><span class="params">                                          String name, // 请求的 beanName</span></span></span><br><span class="line"><span class="function"><span class="params">                                          String beanName, // 解析后的 beanName</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>{ <span class="comment">// 父 bean 定义</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户期望获取 FactoryBean 实例</span></span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) {</span><br><span class="line">        <span class="comment">// NullBean 是对 null 实例的内部表示</span></span><br><span class="line">        <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) {</span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获取FactoryBean，但是对应的bean并不是FactoryBean类型</span></span><br><span class="line">        <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 标识是 FactoryBean 实例</span></span><br><span class="line">        <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) {</span><br><span class="line">            mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 一个 bean 实例，可以是普通的 bean，也可能是 FactoryBean 实例</span></span><br><span class="line"><span class="comment">     * 该bean实例不是FactoryBean or 本来就是希望获取FactoryBean实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 用户并不期望获取 FactoryBean 实例，且当前 bean 也不是 FactoryBean，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) {</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当前 bean 是 FactoryBean，但用户期望获取由该 FactoryBean 创建的 bean 实例 */</span></span><br><span class="line"></span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 标识是 FactoryBean 实例</span></span><br><span class="line">        mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 尝试从缓存中获取最终 bean 实例</span></span><br><span class="line">        object = <span class="keyword">this</span>.getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于 FactoryBean 获取最终 bean 实例</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) {</span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">        <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.containsBeanDefinition(beanName)) {</span><br><span class="line">            <span class="comment">// 执行对 bean 定义的 merge 操作</span></span><br><span class="line">            mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 是否是用户定义的，而不是应用程序自己定义的</span></span><br><span class="line">        <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        <span class="comment">// 核心实现，基于 FactoryBean 获取最终 bean 实例</span></span><br><span class="line">        object = <span class="keyword">this</span>.getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的实现可以分为四种情况：</p>
<ol>
<li>用户期望获取 FactoryBean 实例，当前 bean 实例是 FactoryBean 类型，直接返回。</li>
<li>用户期望获取 FactoryBean 实例，当前 bean 实例不是 FactoryBean 类型，抛出异常。</li>
<li>用户期望获取最终 bean 实例，当前 bean 实例不是 FactoryBean 类型，直接返回。</li>
<li>用户期望获取最终 bean 实例，当前 bean 实例是 FactoryBean 类型，需要基于 FactoryBean 创建最终 bean 实例。</li>
</ol>
<p>前面三种情况都比较简单，重点看一下第四种情况，这一步的核心在于如何由 FactoryBean 获取到最终的 bean 实例。容器首先会尝试从缓存中获取，因为对于一些单例的 bean 来说，可能之前已经完成了实例化。Spring 定义了 <code>FactoryBeanRegistrySupport#factoryBeanObjectCache</code> 属性，用于记录 FactoryBean 与对应 bean 实例之间的映射关系。如果缓存不命中则执行创建过程，继续执行 <code>FactoryBeanRegistrySupport#getObjectFromFactoryBean</code> 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        FactoryBean&lt;?&gt; factory, // FactoryBean 实例</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, // 真实 beanName</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> shouldPostProcess)</span> <span class="comment">// 是否执行后处理</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 如果是单例，且已经实例化</span></span><br><span class="line">    <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; <span class="keyword">this</span>.containsSingleton(beanName)) {</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getSingletonMutex()) {</span><br><span class="line">            <span class="comment">// 尝试从缓存中获取，key 为 factoryBeanName，value 为由 FactoryBean 创建的 bean 实例</span></span><br><span class="line">            Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (object == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 调用 FactoryBean 的 getObject 方法创建对象</span></span><br><span class="line">                object = <span class="keyword">this</span>.doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">                <span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">                <span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">                Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) {</span><br><span class="line">                    object = alreadyThere;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (shouldPostProcess) {</span><br><span class="line">                        <span class="comment">// 提前引用</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">                            <span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">                            <span class="keyword">return</span> object;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">this</span>.beforeSingletonCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="comment">// 后置处理</span></span><br><span class="line">                            object = <span class="keyword">this</span>.postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                        } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of FactoryBean's singleton object failed"</span>, ex);</span><br><span class="line">                        } <span class="keyword">finally</span> {</span><br><span class="line">                            <span class="keyword">this</span>.afterSingletonCreation(beanName);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 如果最终的 bean 实例已经实例化完成，则缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.containsSingleton(beanName)) {</span><br><span class="line">                        <span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 返回由 FactoryBean 创建的 bean 实例</span></span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 不是单例，或未实例化过</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 调用 FactoryBean 的 getObject 方法创建对象</span></span><br><span class="line">        Object object = <span class="keyword">this</span>.doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">        <span class="keyword">if</span> (shouldPostProcess) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 后置处理</span></span><br><span class="line">                object = <span class="keyword">this</span>.postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of FactoryBean's object failed"</span>, ex);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现对于单例来说保证单例在容器中的唯一性。我们期望的调用 <code>FactoryBean#getObject</code> 方法创建 bean 实例的逻辑位于 <code>FactoryBeanRegistrySupport#doGetObjectFromFactoryBean</code> 方法中。前面的文章已经介绍过 FactoryBean，并演示了 FactoryBean 的使用方法，再来回顾一下 FactoryBean 接口的定义：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="comment">/** 获取由 FactoryBean 创建的目标 bean 实例 */</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">/** 返回目标 bean 类型 */</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    <span class="comment">/** 是否是单实例 */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>FactoryBean 接口声明了三个方法，而 <code>FactoryBean#getObject</code> 方法是用来真正创建对象的地方。当我们在调用 <code>BeanFactory#getBean</code> 方法时如果不加 <code>&amp;</code> 前缀，这个时候该方法可以看作是 <code>FactoryBean#getObject</code> 方法的代理方法，而具体实现就在 <code>FactoryBeanRegistrySupport#doGetObjectFromFactoryBean</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 getObject 方法创建最终 bean 实例，该方法由用户实现</span></span><br><span class="line">    Object object;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) {</span><br><span class="line">            AccessControlContext acc = <span class="keyword">this</span>.getAccessControlContext();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">            } <span class="keyword">catch</span> (PrivilegedActionException pae) {</span><br><span class="line">                <span class="keyword">throw</span> pae.getException();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            object = factory.getObject();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"FactoryBean threw exception on object creation"</span>, ex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not accept a null value for a FactoryBean that's not fully initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// FactoryBean 正在实例化中，此时获取最终 bean 实例太早</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                    <span class="string">"FactoryBean which is currently in creation returned null from getObject"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果用户指定返回 null 值，则使用 NullBean 代替</span></span><br><span class="line">        object = <span class="keyword">new</span> NullBean();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法中执行 <code>FactoryBean#getObject</code> 的实现是我们一层层剥离外表所触及到的核心，该方法的具体实现则交给了开发者。</p>

        <h3 id="实例化-bean-对象">
          <a href="#实例化-bean-对象" class="heading-link"><i class="fas fa-link"></i></a>实例化 bean 对象</h3>
      <p>如果单例集合中不存在目标 bean 实例，那么说明当前 bean 可能是一个非单例对象，或者是一个单例但却是第一次加载。如果将前面的操作看作是获取对象，那么这里就需要真正创建对象了。在开始实例化 bean 之前，需要做如下几件事情：</p>
<ol>
<li>对 prototype 对象的循环依赖进行检查，如果存在则直接抛出异常，而不尝试去解决循环依赖。</li>
<li>检测目标 bean 定义是否属于当前 BeanFactory 的管辖范围，如果不属于且同时存在父 BeanFactory，则委托给父 BeanFactory 进行处理。</li>
<li>检测是不是仅仅做类型检查（eg. <code>BeanFactory#isTypeMatch</code>），如果不是则标记该 bean 即将被创建。</li>
<li>如果存在父 bean，则继承父 bean 定义，并检查 bean 是否是抽象类，如果是则抛出异常。</li>
<li>检查依赖的 bean，如果存在且未实例化，则先递归实例化依赖的 bean 对象。</li>
</ol>
<p>完成了上述准备工作之后，容器依据作用域采取适当的方法创建对应的 bean 实例。由于创建 prototype 类型对象，或其它作用域类型对象与创建 singleton 类型对象大同小异，所以下面以创建 singleton 类型对象为例，分析 bean 对象的实例化过程。</p>
<p>前面分析了从单例缓存集合中获取单例对象的实现，而能够执行到当前位置说明之前的缓存不命中，对应的单例对象还没有创建，需要实例化该对象。该过程位于 <code>DefaultSingletonBeanRegistry#getSingleton</code> 方法中，这是一个重载方法，与前面从缓存中获取单例对象的方法在参数上存在差别，方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>{</span><br><span class="line">    Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) { <span class="comment">// singletonObjects 用于记录 beanName 与已创建的单例对象之间的映射关系</span></span><br><span class="line">        <span class="comment">// 尝试从缓存中获取已经实例化完成的 bean 实例</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 缓存不命中，需要进行实例化</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 目标 bean 正在被销毁，期间不允许创建</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                        <span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line">                                <span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验 bean 是否正在被实例化</span></span><br><span class="line">            <span class="keyword">this</span>.beforeSingletonCreation(beanName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) {</span><br><span class="line">                <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 基于 ObjectFactory 创建 bean 对象</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">catch</span> (IllegalStateException ex) {</span><br><span class="line">                <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                <span class="comment">// 异常，再次尝试从缓存中获取</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (BeanCreationException ex) {</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) {</span><br><span class="line">                    <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) {</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) {</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 后置处理，移除正在被实例化的状态</span></span><br><span class="line">                <span class="keyword">this</span>.afterSingletonCreation(beanName);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新创建的单例，记录到缓存中，并移除中间状态</span></span><br><span class="line">            <span class="keyword">if</span> (newSingleton) {</span><br><span class="line">                <span class="keyword">this</span>.addSingleton(beanName, singletonObject);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回实例</span></span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的执行逻辑还是很直观的，概括如下：</p>
<ol>
<li>检测 bean 是否正在被销毁，如果是则期间不允许重新实例化；</li>
<li>设置 bean 的状态为正在被创建；</li>
<li>实例化 bean 对象；</li>
<li>移除 bean 的正在被创建状态；</li>
<li>将新创建的 bean 实例记录到缓存，并返回该实例。</li>
</ol>
<p>步骤 3 中的实例化 bean 是整个流程的关键所在，这里调用了 <code>ObjectFactory#getObject</code> 方法，由传入的参数我们可以知道该方法的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getSingleton(beanName, () -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">    } <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">        <span class="keyword">this</span>.destroySingleton(beanName); <span class="comment">// 清理工作，从单例缓存中移除</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></div></figure>
<p>所以实例化 bean 的真正逻辑位于 <code>AbstractAutowireCapableBeanFactory#createBean</code> 方法中，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">        logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    }</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.根据设置的 class 属性或 className 解析得到对应的 Class 引用</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = <span class="keyword">this</span>.resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) {</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.校验 lookup-method 和 replaced-method 标签应用的方法是否存在</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    } <span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 应用 InstantiationAwareBeanPostProcessor 处理器</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        Object bean = <span class="keyword">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="comment">// 如果在处理器中已经完成了对 bean 的实例化操作，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建 bean 实例</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Object beanInstance = <span class="keyword">this</span>.doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    } <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) {</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>该方法虽然名字叫 createBean，顾名思义是创建 bean 实例的地方，通过调用 <code>AbstractAutowireCapableBeanFactory#doCreateBean</code> 方法完成对 bean 的实例化。不过，在开始执行创建之前，该方法还做了一些前期准备工作，具体流程如代码注释，下面针对各个过程逐一分析。</p>

        <h4 id="解析-Class-引用">
          <a href="#解析-Class-引用" class="heading-link"><i class="fas fa-link"></i></a>解析 Class 引用</h4>
      <p>不知道你是否还记得，在分析标签解析的过程中对于 class 属性的解析，如果参数中传入了类加载器则会尝试获取对应的 Class 引用，否则直接记录类的全称类名。对于前者而言，这里的解析就是直接返回 Class 引用对象即可，而对于后者则需要解析获取对应的 Class 引用。相关实现位于 <code>AbstractBeanFactory#resolveBeanClass</code> 方法中，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveBeanClass(<span class="keyword">final</span> RootBeanDefinition mbd, String beanName, <span class="keyword">final</span> Class&lt;?&gt;... typesToMatch)</span><br><span class="line">        <span class="keyword">throws</span> CannotLoadBeanClassException {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 如果之前直接存储的是 Class 引用，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.hasBeanClass()) {</span><br><span class="line">            <span class="keyword">return</span> mbd.getBeanClass();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则由 className 解析得到对应的 Class 引用</span></span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;) () -&gt;</span><br><span class="line">                    <span class="keyword">this</span>.doResolveBeanClass(mbd, typesToMatch), <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ... 省略异常处理</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>逻辑很清晰，如果 BeanDefinition 实例中记录已经是 Class 引用，则直接返回即可；否则需要进行解析，具体由 <code>AbstractBeanFactory#doResolveBeanClass</code> 方法实现，该方法会验证类全称类名，并利用类加载器解析获取对应的 Class 引用，具体实现不再展开。</p>

        <h4 id="校验-override-方法">
          <a href="#校验-override-方法" class="heading-link"><i class="fas fa-link"></i></a>校验 override 方法</h4>
      <p>Spring 中并不存在 <code>&lt;override-method /&gt;</code> 标签，这里的 override 指的是 <code>&lt;lookup-method/&gt;</code> 和 <code>&lt;replaced-method/&gt;</code> 这两个标签。之前解析这两个标签时是将标签配置以 MethodOverride 对象的形式记录在 <code>AbstractBeanDefinition#methodOverrides</code> 属性中，而这里的处理逻辑主要是逐一检查被覆盖的方法是否真实存在，如果不存在则说明配置不合法，需要抛出异常；如果存在唯一的方法版本则说明覆盖是明确的，标记 <code>MethodOverride#overloaded</code> 为 false 表明后期无需再依据参数类型和个数进行推测：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>{</span><br><span class="line">    <span class="comment">// Check that lookup methods exist and determine their overloaded status.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasMethodOverrides()) {</span><br><span class="line">        <span class="comment">// 获取之前解析的 &lt;lookup-method/&gt; 和 &lt;replaced-method/&gt; 标签配置，并逐一应用 prepareMethodOverride 方法</span></span><br><span class="line">        <span class="keyword">this</span>.getMethodOverrides().getOverrides().forEach(<span class="keyword">this</span>::prepareMethodOverride);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareMethodOverride</span><span class="params">(MethodOverride mo)</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>{</span><br><span class="line">    <span class="comment">// 获取指定类中指定方法的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = ClassUtils.getMethodCountForName(<span class="keyword">this</span>.getBeanClass(), mo.getMethodName());</span><br><span class="line">    <span class="comment">// 该类并未定义相应名称的方法</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(</span><br><span class="line">                <span class="string">"Invalid method override: no method with name '"</span> + mo.getMethodName() + <span class="string">"' on class ["</span> + <span class="keyword">this</span>.getBeanClassName() + <span class="string">"]"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 该类仅定义了唯一一个相应名称的方法</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 标记 MethodOverride 暂未被重载，避免参数类型检查的开销</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果一个方法存在多个重载版本，那么在调用及增强的时候还需要根据参数类型进行匹配来确认最终调用的方法版本，</span></span><br><span class="line"><span class="comment">         * 如果方法未被重载，也就是对应这里的只有一个版本，就在设置重载标识为 false，后续可以直接定位方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mo.setOverloaded(<span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="实例化前置处理">
          <a href="#实例化前置处理" class="heading-link"><i class="fas fa-link"></i></a>实例化前置处理</h4>
      <p>InstantiationAwareBeanPostProcessor 处理器一般在做基于 Spring 的基础组件研发时用的比较多，先来介绍一下该处理器的作用。该处理器的接口定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 实例化 bean 前调用，是对 bean 定义进行修改的最后机会 */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 实例化 bean 后立即调用，位于属性注入之前 */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 在将属性注入 bean 实例前对属性进行处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 该方法已过期，功能同 postProcessProperties */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由代码注释还是能够清晰的知道这个处理器的功能的。接口中定义的方法紧挨着 bean 实例化的过程，如果我们希望在实例化前后对 bean 对象应用一些修改，可以通过实现该接口并注册到 BeanFactory 中。不过需要注意一点的是处理器会对所有的 bean 实例生效，需要处理好筛选的逻辑。</p>
<p>继续分析对于 InstantiationAwareBeanPostProcessor 处理器的执行逻辑。Spring 首先会去解析 bean 所属的真正 Class 引用，因为可能存在一些工厂 bean，而具体的 bean 类型还需要通过工厂方法去推测。相关实现位于 <code>AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>{</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果 bean 尚未实例化</span></span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {</span><br><span class="line">        <span class="comment">// 当前 bean 不是合成的，且注册了 InstantiationAwareBeanPostProcessor</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) {</span><br><span class="line">            <span class="comment">// 获取最终的 Class 引用，如果是工厂方法则获取工厂所创建的实例类型</span></span><br><span class="line">            Class&lt;?&gt; targetType = <span class="keyword">this</span>.determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 应用实例化前置处理</span></span><br><span class="line">                bean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// 应用实例初始化后置处理</span></span><br><span class="line">                    bean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 标识对于当前 bean 已经应用过该处理器，避免重复应用</span></span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>接着就是调用注册的 InstantiationAwareBeanPostProcessor 处理器在创建 bean 实例之前对 BeanDefinition 进行前置处理，具体实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用实例化前置处理</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历应用注册的 InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation 方法</span></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : <span class="keyword">this</span>.getBeanPostProcessors()) {</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果 InstantiationAwareBeanPostProcessor 在执行前置处理期间完成了对 bean 的实例化操作，则会触发执行 <code>InstantiationAwareBeanPostProcessor#postProcessAfterInitialization</code> 方法（如下），该方法会在完成对 bean 实例的初始化操作之后被调用，而这里对于 bean 实例的创建和初始化均在 <code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code> 中已完成。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="comment">// 遍历应用注册的 InstantiationAwareBeanPostProcessor 的 postProcessAfterInitialization 方法</span></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor processor : <span class="keyword">this</span>.getBeanPostProcessors()) {</span><br><span class="line">        Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        result = current;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>注意这两个方法的后缀一个是 Instantiation，另一个是 Initialization，前者表示创建 bean 实例，后者表示对创建的 bean 实例执行初始化操作。</p>

        <h4 id="创建-bean-实例">
          <a href="#创建-bean-实例" class="heading-link"><i class="fas fa-link"></i></a>创建 bean 实例</h4>
      <p>如果在 <code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code> 方法中完成了实例化 bean 的过程，则直接返回相应的 bean 实例即可，否则就需要继续执行创建 bean 实例的过程，并且大部分 bean 实例都是在这一步完成创建的。实例化 bean 的逻辑还是相当复杂的，由 <code>AbstractAutowireCapableBeanFactory#doCreateBean</code> 方法实现，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 采用合适的方式创建 bean 对象 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取对应的 FactoryBean 的 BeanWrapper 对象，如果存在则基于对应的 FactoryBean 创建 bean 对象</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果对应的 FactoryBean 不存在，则采用适当的策略实例化 bean 对象</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 采用一定的策略创建 bean 实例：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. 如果设置了 instanceSupplier 回调，则基于该 Supplier 获取 bean 对象；</span></span><br><span class="line"><span class="comment">         * 2. 否则，如果指定了工厂方法，则使用工厂方法创建 bean 对象；</span></span><br><span class="line"><span class="comment">         * 3. 否则，调用相应的构造方法创建 bean 对象。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取 bean 实例</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="comment">// 获取 bean 实例对应的 Class 对象</span></span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) {</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 应用 MergedBeanDefinitionPostProcessor 处理器</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) {</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 应用 postProcessMergedBeanDefinition 方法，@Autowired 注解即依赖此处理器实现</span></span><br><span class="line">                <span class="keyword">this</span>.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            }</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 检查是否需要提前曝光 bean 实例，用于解决循环依赖</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() <span class="comment">// 单例</span></span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.allowCircularReferences <span class="comment">// 允许自动解决循环依赖</span></span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)); <span class="comment">// 当前 bean 正在创建中</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName + <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 为避免循环依赖，在完成 bean 实例化之前，将对应的 ObjectFactory 注册到容器中</span></span><br><span class="line">        <span class="keyword">this</span>.addSingletonFactory(beanName,</span><br><span class="line">                <span class="comment">// 获取 bean 的提前引用</span></span><br><span class="line">                () -&gt; <span class="keyword">this</span>.getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 初始化 bean 实例</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 对 bean 进行填充，注入各个属性值，如果存在依赖的 bean 则递归初始化</span></span><br><span class="line">        <span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化 bean，调用初始化方法，比如 init-method</span></span><br><span class="line">        exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 基于依赖关系验证是否存在循环依赖</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line">        <span class="comment">// 获取 bean 实例</span></span><br><span class="line">        Object earlySingletonReference = <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) {</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果不允许注入 raw bean 实例 &amp;&amp; 存在依赖的 bean</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; <span class="keyword">this</span>.hasDependentBean(beanName)) {</span><br><span class="line">                <span class="comment">// 获取依赖的 bean 的 beanName 集合</span></span><br><span class="line">                String[] dependentBeans = <span class="keyword">this</span>.getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="comment">// 遍历逐个检测依赖的 bean 实例，记录未完成创建的 bean 实例</span></span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) {</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 因为 bean 在实例化完成之后，其依赖的 bean 实例一定也是完成实例化的，</span></span><br><span class="line"><span class="comment">                 * 如果 actualDependentBeans 不为空，则说明依赖的 bean 实例没有完成创建，存在循环依赖</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                                    StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                    <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                                    <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                                    <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                                    <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 注册销毁机制</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">this</span>.registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    } <span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的执行流程可以概括为：</p>
<ol>
<li>采用合适的策略创建 bean 实例；</li>
<li>如果注册了 BeanDefinition 处理器，则在初始化 bean 实例之前对相应的 BeanDefinition 实例进行修改；</li>
<li>如果允许自动解决循环依赖，则提前曝光 bean 实例；</li>
<li>初始化 bean 实例，执行属性注入，调用初始化方法；</li>
<li>基于依赖关系验证是否存在未完成初始化的 bean 实例，如果存在则说明存在无法解决的循环依赖，抛出异常；</li>
<li>为实现了销毁逻辑的 bean 注册销毁机制。</li>
</ol>
<p>下面逐步展开分析。首先来看 <strong>步骤一</strong> ，这一步主要用于创建 bean 对象，Spring 在内部定义了 BeanWrapper 接口，用于对 bean 实例进行封装和操作。关于创建 bean 对象的过程，Spring 采取的策略如下：</p>
<ol>
<li>如果是 FactoryBean，则基于 FactoryBean 对象获取最终 bean 实例；</li>
<li>否则，如果设置了 instanceSupplier 回调，则调用 <code>Supplier#get</code> 方法获取 bean 实例；</li>
<li>否则，如果指定了工厂方法，则调用工厂方法创建 bean 实例；</li>
<li>否则，基于参数调用确定版本的构造方法创建 bean 实例。</li>
</ol>
<p>上述过程的后三步由 <code>AbstractAutowireCapableBeanFactory#createBeanInstance</code> 方法实现，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>{</span><br><span class="line">    <span class="comment">// 解析 Class 对象</span></span><br><span class="line">    Class&lt;?&gt; beanClass = <span class="keyword">this</span>.resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="comment">// 不是 public 类，或者对应的构造方法不能访问</span></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 如果设置了 instanceSupplier，则调用 Supplier#get 获取 bean 实例</span></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果指定了工厂方法，则使用工厂方法创建 bean 实例</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 解析并确定构造方法版本，调用构造方法创建 bean 实例</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) {</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) {</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 之前已经解析过构造方法版本，直接复用，避免重复解析</span></span><br><span class="line">    <span class="keyword">if</span> (resolved) {</span><br><span class="line">        <span class="comment">// 使用之前确定的构造方法版本</span></span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 使用默认构造方法</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instantiateBean(beanName, mbd);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依据参数决定使用哪个构造方法</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = <span class="keyword">this</span>.determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR</span><br><span class="line">            || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析构造方法失败，使用首选的构造方法，如果有指定的话</span></span><br><span class="line">    ctors = mbd.getPreferredConstructors();</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认的构造方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instantiateBean(beanName, mbd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>下面进一步说明一下基于工厂方法和基于构造方法创建 bean 对象的过程。如果在配置时使用 factory-method 属性指明了工厂方法，则 Spring 在初始化 IoC 容器时会调用 <code>AbstractAutowireCapableBeanFactory#instantiateUsingFactoryMethod</code> 方法创建 bean 实例，该方法的实现比较冗长，故不在此贴出。总结来说，该方法的主要执行流程如下：</p>
<ol>
<li>确定当前使用的是静态工厂配置，还是非静态工厂配置；</li>
<li>基于参数类型和个数确定用于实例化 bean 的工厂方法版本；</li>
<li>调用工厂方法创建 bean 对象。</li>
</ol>
<p>其中最复杂的是第二步，因为可能存在多个工厂方法的重载版本，所以需要依据给定或配置的参数个数和类型去解析确定具体使用哪个工厂方法。Spring 会对所有的候选工厂方法按照 public 优先，以及参数个数多的方法优先的原则进行排序，然后逐个比对是否满足当前指定的参数列表，依次确定具体使用哪个工厂方法创建 bean 实例。基于构造方法创建 bean 对象的过程与上述过程大同小异，核心都是基于参数个数和类型确定最终调用的方法版本，不再展开。</p>
<p>需要清楚的一点是，经过上述过程创建的 bean 实例，不管是通过工厂方法还是构造方法，到这里得到 bean 实例也仅仅是一个最初实例，接下去还需要对该实例进行初始化，注入相应的属性值等。如果将此时的 bean 实例看作是一张白纸，那么初始化操作就可以类比在白纸上作画，而颜料就是之前解析得到的 BeanDefinition 对象。Spring 定义了 MergedBeanDefinitionPostProcessor 处理器接口，允许用户在容器执行初始化操作之前对最终的 BeanDefinition 对象进行修改。</p>
<p><strong>步骤二</strong> 所做的工作就是应用 MergedBeanDefinitionPostProcessor 处理器，相应的实现位于 <code>AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取并遍历所有的后置处理器</span></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : <span class="keyword">this</span>.getBeanPostProcessors()) {</span><br><span class="line">        <span class="comment">// 如果是 MergedBeanDefinitionPostProcessor，则进行应用 postProcessMergedBeanDefinition 方法</span></span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) {</span><br><span class="line">            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于 singleton 类型对象而言， <strong>步骤三</strong> 会提前曝光 bean 实例，Spring 基于该机制尝试自动解决循环依赖问题。循环依赖可能发生在构造方法注入过程中，也可能发生在 setter 方法注入过程中，对于前者来说 Spring 是无法解决的，对于后者则可以通过提前曝光机制达到“先引用，后初始化”的目的，从而巧妙的破解环路。提前曝光机制的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() <span class="comment">// 单例</span></span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>.allowCircularReferences <span class="comment">// 允许自动解决循环依赖</span></span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)); <span class="comment">// 当前 bean 正在创建中</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">        logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName + <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 为避免循环依赖，在完成 bean 实例化之前，将对应的 ObjectFactory 注册到容器中</span></span><br><span class="line">    <span class="keyword">this</span>.addSingletonFactory(beanName,</span><br><span class="line">            <span class="comment">// 获取 bean 的提前引用</span></span><br><span class="line">            () -&gt; <span class="keyword">this</span>.getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingletonFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>{</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) {</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) {</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>说明一下上述方法中几个变量的含义：</p>
<ul>
<li>singletonObjects：用于记录 beanName 和 bean 实例之间的映射关系。</li>
<li>singletonFactories：用于记录 beanName 和创建 bean 的工厂 ObjectFactory 对象之间的映射关系。</li>
<li>earlySingletonObjects：也是记录 beanName 和 bean 实例之间的映射关系，不同于 singletonObjects，其中记录的 bean 实例在创建过程中就可以通过 getBean 方法获取到。</li>
<li>registeredSingletons：用来记录当前所有已注册的 beanName，按照注册顺序存放。</li>
</ul>
<p>提前曝光也就是在初始化 bean 对象之前曝光该对象，其目的是先创建好对象，再建立依赖关系，将这两步拆分开以破解依赖环路。当初始化一个 bean 对象时，如果引用了另外一个 bean 对象，此时就需要转而去创建并初始化引用的 bean 对象，如果恰好该 bean 对象又引用了之前的 bean 对象就出现了循环依赖。假设我们令第一个 bean 为 A，第二个 bean 为 B，基于这段代码的执行逻辑，B 就可以先给自己类型为 A 的属性注入 A 的实例（这个时候 A 还没有被初始化）然后完成初始化，此时继续回到初始化 A 的逻辑，因为都是单例，所以当 A 完成了初始化之后，B 所引用的 A 对象也就是一个完成了初始化过程的对象，而不是之前的刚刚完成创建还没有注入属性的对象。</p>
<p><strong>步骤四</strong> 实现了对上面创建的 bean 实例执行初始化的逻辑，包括 <strong>属性注入</strong> 和 <strong>调用初始化方法</strong> 两个步骤。先来分析属性注入的过程，该过程由 <code>AbstractAutowireCapableBeanFactory#populateBean</code> 方法实现（populate，这个词很有想象力~）：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>{</span><br><span class="line">    <span class="comment">// 未创建 bean 对象</span></span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 但是存在需要注入的属性</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.hasPropertyValues()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation 方法对初始化前的 bean 实例进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) {</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : <span class="keyword">this</span>.getBeanPostProcessors()) {</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 bean 实例的属性值集合</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取注入类型</span></span><br><span class="line">    <span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">        <span class="comment">// 根据名称注入</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) {</span><br><span class="line">            <span class="keyword">this</span>.autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 根据类型注入</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {</span><br><span class="line">            <span class="keyword">this</span>.autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        }</span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用 InstantiationAwareBeanPostProcessor#postProcessProperties 方法在注入属性之前对属性值进行处理</span></span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) {</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) {</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : <span class="keyword">this</span>.getBeanPostProcessors()) {</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">                <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) {</span><br><span class="line">                        filteredPds = <span class="keyword">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 兼容已过期的方法</span></span><br><span class="line">                    pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                    <span class="comment">// 处理器把属性值处理没了，继续执行属性注入已经没有意义，直接返回</span></span><br><span class="line">                    <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) {</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                pvs = pvsToUse;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖检查，对应 dependency-check 属性，该属性已过期</span></span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) {</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) {</span><br><span class="line">            filteredPds = <span class="keyword">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行属性注入</span></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法会执行 <code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code> 后置处理方法，以实现对完成创建但还未注入属性值的对象进行最后的更改。如果该方法指明不需要执行后续的属性注入过程，则运行到此结束；否则方法会检测当前的注入类型是 <code>byName</code> 还是 <code>byType</code>，并执行对应的注入逻辑获取依赖的属性值。在真正执行注入之前，还会应用 <code>InstantiationAwareBeanPostProcessor#postProcessProperties</code> 处理方法对待注入的属性值执行最后的修改，并依据配置决定是否执行依赖检查，以确保所有的属性都被赋值（这里的赋值是指 BeanDefinition 对象中的属性都有对应的值，而不是指最终 bean 实例的属性是否注入了对应的值）。最后将属性值注入给 bean 实例对应的属性中。</p>
<p>整个流程还是比较清晰的，下面进一步分析基于 name 或 type 解析属性值，以及注入属性值的过程。</p>
<ul>
<li><strong>基于 name 解析属性值</strong></li>
</ul>
<p>如果当前注入类型是 <code>byName</code>，则容器会基于 beanName 获取依赖的 bean 实例，并将依赖关系记录到对应的集合中，如果依赖的 bean 未被实例化则需要转而执行实例化。基于 name 解析属性值的过程由 <code>AbstractAutowireCapableBeanFactory#autowireByName</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取需要注入的属性名称集合</span></span><br><span class="line">    String[] propertyNames = <span class="keyword">this</span>.unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    <span class="keyword">for</span> (String propertyName : propertyNames) {</span><br><span class="line">        <span class="comment">// 当前属性是由容器管理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.containsBean(propertyName)) {</span><br><span class="line">            <span class="comment">// 获取 bean 实例，如果没有实例化则执行实例化操作</span></span><br><span class="line">            Object bean = <span class="keyword">this</span>.getBean(propertyName);</span><br><span class="line">            <span class="comment">// 记录到属性集合中</span></span><br><span class="line">            pvs.add(propertyName, bean);</span><br><span class="line">            <span class="comment">// 记录 bean 之间的依赖关系</span></span><br><span class="line">            <span class="keyword">this</span>.registerDependentBean(propertyName, beanName);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// ... 省略日志打印</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<ul>
<li><strong>基于 type 解析属性值</strong></li>
</ul>
<p>如果当前注入类型是 <code>byType</code>，则容器会依据属性类型去确定依赖的 bean 实例，并将依赖关系记录到对应的集合中，如果依赖的 bean 未被实例化则需要转而执行实例化。因为类型注入需要有一个推断的过程，所以实现逻辑要复杂很多，位于 <code>AbstractAutowireCapableBeanFactory#autowireByType</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>{</span><br><span class="line"></span><br><span class="line">    TypeConverter converter = <span class="keyword">this</span>.getCustomTypeConverter();</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) {</span><br><span class="line">        converter = bw;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 获取需要注入的属性名称集合</span></span><br><span class="line">    String[] propertyNames = <span class="keyword">this</span>.unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    <span class="keyword">for</span> (String propertyName : propertyNames) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line">            <span class="comment">// Don't try autowiring by type for type Object: never makes sense,</span></span><br><span class="line">            <span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line">            <span class="keyword">if</span> (Object.class != pd.getPropertyType()) {</span><br><span class="line">                <span class="comment">// 获取对应的 setter 方法</span></span><br><span class="line">                MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">                <span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line">                <span class="keyword">boolean</span> eager = !(bw.getWrappedInstance() <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">                DependencyDescriptor desc = <span class="keyword">new</span> AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 解析指定 beanName 属性所匹配的值，并把解析到的属性存储在 autowiredBeanNames 中，当属性存在多个候选 bean 时，比如：</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * @Autowired</span></span><br><span class="line"><span class="comment">                 * private List&lt;A&gt; list</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 则会注入找到的所有匹配 A 类型的 bean 实例</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Object autowiredArgument = <span class="keyword">this</span>.resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">                <span class="comment">// 记录到属性集合中</span></span><br><span class="line">                <span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) {</span><br><span class="line">                    pvs.add(propertyName, autowiredArgument);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 记录 bean 之间的依赖关系</span></span><br><span class="line">                <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) {</span><br><span class="line">                    <span class="keyword">this</span>.registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">                }</span><br><span class="line">                autowiredBeanNames.clear();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Nullable</span> String requestingBeanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并初始化参数名称探测器</span></span><br><span class="line">    descriptor.initParameterNameDiscovery(<span class="keyword">this</span>.getParameterNameDiscoverer());</span><br><span class="line">    <span class="comment">// 支持 java8 的 Optional</span></span><br><span class="line">    <span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 对应 ObjectFactory 类注入的特殊处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType()</span><br><span class="line">            || ObjectProvider.class == descriptor.getDependencyType()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 支持 javax.inject.Provider</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 通用处理逻辑</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Object result = <span class="keyword">this</span>.getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, requestingBeanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) {</span><br><span class="line">            result = <span class="keyword">this</span>.doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于通用处理逻辑而言，Spring 的解析过程如下：</p>
<ol>
<li>以确定的 <code>@Value</code> 注解和集合类型进行解析，如果不是这些类型则获取匹配类型的 bean 实例集合；</li>
<li>如果存在多个匹配项则尝试以优先级配置（比如 Primary 或 Priority）确定首选的 bean 实例，否则无需做推断逻辑；</li>
<li>检测当前解析得到的 bean 是不是期望的 bean 实例，如果是工厂之类的 bean，则还要继续获取工厂所创建的 bean 实例。</li>
</ol>
<ul>
<li><strong>注入属性值</strong></li>
</ul>
<p>执行到这一步才真正将 bean 的所有属性全部注入到 bean 实例中，之前虽然已经创建了实例，但是属性仍存在于 BeanDefinition 实例中。注入的过程由 <code>AbstractAutowireCapableBeanFactory#applyPropertyValues</code> 方法实现，该方法会将相应属性转换成目标 bean 实例中对应属性的真实类型，并注入到对应属性上：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (pvs.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) {</span><br><span class="line">        ((BeanWrapperImpl) bw).setSecurityContext(<span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 记录待执行类型转换的属性值</span></span><br><span class="line">    List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) {</span><br><span class="line">        mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">        <span class="comment">// 之前已经完成了类型转换，直接注入</span></span><br><span class="line">        <span class="keyword">if</span> (mpvs.isConverted()) {</span><br><span class="line">            <span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                bw.setPropertyValues(mpvs);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            } <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                        mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        original = mpvs.getPropertyValueList();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TypeConverter converter = <span class="keyword">this</span>.getCustomTypeConverter();</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) {</span><br><span class="line">        converter = bw;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建属性值解析器</span></span><br><span class="line">    BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">    List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line">    <span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 遍历属性值，执行类型转换</span></span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : original) {</span><br><span class="line">        <span class="comment">// 已经转换过</span></span><br><span class="line">        <span class="keyword">if</span> (pv.isConverted()) {</span><br><span class="line">            deepCopy.add(pv);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 未转换，执行类型转换</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            String propertyName = pv.getName();</span><br><span class="line">            Object originalValue = pv.getValue();</span><br><span class="line">            <span class="keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) {</span><br><span class="line">                Method writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();</span><br><span class="line">                <span class="keyword">if</span> (writeMethod == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Autowire marker for property without write method: "</span> + pv);</span><br><span class="line">                }</span><br><span class="line">                originalValue = <span class="keyword">new</span> DependencyDescriptor(<span class="keyword">new</span> MethodParameter(writeMethod, <span class="number">0</span>), <span class="keyword">true</span>);</span><br><span class="line">            }</span><br><span class="line">            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">            Object convertedValue = resolvedValue;</span><br><span class="line">            <span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName)</span><br><span class="line">                    &amp;&amp; !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">            <span class="comment">// 判定可以转换，执行转换</span></span><br><span class="line">            <span class="keyword">if</span> (convertible) {</span><br><span class="line">                convertedValue = <span class="keyword">this</span>.convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line">            <span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line">            <span class="comment">// 转换后的值等于原始值</span></span><br><span class="line">            <span class="keyword">if</span> (resolvedValue == originalValue) {</span><br><span class="line">                <span class="keyword">if</span> (convertible) {</span><br><span class="line">                    pv.setConvertedValue(convertedValue);</span><br><span class="line">                }</span><br><span class="line">                deepCopy.add(pv);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 转换后的类型不是集合和数组类型</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue</span><br><span class="line">                    &amp;&amp; !((TypedStringValue) originalValue).isDynamic()</span><br><span class="line">                    &amp;&amp; !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) {</span><br><span class="line">                pv.setConvertedValue(convertedValue);</span><br><span class="line">                deepCopy.add(pv);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 未解析完全（对应集合或数组类型），标记需要继续解析</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">                deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记已经全部转换完成</span></span><br><span class="line">    <span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) {</span><br><span class="line">        mpvs.setConverted();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置属性值，深拷贝</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">    } <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>完成了属性注入过程，接下来容器会执行指定的 init-method 方法。不过，Spring 并不是单纯的调用一下对应的初始化方法，在 <code>AbstractAutowireCapableBeanFactory#initializeBean</code> 实现中主要做了 4 件事情：</p>
<ol>
<li>激活 bean 实现的 Aware 类，包括 BeanNameAware、BeanClassLoaderAware，以及 BeanFactoryAware；</li>
<li>应用 <code>BeanPostProcessor#postProcessBeforeInitialization</code> 方法，实现初始化前置处理；</li>
<li>调用用户自定义的 init-method 方法，以及常用的 <code>InitializingBean#afterPropertiesSet</code> 方法；</li>
<li>应用 <code>BeanPostProcessor#postProcessAfterInitialization</code> 方法，实现初始化后置处理。</li>
</ol>
<p>方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>{</span><br><span class="line">    <span class="comment">// 1. 激活 bean 实现的 Aware 类：BeanNameAware, BeanClassLoaderAware, BeanFactoryAware</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) {</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {</span><br><span class="line">            <span class="keyword">this</span>.invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">this</span>.invokeAwareMethods(beanName, bean);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 应用 BeanPostProcessor#postProcessBeforeInitialization 方法</span></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">        wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 调用用户自定义的 init-method 方法，以及常用的 afterPropertiesSet 方法</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">this</span>.invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException((mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>), beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用 BeanPostProcessor#postProcessAfterInitialization 方法</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">        wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>到此，一个 bean 也就基本实例化完成了。在返回该 bean 实例之前，为了确保正确性，Spring 会基于依赖关系检测当前 bean 所依赖的 bean 实例是否都已经实例化完成（ <strong>步骤五</strong> ），如果存在未完成实例化的 bean 则说明配置存在问题，需要抛出异常。这种情况通常都是循环依赖所导致的，这对于使用 Spring 的正确运行而言是一个极大的隐患，所以需要确保所有实例化的 bean 都完成了对象的创建和初始化过程，否则应用不应该正常启动。</p>
<p>对于配置了 destroy-method 属性的 bean，或者该 bean 实现了 DisposableBean 或 DestructionAwareBeanPostProcessor 接口，那么在返回 bean 实例之前，Spring 还需要为该 bean 注册销毁机制（ <strong>步骤六</strong> ）。以常用的 DisposableBean 接口为例，当执行销毁一个实现了该接口的 bean 实例时，相应的 <code>DisposableBean#destroy</code> 方法会被调用。对应的注册过程由 <code>AbstractBeanFactory#registerDisposableBeanIfNecessary</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDisposableBeanIfNecessary</span><span class="params">(String beanName, Object bean, RootBeanDefinition mbd)</span> </span>{</span><br><span class="line">    AccessControlContext acc = (System.getSecurityManager() != <span class="keyword">null</span> ? <span class="keyword">this</span>.getAccessControlContext() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isPrototype() &amp;&amp; <span class="keyword">this</span>.requiresDestruction(bean, mbd)) {</span><br><span class="line">        <span class="comment">// singleton 类型</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">            <span class="comment">// Register a DisposableBean implementation that performs all destruction</span></span><br><span class="line">            <span class="comment">// work for the given bean: DestructionAwareBeanPostProcessors, DisposableBean interface, custom destroy method.</span></span><br><span class="line">            <span class="keyword">this</span>.registerDisposableBean(beanName,</span><br><span class="line">                    <span class="keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, <span class="keyword">this</span>.getBeanPostProcessors(), acc));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 其它作用域</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// A bean with a custom scope...</span></span><br><span class="line">            Scope scope = <span class="keyword">this</span>.scopes.get(mbd.getScope());</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + mbd.getScope() + <span class="string">"'"</span>);</span><br><span class="line">            }</span><br><span class="line">            scope.registerDestructionCallback(beanName,</span><br><span class="line">                    <span class="keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, <span class="keyword">this</span>.getBeanPostProcessors(), acc));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>以 singleton 类型为例，如果一个 bean 需要注册销毁机制，那么 Spring 会以 beanName 为 key，以包装销毁逻辑的 DisposableBeanAdapter 对象为 value 记录到 <code>DefaultSingletonBeanRegistry#disposableBeans</code> 属性中。当相应的 bean 被销毁时，容器就会尝试获取对应的 DisposableBeanAdapter 实例，并执行销毁逻辑。</p>

        <h3 id="类型检查和转换">
          <a href="#类型检查和转换" class="heading-link"><i class="fas fa-link"></i></a>类型检查和转换</h3>
      <p>在调用 <code>BeanFactory#getBean(String name, Class&lt;T&gt; requiredType)</code> 方法获取 bean 实例，或者做类型检查时，可以指定期望的 bean 类型。如果指定该参数则容器在创建和初始化 bean 对象的最后一步需要执行类型校验，并尝试将 bean 实例转换成期望类型，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要求做类型检查，则检查 bean 的实际类型是否是期望的类型，对应 getBean 时指定的 requireType</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 执行类型转换，转换成期望的类型</span></span><br><span class="line">        T convertedBean = <span class="keyword">this</span>.getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> convertedBean;</span><br><span class="line">    } <span class="keyword">catch</span> (TypeMismatchException ex) {</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                    ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>转换的过程还是比较复杂的，鉴于本篇已经写的够长了，就不再展开啦。</p>

        <h3 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>至此，我们已经完成了对 <code>BeanFactory#getBean</code> 完整过程的分析。回顾过去这几篇文章，我们探究了容器加载、解析配置文件得到 BeanDefinition 实例，并基于该实例创建、初始化得到目标 bean 实例的过程。虽然 Spring 暴露的使用方式只有短短几行，但是背后却暗藏着十分复杂的逻辑。实际中我们一般不会直接使用 BeanFactory 操作容器，使用更多的是 ApplicationContext 对象，下一篇我们将继续探究基于 ApplicationContext 的 bean 的加载和初始化过程。</p>

        <h3 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h3>
      <ol>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/25866350/">Spring 源码深度解析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2017/05/28/spring/spring-ioc-get-bean/">https://plotor.github.io/2017/05/28/spring/spring-ioc-get-bean/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/Spring/">Spring</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2017/06/03/spring/spring-ioc-application-context/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Spring IoC 源码解析：高级容器的初始化过程</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2017/05/19/spring/spring-ioc-custom-element/"><span class="paginator-prev__text">Spring IoC 源码解析：自定义标签的解析过程</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-bean-%E6%A0%87%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">
          解析 bean 标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E5%8D%95%E5%AE%9E%E4%BE%8B%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">
          检索单实例集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-FactoryBean"><span class="toc-number">3.</span> <span class="toc-text">
          处理 FactoryBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-bean-%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">
          实例化 bean 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-Class-%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">
          解析 Class 引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C-override-%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">
          校验 override 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">
          实例化前置处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-bean-%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.4.</span> <span class="toc-text">
          创建 bean 实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">
          类型检查和转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">
          总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">7.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">95</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2025</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>