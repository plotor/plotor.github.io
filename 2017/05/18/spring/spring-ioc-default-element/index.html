<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="上一篇我们梳理了容器初始化的整体流程，了解了一个 bean 是如何从静态配置变为一个可运行的实例的，但是对于过程中涉及到的具体细节并未进行深入探究。从本篇开始，我们将回到起点重新沿着主线走一遍，与之前不同的是，这一次我们更加关注细节。 由前面的分析我们已经大致知晓 IoC 容器在初始化期间主要分为两个阶段：加载并解析配置文件和初始化 bean 实例。本文所要介绍的对于默认标签的解析发生在加载并解析">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring IoC 源码解析：默认标签的解析过程">
<meta property="og:url" content="https://plotor.github.io/2017/05/18/spring/spring-ioc-default-element/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="上一篇我们梳理了容器初始化的整体流程，了解了一个 bean 是如何从静态配置变为一个可运行的实例的，但是对于过程中涉及到的具体细节并未进行深入探究。从本篇开始，我们将回到起点重新沿着主线走一遍，与之前不同的是，这一次我们更加关注细节。 由前面的分析我们已经大致知晓 IoC 容器在初始化期间主要分为两个阶段：加载并解析配置文件和初始化 bean 实例。本文所要介绍的对于默认标签的解析发生在加载并解析">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-05-18T15:52:25.000Z">
<meta property="article:modified_time" content="2024-09-17T09:05:22.510Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary"><title>Spring IoC 源码解析：默认标签的解析过程 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2017/05/18/spring/spring-ioc-default-element/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Spring IoC 源码解析：默认标签的解析过程</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2017-05-18</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">11.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">61分</span></span></div></header><div class="post-body"><p>上一篇我们梳理了容器初始化的整体流程，了解了一个 bean 是如何从静态配置变为一个可运行的实例的，但是对于过程中涉及到的具体细节并未进行深入探究。从本篇开始，我们将回到起点重新沿着主线走一遍，与之前不同的是，这一次我们更加关注细节。</p>
<p>由前面的分析我们已经大致知晓 IoC 容器在初始化期间主要分为两个阶段：加载并解析配置文件和初始化 bean 实例。本文所要介绍的对于默认标签的解析发生在加载并解析配置文件阶段，以 XML 配置为例，容器会将 XML 形式的静态配置解析成对应的 BeanDefinition 对象注册到容器中。在配置方面，Spring 为开发者提供了许多可用的标签，比如 <code>&lt;beans /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;import /&gt;</code>，以及 <code>&lt;alias /&gt;</code> 等等。这些标签统称为 <strong>默认标签</strong> （个人觉得翻译成内置标签更加合理），同时 Spring 还允许开发者自己定义标签，方法 <code>DefaultBeanDefinitionDocumentReader#parseBeanDefinitions</code> 中的逻辑就是判断当前标签是默认标签还是自定义标签，并调用相应的方法对标签进行解析（实现如下），本篇我们主要分析默认标签的解析过程，对于自定义标签则留到下一篇进行讲解。<a id="more"></a></p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>{</span><br><span class="line">    <span class="comment">// 解析默认标签</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) {</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) {</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="comment">// 解析默认标签</span></span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) {</span><br><span class="line">                    <span class="keyword">this</span>.parseDefaultElement(ele, delegate);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 解析自定义标签</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析自定义标签</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>我们在上一篇中已经和上述方法打过照面，如果不清楚该方法的调用时机，可以重新阅读一下。</p>
<p>本文，我们主要关注 <code>DefaultBeanDefinitionDocumentReader#parseDefaultElement</code> 方法。该方法用于对默认标签进行解析，整个方法的逻辑很清晰，判断当前的标签类型，然后调用对应的解析器去做解析处理，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>{</span><br><span class="line">    <span class="comment">// 处理 import 标签，该标签用于引入其它的 xml 配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {</span><br><span class="line">        <span class="keyword">this</span>.importBeanDefinitionResource(ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 处理 alias 标签，该标签用于为 bean 配置别名</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {</span><br><span class="line">        <span class="keyword">this</span>.processAliasRegistration(ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 处理 bean 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {</span><br><span class="line">        <span class="keyword">this</span>.processBeanDefinition(ele, delegate);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 处理 beans 标签，即在 &lt;beans /&gt; 中再嵌套 &lt;beans /&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {</span><br><span class="line">        <span class="comment">// recurse</span></span><br><span class="line">        <span class="keyword">this</span>.doRegisterBeanDefinitions(ele);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法按照标签类型分而治之，下面逐个探究各个标签的解析过程。</p>

        <h3 id="标签-bean-的解析过程">
          <a href="#标签-bean-的解析过程" class="heading-link"><i class="fas fa-link"></i></a>标签 bean 的解析过程</h3>
      <p>标签 <code>&lt;bean/&gt;</code> 是基于 XML 进行配置时使用频次最多的标签，所以我们首先从这里开挖。该标签对应的处理方法是 <code>DefaultBeanDefinitionDocumentReader#processBeanDefinition</code>，先来总览一下整个方法的执行逻辑：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>{</span><br><span class="line">    <span class="comment">// 1. 解析 bean 元素，包括 id、name、alias 和 class</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 2. 如果默认标签下有自定义标签，则进行解析</span></span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 3. 注册解析得到的 BeanDefinitionHolder</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, <span class="keyword">this</span>.getReaderContext().getRegistry());</span><br><span class="line">        } <span class="keyword">catch</span> (BeanDefinitionStoreException ex) {</span><br><span class="line">            <span class="keyword">this</span>.getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> + bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 4. 发出响应事件，通知相关监听器这个 bean 定义已经加载完了</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这里的实现只是为了扩展，Spring 自己并没有对注册实现做任何逻辑处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的执行流程可以概括为：</p>
<ol>
<li>解析各个默认标签元素，将配置语义转换成 BeanDefinition 对象，并记录到 BeanDefinitionHolder 中；</li>
<li>检查当前标签下是否有自定义标签元素，若存在则进行解析；</li>
<li>注册由前两步得到的 BeanDefinitionHolder 对象；</li>
<li>发布事件，通知相应的监听者当前 bean 的默认标签已经解析完成。</li>
</ol>

        <h4 id="解析默认标签元素">
          <a href="#解析默认标签元素" class="heading-link"><i class="fas fa-link"></i></a>解析默认标签元素</h4>
      <p>默认标签元素的解析位于 <code>DefinitionParserDelegate#parseBeanDefinitionElement</code> 方法中，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 id 属性</span></span><br><span class="line">    String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    <span class="comment">// 获取 name 属性</span></span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果配置了多个 name（以逗号、分号，或者空格分隔），则解析成 List</span></span><br><span class="line">    List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) {</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有配置 id 属性，但配置了至少一个 name，则以第一个 name 作为 id</span></span><br><span class="line">    String beanName = id;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {</span><br><span class="line">        beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 name 和 alias 的在容器中的唯一性</span></span><br><span class="line">    <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 bean 标签，使用 GenericBeanDefinition 对象封装</span></span><br><span class="line">    AbstractBeanDefinition beanDefinition = <span class="keyword">this</span>.parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 未设置 beanName，按照规则自动生成一个</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) {</span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                            beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">                    <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">                    <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length()</span><br><span class="line">                            &amp;&amp; !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                <span class="keyword">this</span>.error(ex.getMessage(), ele);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        <span class="comment">// 使用 BeanDefinitionHolder 对象封装解析后的信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述解析 <code>&lt;bean /&gt;</code> 标签的执行过程可以概括为：</p>
<ol>
<li>获取 id 和 name 属性，并检查属性值在整个配置中的唯一性；</li>
<li>解析其它属性元素，封装成 GenericBeanDefinition 对象；</li>
<li>Spring 会以 id 或第一个 name 值作为 bean 的唯一标识（即 beanName），如果没有设置则依据命名规则自动生成一个；</li>
<li>将解析得到的 BeanDefinition 实例、beanName，以及 alias 列表封装成 BeanDefinitionHolder 对象返回。</li>
</ol>
<p>整个过程中最核心的步骤是第 2 步，这一步完成了由配置到 BeanDefinition 实例的转换，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈，用于发生异常时打印异常链</span></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 class 属性</span></span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) {</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 parent 属性</span></span><br><span class="line">    String parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) {</span><br><span class="line">        parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 创建 BeanDefinition 对象，采用 GenericBeanDefinition 实现类</span></span><br><span class="line">        AbstractBeanDefinition bd = <span class="keyword">this</span>.createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 &lt;bean/&gt; 标签的各种属性元素</span></span><br><span class="line">        <span class="keyword">this</span>.parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        <span class="comment">// 获取并设置 description 属性</span></span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析元数据子标签 &lt;meta key="" value=""/&gt;</span></span><br><span class="line">        <span class="keyword">this</span>.parseMetaElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 lookup-method 子标签</span></span><br><span class="line">        <span class="keyword">this</span>.parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 replaced-method 子标签</span></span><br><span class="line">        <span class="keyword">this</span>.parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析构造方法参数</span></span><br><span class="line">        <span class="keyword">this</span>.parseConstructorArgElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 property 子标签</span></span><br><span class="line">        <span class="keyword">this</span>.parsePropertyElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 qualifier 子标签</span></span><br><span class="line">        <span class="keyword">this</span>.parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">        <span class="keyword">this</span>.error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">    } <span class="keyword">catch</span> (NoClassDefFoundError err) {</span><br><span class="line">        <span class="keyword">this</span>.error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">this</span>.error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法会先获取配置的 class 和 parent 属性值，然后基于这两个值创建最初的 BeanDefinition 对象：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> String parentName)</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">    <span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">            parentName, className, <span class="keyword">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.BeanDefinitionReaderUtils#createBeanDefinition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> String parentName, <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">    <span class="comment">// 创建 GenericBeanDefinition 对象</span></span><br><span class="line">    GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">    <span class="comment">// 设置 parent 属性</span></span><br><span class="line">    bd.setParentName(parentName);</span><br><span class="line">    <span class="comment">// 设置 class 属性</span></span><br><span class="line">    <span class="keyword">if</span> (className != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果指定了类加载器，则基于此类加载器解析 className 对应的 Class 对象</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) {</span><br><span class="line">            bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            bd.setBeanClassName(className);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由上述实现可以看到，这里创建的 BeanDefinition 对象是 GenericBeanDefinition 类型，并设置对象的 <code>GenericBeanDefinition#parentName</code> 属性。如果指定了类加载器，则基于该类加载器获取 bean 对应的 Class 对象，并设置 <code>AbstractBeanDefinition#beanClass</code> 属性，否则直接将 bean 的 className 记录到该属性上。</p>

        <h5 id="解析属性元素">
          <a href="#解析属性元素" class="heading-link"><i class="fas fa-link"></i></a>解析属性元素</h5>
      <p>接下来，Spring 会去解析 <code>&lt;bean /&gt;</code> 标签中的各种属性配置，并依据获取到的属性值去设置上面创建的 GenericBeanDefinition 对象。相关实现位于 <code>BeanDefinitionParserDelegate#parseBeanDefinitionAttributes</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionAttributes</span><span class="params">(Element ele,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            <span class="meta">@Nullable</span> BeanDefinition containingBean,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            AbstractBeanDefinition bd)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性 singleton 已经过时，推荐使用 scope 属性</span></span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {</span><br><span class="line">        <span class="keyword">this</span>.error(<span class="string">"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration"</span>, ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析并设置 scope 属性</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) {</span><br><span class="line">        bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 当前 bean 没有指定 scope，如果传入了containingBean，则继承其scope</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// Take default from containing bean in case of an inner bean definition.</span></span><br><span class="line">        bd.setScope(containingBean.getScope());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并设置 abstract 属性</span></span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {</span><br><span class="line">        bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并设置 lazy-init 属性（false、true、default）</span></span><br><span class="line">    String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isDefaultValue(lazyInit)) {</span><br><span class="line">        <span class="comment">// 如果是默认配置，则继承 default-lazy-init</span></span><br><span class="line">        lazyInit = <span class="keyword">this</span>.defaults.getLazyInit();</span><br><span class="line">    }</span><br><span class="line">    bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并设置 autowire 属性</span></span><br><span class="line">    String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line">    bd.setAutowireMode(<span class="keyword">this</span>.getAutowireMode(autowire));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并设置 depends-on 属性</span></span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {</span><br><span class="line">        String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">        <span class="comment">// 多个 depends 以逗号、分号，或空格分隔</span></span><br><span class="line">        bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并设置 autowire-candidate 属性</span></span><br><span class="line">    String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isDefaultValue(autowireCandidate)) {</span><br><span class="line">        String candidatePattern = <span class="keyword">this</span>.defaults.getAutowireCandidates();</span><br><span class="line">        <span class="keyword">if</span> (candidatePattern != <span class="keyword">null</span>) {</span><br><span class="line">            String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">            bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并设置 primary 属性</span></span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {</span><br><span class="line">        bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并设置 init-method 属性</span></span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {</span><br><span class="line">        String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line">        bd.setInitMethodName(initMethodName);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 尝试使用 default-init-method 配置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.defaults.getInitMethod() != <span class="keyword">null</span>) {</span><br><span class="line">        bd.setInitMethodName(<span class="keyword">this</span>.defaults.getInitMethod());</span><br><span class="line">        bd.setEnforceInitMethod(<span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并设置 destroy-method 属性</span></span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {</span><br><span class="line">        String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">        bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 尝试使用 default-destroy-method 配置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.defaults.getDestroyMethod() != <span class="keyword">null</span>) {</span><br><span class="line">        bd.setDestroyMethodName(<span class="keyword">this</span>.defaults.getDestroyMethod());</span><br><span class="line">        bd.setEnforceDestroyMethod(<span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并设置 factory-method 属性</span></span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {</span><br><span class="line">        bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并设置 factory-bean 属性</span></span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {</span><br><span class="line">        bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>整个方法解析了 <code>&lt;bean /&gt;</code> 标签所有的属性，包括常用和不常用的，虽然实现很长，但是都是在做一件事情，即判断是否配置了相应的属性，如果配置了则解析并记录到 BeanDefinition 对象中。对于部分具备继承性质的属性，如果没有配置则沿用上游配置的值。下面选择几个不是特别常用的属性举例说明一下。</p>
<ul>
<li><strong>abstract</strong></li>
</ul>
<p>属性 abstract 与 parent 属性组合使用，让配置具备继承性质。如果多个 bean 在配置上存在大量的重复，这个时候就可以考虑使用继承的配置，抽象出重复的属性配置在父 bean 中，而子 bean 则配置特有的属性，如下：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"abstractCar"</span> <span class="attr">class</span>=<span class="string">"org.zhenchao.spring.ioc.Car"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">p:brand</span>=<span class="string">"benz"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"whiteCar"</span> <span class="attr">parent</span>=<span class="string">"abstractCar"</span> <span class="attr">p:color</span>=<span class="string">"white"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blackCar"</span> <span class="attr">parent</span>=<span class="string">"abstractCar"</span> <span class="attr">p:color</span>=<span class="string">"black"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>通过 <code>abstract="true"</code> 属性将父 bean 置为抽象，然后在子 bean 中利用 parent 属性进行引用，这样相同的属性只需要配置一份即可。</p>
<ul>
<li><strong>autowire-candidate</strong></li>
</ul>
<p>在自动注入时，有时候往往存在多个候选的注入对象，Spring 在无法确定正确的候选者时就会抛出 UnsatisfiedDependencyException 异常，这个时候我们可以将某个或多个候选者配置为 <code>autowire-candidate=false</code>，从而剥夺其候选者的身份。</p>
<ul>
<li><strong>primary</strong></li>
</ul>
<p>属性 primary 的功能类似于 autowire-candidate，后者是剥夺某个 bean 的自动注入候选者身份，但是如果存在多个候选者时，一个个的配置会比较麻烦，这个时候我们可以使用 primary 属性将某个候选 bean 设置为 <code>primary=true</code>，这样就使得该 bean 在候选时具备了最高优先级。</p>

        <h5 id="解析子标签元素">
          <a href="#解析子标签元素" class="heading-link"><i class="fas fa-link"></i></a>解析子标签元素</h5>
      <p>标签 <code>&lt;bean /&gt;</code> 除了提供了大量的属性配置外，还允许我们在该标签中配置子标签，Spring 内置了多种子标签，下面对各个子标签的功能和解析过程逐一分析。</p>
<ul>
<li><strong>解析 meta 标签</strong></li>
</ul>
<p>标签 meta 使用的不多，这个配置最终会记录到 BeanDefinition 实例中。假设有如下配置：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"org.zhenchao.spring.ioc.MyBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"meta_name"</span> <span class="attr">value</span>=<span class="string">"zhenchao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>那么我们可以通过如下方式从 bean 对应的 BeanDefinition 实例中获取配置的 meta 值：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> BeanDefinition definition = beanFactory.getBeanDefinition(<span class="string">"myBean"</span>);</span><br><span class="line"><span class="keyword">final</span> Object metaName = definition.getAttribute(<span class="string">"meta_name"</span>);</span><br></pre></td></tr></tbody></table></div></figure>
<p>通过分析源码我们可以清晰看到 <code>&lt;meta /&gt;</code> 标签解析和记录的过程，位于 <code>BeanDefinitionParserDelegate#parseMetaElements</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseMetaElements</span><span class="params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取当前结点下的所有子标签</span></span><br><span class="line">    NodeList nl = ele.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="comment">// 如果是 &lt;meta/&gt; 标签则进行解析</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isCandidateElement(node) &amp;&amp; <span class="keyword">this</span>.nodeNameEquals(node, META_ELEMENT)) {</span><br><span class="line">            Element metaElement = (Element) node;</span><br><span class="line">            <span class="comment">// 获取配置的 key 属性</span></span><br><span class="line">            String key = metaElement.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">            <span class="comment">// 获取配置的 value 属性</span></span><br><span class="line">            String value = metaElement.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">            <span class="comment">// 使用 BeanMetadataAttribute 对象进行封装</span></span><br><span class="line">            BeanMetadataAttribute attribute = <span class="keyword">new</span> BeanMetadataAttribute(key, value);</span><br><span class="line">            attribute.setSource(<span class="keyword">this</span>.extractSource(metaElement));</span><br><span class="line">            <span class="comment">// 记录到 BeanDefinition 的属性集合中</span></span><br><span class="line">            attributeAccessor.addMetadataAttribute(attribute);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由上述实现可以看到，容器是将 <code>&lt;meta /&gt;</code> 标签配置值通过 BeanMetadataAttribute 对象进行封装，并调用 <code>BeanMetadataAttributeAccessor#addMetadataAttribute</code> 方法记录到 attributes 属性中。该属性是一个 map 型的对象，而我们之所以可以从 BeanDefinition 实例中获取到配置值，是因为 BeanDefinition 继承自 BeanMetadataAttributeAccessor 类。</p>
<ul>
<li><strong>解析 lookup-method 标签</strong></li>
</ul>
<p>标签 <code>&lt;lookup-method /&gt;</code> 一般用于希望在一个 singleton 对象中获取一个 prototype 对象的场景。假如我们在一个 singleton 对象中寄希望每次调用 getter 方法时获取一个 prototype 类型的新对象，因为外围 bean 实例是 singleton 类型的，其属性也都只有一份，所以不可能每次都返回 prototype 类型属性的新实例，此时我们就可以使用 <code>&lt;lookup-method /&gt;</code> 标签来达到目的。示例如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrototypeBean prototypeBean;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrototypeBean <span class="title">getPrototypeBean</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> prototypeBean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrototypeBean</span><span class="params">(PrototypeBean prototypeBean)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.prototypeBean = prototypeBean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>MyBean 为 singleton 类型，虽然 PrototypeBean 是 prototype 的，但是我们每次调用 <code>MyBean#getPrototypeBean</code> 方法返回的仍然是同一个对象，这个时候就可以使用 <code>&lt;lookup-method /&gt;</code> 标签：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"prototype-bean"</span> <span class="attr">class</span>=<span class="string">"org.zhenchao.spring.ioc.PrototypeBean"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"org.zhenchao.spring.ioc.MyBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"getPrototypeBean"</span> <span class="attr">bean</span>=<span class="string">"prototype-bean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>标签 <code>&lt;lookup-method /&gt;</code>  让 <code>MyBean#getPrototypeBean</code> 方法每次都会去调用一遍 prototype 对象，从而每次都返回新的对象。该标签的解析位于 <code>BeanDefinitionParserDelegate#parseLookupOverrideSubElements</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseLookupOverrideSubElements</span><span class="params">(Element beanEle, MethodOverrides overrides)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取当前结点下的所有子标签</span></span><br><span class="line">    NodeList nl = beanEle.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="comment">// 如果是 &lt;lookup-method /&gt; 标签则进行解析</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isCandidateElement(node) &amp;&amp; <span class="keyword">this</span>.nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="comment">// 获取配置的 name 属性</span></span><br><span class="line">            String methodName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">            <span class="comment">// 获取配置的 bean 属性</span></span><br><span class="line">            String beanRef = ele.getAttribute(BEAN_ELEMENT);</span><br><span class="line">            <span class="comment">// 使用 LookupOverride 对象进行封装</span></span><br><span class="line">            LookupOverride override = <span class="keyword">new</span> LookupOverride(methodName, beanRef);</span><br><span class="line">            override.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">            <span class="comment">// 记录到 BeanDefinition 的 overrides 属性中</span></span><br><span class="line">            overrides.addOverride(override);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的执行逻辑主要是解析 <code>&lt;lookup-method&gt;</code> 标签配置封装成 LookupOverride 对象，并调用 <code>MethodOverrides#addOverride</code> 方法将该对象添加到 overrides 属性中，这是一个线程安全的 Set 集合。实现每次返回一个新对象的机制是通过覆盖目标 bean 的对应方法，在每次调用该方法时都创建一个被引用 bean 的新实例。</p>
<ul>
<li><strong>解析 replaced-method 标签</strong></li>
</ul>
<p>标签 <code>&lt;replaced-method /&gt;</code> 顾名思义，是用来替换一个方法的实现。如果希望替换 MyBean 的如下方法：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">originalMethod</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"This is original method."</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>我们首先需要定义一个实现了 MethodReplacer 接口的 bean，并实现 <code>MethodReplacer#reimplement</code> 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodReplacer</span> <span class="keyword">implements</span> <span class="title">MethodReplacer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        System.out.println(<span class="string">"This is replaced method."</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>然后利用 <code>&lt;replaced-method /&gt;</code> 子标签进行配置：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"method-replacer"</span> <span class="attr">class</span>=<span class="string">"org.zhenchao.spring.ioc.MyMethodReplacer"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"org.zhenchao.spring.ioc.MyBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"originalMethod"</span> <span class="attr">replacer</span>=<span class="string">"method-replacer"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>这样在调用 <code>MyBean#originalMethod</code> 方法时，本质上是在调用 <code>MyMethodReplacer#reimplement</code>  方法。该标签的解析位于 parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseReplacedMethodSubElements</span><span class="params">(Element beanEle, MethodOverrides overrides)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取当前结点下的所有子标签</span></span><br><span class="line">    NodeList nl = beanEle.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="comment">// 如果是 &lt;replaced-method /&gt; 标签则进行解析</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isCandidateElement(node) &amp;&amp; <span class="keyword">this</span>.nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {</span><br><span class="line">            Element replacedMethodEle = (Element) node;</span><br><span class="line">            <span class="comment">// 获取配置的 name 属性</span></span><br><span class="line">            String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">            <span class="comment">// 获取配置的 replacer 属性</span></span><br><span class="line">            String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);</span><br><span class="line">            <span class="comment">// 使用 ReplaceOverride 对象进行封装</span></span><br><span class="line">            ReplaceOverride replaceOverride = <span class="keyword">new</span> ReplaceOverride(name, callback);</span><br><span class="line">            <span class="comment">// 如果配置了 &lt;arg-type /&gt; 子标签，则进行解析</span></span><br><span class="line">            List&lt;Element&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);</span><br><span class="line">            <span class="keyword">for</span> (Element argTypeEle : argTypeEles) {</span><br><span class="line">                String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);</span><br><span class="line">                match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasText(match)) {</span><br><span class="line">                    replaceOverride.addTypeIdentifier(match);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            replaceOverride.setSource(<span class="keyword">this</span>.extractSource(replacedMethodEle));</span><br><span class="line">            <span class="comment">// 记录到 BeanDefinition 的 overrides 属性中</span></span><br><span class="line">            overrides.addOverride(replaceOverride);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于 <code>&lt;replaced-method /&gt;</code> 标签的解析类似于 <code>&lt;lookup-method /&gt;</code> 标签，不过标签 <code>&lt;replaced-method /&gt;</code> 在替换方法时可能存在多个方法的重载版本，这个时候就需要通过参数类型进一步确认，所以实现时增加了对于参数类型配置的解析逻辑。</p>
<ul>
<li><strong>解析构造函数参数标签</strong></li>
</ul>
<p>构造函数标签 <code>&lt;constructor-arg /&gt;</code> 是我们常用的标签，也是三种依赖注入方式之一。使用示例：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--参数配置顺序并不能决定在构造方法中的匹配顺序--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"long"</span> <span class="attr">value</span>=<span class="string">"100001"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"zhenchao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>配置顺序与构造方法中参数定义顺序没有直接关系，所以大部分时候都可能会映射错误，此时我们可以凭借 index 属性和 type 属性从两个维度上做唯一性限制。标签 <code>&lt;constructor-arg /&gt;</code> 可以看作是 <code>&lt;property /&gt;</code> 标签的一种特殊形式，在实现上复用了解析 <code>&lt;property /&gt;</code> 标签的实现，这些复用的实现将留到后面分析 <code>&lt;property /&gt;</code> 标签时再展开。该标签的解析实现位于 <code>BeanDefinitionParserDelegate#parseConstructorArgElements</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取当前结点下的所有子标签</span></span><br><span class="line">    NodeList nl = beanEle.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="comment">// 如果是 &lt;constructor-arg/&gt; 标签则进行解析</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isCandidateElement(node) &amp;&amp; <span class="keyword">this</span>.nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {</span><br><span class="line">            <span class="keyword">this</span>.parseConstructorArgElement((Element) node, bd);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 index 属性</span></span><br><span class="line">    String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line">    <span class="comment">// 获取 type 属性</span></span><br><span class="line">    String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">    <span class="comment">// 获取 name 属性</span></span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置了 index 属性</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">int</span> index = Integer.parseInt(indexAttr);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">this</span>.error(<span class="string">"'index' cannot be lower than 0"</span>, ele);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry(index));</span><br><span class="line">                    <span class="comment">// 解析标签元素，复用 &lt;property/&gt; 标签的解析过程</span></span><br><span class="line">                    Object value = <span class="keyword">this</span>.parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">                    ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">                    <span class="comment">// 设置 type 属性</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) {</span><br><span class="line">                        valueHolder.setType(typeAttr);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 设置 name 属性</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) {</span><br><span class="line">                        valueHolder.setName(nameAttr);</span><br><span class="line">                    }</span><br><span class="line">                    valueHolder.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">                    <span class="comment">// 不允许有重复的 index</span></span><br><span class="line">                    <span class="keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {</span><br><span class="line">                        <span class="keyword">this</span>.error(<span class="string">"Ambiguous constructor-arg entries for index "</span> + index, ele);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// 记录 index 对应的构造参数 ValueHolder 对象</span></span><br><span class="line">                        bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (NumberFormatException ex) {</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"Attribute 'index' of tag 'constructor-arg' must be an integer"</span>, ele);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 未配置 index 属性</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry());</span><br><span class="line">            <span class="comment">// 解析标签元素，复用 &lt;property/&gt; 标签的解析过程</span></span><br><span class="line">            Object value = <span class="keyword">this</span>.parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">            ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">            <span class="comment">// 设置 type 属性</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) {</span><br><span class="line">                valueHolder.setType(typeAttr);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 设置 name 属性</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) {</span><br><span class="line">                valueHolder.setName(nameAttr);</span><br><span class="line">            }</span><br><span class="line">            valueHolder.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">            <span class="comment">// 依据 type 或 name 做参数映射</span></span><br><span class="line">            bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>标签 <code>&lt;constructor-arg /&gt;</code> 的解析过程中首先会获取 index、type 和 name 三个属性，然后依据是否设置了 index 属性分成两部分。如果设置了 index 属性，则整个解析过程如下：</p>
<ol>
<li>解析 <code>&lt;constructor-arg /&gt;</code> 标签元素，这里复用了 <code>&lt;property /&gt;</code> 标签的解析过程；</li>
<li>利用 ValueHolder 封装解析出来的元素值，如果设置 type 和 name 属性则记录到到 ValueHolder 对象中；</li>
<li>检查是否存在重复的 index 配置，没有则以 index 为 key，将 ValueHolder 对象以 Map 的形式记录到 BeanDefinition 实例中。</li>
</ol>
<p>如果没有设置 index 属性，则整个解析过程如下：</p>
<ol>
<li>解析 <code>&lt;constructor-arg /&gt;</code> 标签元素，这里复用了 <code>&lt;property /&gt;</code> 标签的解析过程；</li>
<li>利用 ValueHolder 封装解析出来的元素值，如果设置 type 和 name 属性则记录到到 ValueHolder 对象中；</li>
<li>以 type 或 name 去推断当前 ValueHolder 对象所对应的参数，并以 List 的形式记录到 BeanDefinition 实例中。</li>
</ol>
<p>上述步骤 3 的源码如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addGenericArgumentValue</span><span class="params">(ValueHolder newValue)</span> </span>{</span><br><span class="line">    Assert.notNull(newValue, <span class="string">"ValueHolder must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.genericArgumentValues.contains(newValue)) {</span><br><span class="line">        <span class="keyword">this</span>.addOrMergeGenericArgumentValue(newValue);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOrMergeGenericArgumentValue</span><span class="params">(ValueHolder newValue)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (newValue.getName() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果在册的参数对象存在与当前相同的参数名称，则尝试 merge 操作</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;ValueHolder&gt; it = <span class="keyword">this</span>.genericArgumentValues.iterator(); it.hasNext(); ) {</span><br><span class="line">            ValueHolder currentValue = it.next();</span><br><span class="line">            <span class="comment">// name 相同</span></span><br><span class="line">            <span class="keyword">if</span> (newValue.getName().equals(currentValue.getName())) {</span><br><span class="line">                <span class="keyword">if</span> (newValue.getValue() <span class="keyword">instanceof</span> Mergeable) {</span><br><span class="line">                    Mergeable mergeable = (Mergeable) newValue.getValue();</span><br><span class="line">                    <span class="keyword">if</span> (mergeable.isMergeEnabled()) {</span><br><span class="line">                        newValue.setValue(mergeable.merge(currentValue.getValue()));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                it.remove();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.genericArgumentValues.add(newValue);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法会去检查当前 ValueHolder 对象是否之前有加载过，没有则判断当前参数是否设置了 name 属性，如果有设置且当前 ValueHolder 对象与已有的 ValueHolder 对象存在相同的 name，则尝试对这个两个对象执行 merge 操作，最后记录 ValueHolder 对象到 <code>ConstructorArgumentValues#genericArgumentValues</code> 属性中，这是一个 List 类型属性。</p>
<p>标签 <code>&lt;constructor-arg /&gt;</code> 的解析过程还是相当复杂的，这里面有相当一部分逻辑复用了 <code>&lt;property /&gt;</code> 标签的解析过程。</p>
<ul>
<li><strong>解析 property 标签</strong></li>
</ul>
<p>标签 <code>&lt;property /&gt;</code> 应该是 <code>&lt;bean /&gt;</code> 标签中最常用的子标签，配置方式相当多元化，并且包含丰富的子标签元素。该标签的解析位于 <code>BeanDefinitionParserDelegate#parsePropertyElements</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取当前结点下的所有子标签</span></span><br><span class="line">    NodeList nl = beanEle.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="comment">// 如果是 &lt;property/&gt; 标签则进行解析</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isCandidateElement(node) &amp;&amp; <span class="keyword">this</span>.nodeNameEquals(node, PROPERTY_ELEMENT)) {</span><br><span class="line">            <span class="keyword">this</span>.parsePropertyElement((Element) node, bd);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 name 属性值</span></span><br><span class="line">    String propertyName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(propertyName)) {</span><br><span class="line">        <span class="keyword">this</span>.error(<span class="string">"Tag 'property' must have a 'name' attribute"</span>, ele);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> PropertyEntry(propertyName));</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// name 必须是唯一的</span></span><br><span class="line">        <span class="keyword">if</span> (bd.getPropertyValues().contains(propertyName)) {</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"Multiple 'property' definitions for property '"</span> + propertyName + <span class="string">"'"</span>, ele);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获取 value 值</span></span><br><span class="line">        Object val = <span class="keyword">this</span>.parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">        PropertyValue pv = <span class="keyword">new</span> PropertyValue(propertyName, val);</span><br><span class="line">        <span class="comment">// 解析 &lt;meta/&gt; 子标签</span></span><br><span class="line">        <span class="keyword">this</span>.parseMetaElements(ele, pv);</span><br><span class="line">        pv.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">        <span class="comment">// 记录到 BeanDefinition 实例中</span></span><br><span class="line">        bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先会去获取 <code>&lt;property /&gt;</code> 标签的 name 属性，并确保 name 配置在 <code>&lt;bean /&gt;</code> 标签范围内的唯一性；然后调用 <code>BeanDefinitionParserDelegate#parsePropertyValue</code> 方法解析标签值，接着调用 <code>BeanDefinitionParserDelegate#parseMetaElements</code> 方法来解析标签内的 <code>&lt;meta /&gt;</code> 子标签，这个与之前 <code>&lt;bean /&gt;</code> 标签的 <code>&lt;meta /&gt;</code> 子标签的解析过程是一样的，唯一的区别在于这里将最终的解析结果存放到 PropertyValue 实例中，不过最终该实例还是交由 BeanDefinition 实例持有。</p>
<p>下面的示例演示了在 <code>&lt;property /&gt;</code> 标签下嵌入 <code>&lt;meta /&gt;</code> 子标签，假设我们为 <code>MyBean#age</code> 属性配置了 meta：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"org.zhenchao.spring.ioc.MyBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"26"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"age-meta-key"</span> <span class="attr">value</span>=<span class="string">"age-meta-value"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>那么我们可以通过如下方式获取到该 meta 值：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> BeanDefinition beanDefinition = beanFactory.getBeanDefinition(<span class="string">"myBean"</span>);</span><br><span class="line"><span class="keyword">final</span> String metaValue = beanDefinition.getPropertyValues().getPropertyValue(<span class="string">"age"</span>).getMetadataAttribute(<span class="string">"age-meta-key"</span>).getValue();</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述过程的核心在于解析 <code>&lt;property /&gt;</code> 标签的 value 配置，即 <code>BeanDefinitionParserDelegate#parsePropertyValue</code> 方法，这也是之前在分析 <code>&lt;constructor-arg /&gt;</code> 标签时留着没有分析的方法，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, <span class="meta">@Nullable</span> String propertyName)</span> </span>{</span><br><span class="line">    String elementName = (propertyName != <span class="keyword">null</span> ? <span class="string">"&lt;property&gt; element for property '"</span> + propertyName + <span class="string">"'"</span> : <span class="string">"&lt;constructor-arg&gt; element"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should only have one child element: ref, value, list, etc.</span></span><br><span class="line">    NodeList nl = ele.getChildNodes();</span><br><span class="line">    Element subElement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="comment">// 跳过 description 和 meta 属性</span></span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !<span class="keyword">this</span>.nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp; !<span class="keyword">this</span>.nodeNameEquals(node, META_ELEMENT)) {</span><br><span class="line">            <span class="comment">// 一个 &lt;property/&gt; 标签只能对应一种类型：ref, value, list, etc.</span></span><br><span class="line">            <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">this</span>.error(elementName + <span class="string">" must not contain more than one sub-element"</span>, ele);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                subElement = (Element) node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ref 属性</span></span><br><span class="line">    <span class="keyword">boolean</span> hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">    <span class="comment">// 获取 value 属性</span></span><br><span class="line">    <span class="keyword">boolean</span> hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> ((hasRefAttribute &amp;&amp; hasValueAttribute) <span class="comment">// 不能既配置了 ref，又配置了 value</span></span><br><span class="line">            || ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != <span class="keyword">null</span>)) <span class="comment">// 配置了 ref 或 value 属性，但是又配置了子标签</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.error(elementName + <span class="string">" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element"</span>, ele);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并解析 ref 属性</span></span><br><span class="line">    <span class="keyword">if</span> (hasRefAttribute) {</span><br><span class="line">        String refName = ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(refName)) {</span><br><span class="line">            <span class="keyword">this</span>.error(elementName + <span class="string">" contains empty 'ref' attribute"</span>, ele);</span><br><span class="line">        }</span><br><span class="line">        RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</span><br><span class="line">        ref.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取并解析 value 配置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) {</span><br><span class="line">        TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">        valueHolder.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">        <span class="keyword">return</span> valueHolder;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析子标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parsePropertySubElement(subElement, bd);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 非法配置</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Neither child element nor "ref" or "value" attribute found.</span></span><br><span class="line">        <span class="keyword">this</span>.error(elementName + <span class="string">" must specify a ref or value"</span>, ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>标签 <code>&lt;property /&gt;</code> 的配置方式分为三种：<code>&lt;property name="" value=""/&gt;</code>、<code>&lt;property name="" ref=""/&gt;</code>，以及 <code>&lt;property name=""&gt;&lt;/property&gt;</code>，并且同一时刻只能使用其中的一种方式，上述方法也是针对这三种配置分而治之。</p>
<p>如果配置方式是 <code>&lt;property name="" ref=""/&gt;</code>，则获取并解析 ref 属性值封装成 RuntimeBeanReference 对象返回。如果配置方式是 <code>&lt;property name="" value=""/&gt;</code>，则获取并解析 value 值封装成 TypedStringValue 对象返回。而对于 <code>&lt;property name=""&gt;&lt;/property&gt;</code> 方式来说，因为配置的多元化，Spring 采用专门的方法 <code>BeanDefinitionParserDelegate#parsePropertySubElement</code> 对其进行解析处理：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parsePropertySubElement(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition bd, <span class="meta">@Nullable</span> String defaultValueType)</span> </span>{</span><br><span class="line">    <span class="comment">// 自定义标签</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isDefaultNamespace(ele)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseNestedCustomElement(ele, bd);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 嵌套的 &lt;bean/&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodeNameEquals(ele, BEAN_ELEMENT)) {</span><br><span class="line">        BeanDefinitionHolder nestedBd = <span class="keyword">this</span>.parseBeanDefinitionElement(ele, bd);</span><br><span class="line">        <span class="keyword">if</span> (nestedBd != <span class="keyword">null</span>) {</span><br><span class="line">            nestedBd = <span class="keyword">this</span>.decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nestedBd;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析 &lt;ref/&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodeNameEquals(ele, REF_ELEMENT)) {</span><br><span class="line">        <span class="comment">// 获取 bean 属性</span></span><br><span class="line">        String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">boolean</span> toParent = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 未配置 bean 属性，尝试获取并解析 parent 属性</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(refName)) {</span><br><span class="line">            <span class="comment">// A reference to the id of another bean in a parent context.</span></span><br><span class="line">            refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">            toParent = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasLength(refName)) {</span><br><span class="line">                <span class="keyword">this</span>.error(<span class="string">"'bean' or 'parent' is required for &lt;ref&gt; element"</span>, ele);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(refName)) {</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"&lt;ref&gt; element contains empty target attribute"</span>, ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName, toParent);</span><br><span class="line">        ref.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析 &lt;idref/&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodeNameEquals(ele, IDREF_ELEMENT)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseIdRefElement(ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析 &lt;value/&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodeNameEquals(ele, VALUE_ELEMENT)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseValueElement(ele, defaultValueType);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析 &lt;null/&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodeNameEquals(ele, NULL_ELEMENT)) {</span><br><span class="line">        <span class="comment">// It's a distinguished null value. Let's wrap it in a TypedStringValue</span></span><br><span class="line">        <span class="comment">// object in order to preserve the source location.</span></span><br><span class="line">        TypedStringValue nullHolder = <span class="keyword">new</span> TypedStringValue(<span class="keyword">null</span>);</span><br><span class="line">        nullHolder.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">        <span class="keyword">return</span> nullHolder;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析 &lt;array/&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodeNameEquals(ele, ARRAY_ELEMENT)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseArrayElement(ele, bd);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析 &lt;list/&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodeNameEquals(ele, LIST_ELEMENT)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseListElement(ele, bd);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析 &lt;set/&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodeNameEquals(ele, SET_ELEMENT)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseSetElement(ele, bd);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析 &lt;map/&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodeNameEquals(ele, MAP_ELEMENT)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseMapElement(ele, bd);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析 &lt;props/&gt; 标签</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodeNameEquals(ele, PROPS_ELEMENT)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parsePropsElement(ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 未知的标签</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">this</span>.error(<span class="string">"Unknown property sub-element: ["</span> + ele.getNodeName() + <span class="string">"]"</span>, ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的逻辑还是很清楚的，即判断当前标签类型，然后调用对应的解析方法进行针对性的处理。当前标签可以是自定义标签，也可以是默认标签，甚至是两种标签类型的多层嵌套，而 Spring 的实现也是采用方法的嵌套来处理复杂的配置。</p>
<p>对于 <code>&lt;ref /&gt;</code> 标签来说，提供的使用方式有 <code>&lt;ref bean="..." /&gt;</code> 和 <code>&lt;ref parent="..." /&gt;</code> 两种类型，这两种配置的区别如下：</p>
<ul>
<li><code>&lt;ref bean="ref-bean"/&gt;</code> 表示可以引用同一容器或父容器中的 bean，这是最常用的形式。</li>
<li><code>&lt;ref parent="ref-bean"/&gt;</code> 表示引用父容器中的 bean。</li>
</ul>
<p>对于剩余的标签而言，除了 <code>&lt;idref /&gt;</code>、<code>&lt;value /&gt;</code> 和 <code>&lt;null /&gt;</code>，其余的基本都是对集合类型的处理，对应的实现逻辑都比较清晰，这里不再深入。</p>
<ul>
<li><strong>解析 qualifier 标签</strong></li>
</ul>
<p>注解 <code>@Qualifier</code> 在日常使用中较为常用，标签 <code>&lt;qualifier /&gt;</code> 的作用与其相同，但是在配置中我们一般较少使用。该标签的解析实现位于 <code>BeanDefinitionParserDelegate#parseQualifierElements</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseQualifierElements</span><span class="params">(Element beanEle, AbstractBeanDefinition bd)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取当前结点下的所有子标签</span></span><br><span class="line">    NodeList nl = beanEle.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="comment">// 如果是 &lt;qualifier/&gt; 标签则进行解析</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isCandidateElement(node) &amp;&amp; <span class="keyword">this</span>.nodeNameEquals(node, QUALIFIER_ELEMENT)) {</span><br><span class="line">            <span class="keyword">this</span>.parseQualifierElement((Element) node, bd);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseQualifierElement</span><span class="params">(Element ele, AbstractBeanDefinition bd)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 type 属性</span></span><br><span class="line">    String typeName = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(typeName)) {</span><br><span class="line">        <span class="keyword">this</span>.error(<span class="string">"Tag 'qualifier' must have a 'type' attribute"</span>, ele);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> QualifierEntry(typeName));</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 封装 &lt;qualifier/&gt; 标签配置</span></span><br><span class="line">        AutowireCandidateQualifier qualifier = <span class="keyword">new</span> AutowireCandidateQualifier(typeName);</span><br><span class="line">        qualifier.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">        <span class="comment">// 获取并设置 value 属性</span></span><br><span class="line">        String value = ele.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(value)) {</span><br><span class="line">            qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并解析 &lt;attribute/&gt; 子标签</span></span><br><span class="line">        NodeList nl = ele.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isCandidateElement(node) &amp;&amp; <span class="keyword">this</span>.nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) {</span><br><span class="line">                Element attributeEle = (Element) node;</span><br><span class="line">                <span class="comment">// 获取配置的 key 属性</span></span><br><span class="line">                String attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">                <span class="comment">// 获取配置的 value 属性</span></span><br><span class="line">                String attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasLength(attributeName) &amp;&amp; StringUtils.hasLength(attributeValue)) {</span><br><span class="line">                    <span class="comment">// 封装 &lt;attribute/&gt; 标签配置，并记录到 qualifier 对象中</span></span><br><span class="line">                    BeanMetadataAttribute attribute = <span class="keyword">new</span> BeanMetadataAttribute(attributeName, attributeValue);</span><br><span class="line">                    attribute.setSource(<span class="keyword">this</span>.extractSource(attributeEle));</span><br><span class="line">                    qualifier.addMetadataAttribute(attribute);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">this</span>.error(<span class="string">"Qualifier 'attribute' tag must have a 'name' and 'value'"</span>, attributeEle);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 记录 qualifier 对象到 BeanDefinition 中</span></span><br><span class="line">        bd.addQualifier(qualifier);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述解析过程的逻辑比较简单，通过 AutowireCandidateQualifier 对象对 <code>&lt;qualifier /&gt;</code> 标签及其子标签进行封装，然后记录到 BeanDefinition 实例中。</p>
<p>至此，默认标签中的默认元素都已经全部解析完成，并设置到 GenericBeanDefinition 对象的相应属性中，该对象会被记录到 BeanDefinitionHolder 对象中返回，最后再回顾一下我们最开始出发的地方：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="解析自定义标签">
          <a href="#解析自定义标签" class="heading-link"><i class="fas fa-link"></i></a>解析自定义标签</h4>
      <p>上一节我们介绍了 Spring 对于默认标签的解析过程，实际上在默认标签作用域内，Spring 还允许我们按照规范自定义标签。在开始分析自定义标签的解析过程之前，我们先来简单介绍一下自定义标签的用法，可能很多人还从来没有自定义过属于自己的标签。</p>
<p>需要注意的一点是，这里我们自定义的标签与下一篇讲解的与默认标签对标的自定义标签并不是同一概念，这里的自定义标签是嵌套在默认标签内的，更准确的说是一种 <strong>自定义属性标签</strong> 。自定义的过程分为如下几步：</p>
<ol>
<li>创建标签实体类；</li>
<li>定义标签的描述 XSD 文件；</li>
<li>创建一个标签元素解析器，实现 BeanDefinitionDecorator 接口；</li>
<li>创建一个 handler 类，继承自 NamespaceHandlerSupport；</li>
<li>编写 spring.handlers 和 spring.schemas 文件。</li>
</ol>
<p>下面通过自定义一个简化版的 <code>&lt;property /&gt;</code> 标签演示自定义和使用的过程，该自定义标签包含 name 和 value 两个属性，目的是将 value 值注入到 bean 对应的名为 name 值的属性中。</p>
<p>第一步，先定义一个 <code>&lt;property /&gt;</code> 标签对应的 POJO 类：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Property</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>第二步，定义标签的 XSD 文件，以约束配置：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">targetNamespace</span>=<span class="string">"http://www.zhenchao.org/schema/property"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tns</span>=<span class="string">"http://www.zhenchao.org/schema/property"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">complexType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">"value"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>第三步，创建标签元素解析器，这里需要实现 BeanDefinitionDecorator 接口。解析器用于对标签配置属性进行解析，并设置到 BeanDefinition 实例的属性集合中，后续在执行 <code>BeanFactory#getBean</code> 时容器会将属性集合中的值赋值给 bean 实例：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyBeanDefinitionDecorator</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDecorator</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorate</span><span class="params">(Node node, BeanDefinitionHolder definition, ParserContext parserContext)</span> </span>{</span><br><span class="line">        Element element = (Element) node;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"mytag:property"</span>.equals(element.getNodeName())) {</span><br><span class="line">            String name = element.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">            Assert.hasText(name, <span class="string">"The 'name' in 'mytag:property' is missing!"</span>);</span><br><span class="line">            String value = element.getAttribute(<span class="string">"value"</span>);</span><br><span class="line">            Assert.hasText(value, <span class="string">"The 'value' in 'mytag:property' is missing!"</span>);</span><br><span class="line">            PropertyValue propertyValue = <span class="keyword">new</span> PropertyValue(name, value);</span><br><span class="line">            definition.getBeanDefinition().getPropertyValues().addPropertyValue(propertyValue);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>第四步，创建一个继承自 NamespaceHandlerSupport 抽象类的 handler 类，用于注册上面定义的解析器：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.registerBeanDefinitionDecorator(<span class="string">"property"</span>, <span class="keyword">new</span> PropertyBeanDefinitionDecorator());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>第五步，编写 spring.handlers 和 spring.schemas 文件，放于 META-INF 目录下面，内容如下：</p>
<ul>
<li>spring.handlers</li>
</ul>
<figure class="highlight text"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://www.zhenchao.org/schema/property=org.zhenchao.handler.PropertyNamespaceHandler</span><br></pre></td></tr></tbody></table></div></figure>
<ul>
<li>spring.schemas</li>
</ul>
<figure class="highlight text"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://www.zhenchao.org/schema/property.xsd=META-INF/property.xsd</span><br></pre></td></tr></tbody></table></div></figure>
<p>下面来看一下如何使用。首先需要在头部定义标签命名空间：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mytag</span>=<span class="string">"http://www.zhenchao.org/schema/property"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=</span></span><br><span class="line"><span class="tag">               "<span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">beans</span> <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">beans</span>/<span class="attr">spring-beans.xsd</span></span></span><br><span class="line"><span class="tag">                <span class="attr">http:</span>//<span class="attr">www.zhenchao.org</span>/<span class="attr">schema</span>/<span class="attr">property</span> <span class="attr">http:</span>//<span class="attr">www.zhenchao.org</span>/<span class="attr">schema</span>/<span class="attr">property.xsd</span>"</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>假设 MyBean 中有一个 tag 属性，那么我们可以利用我们自定义的标签进行如下配置：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"org.zhenchao.spring.ioc.MyBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mytag:property</span> <span class="attr">name</span>=<span class="string">"tag"</span> <span class="attr">value</span>=<span class="string">"myCustomTagValue"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>当我们获取 MyBean 实例的 tag 属性值时，就能够得到我们配置的值，类似于标准 <code>&lt;property /&gt;</code> 标签的效果，不过 Spring 提供的 <code>&lt;property /&gt;</code> 标签功能要强大很多，这里只是演示如何自定义一个属于自己的标签，实际开发中我们自定义的标签也会比这要复杂的多。当我们在使用 Spring 默认的标签配置时，如果发现配置异常复杂，这个时候就可以考虑是否可以通过自定义标签来简化配置。不过笔者也不推荐为了自定义而自定义，自定义的标签给后来人阅读源码带来了很大的负担，增加了学习成本。</p>
<p>介绍完了自定义标签的定义和使用方式，我们继续来剖析 Spring 对于自定义标签解析过程的实现。自定义标签的解析过程位于 <code>BeanDefinitionParserDelegate#decorateBeanDefinitionIfRequired</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateBeanDefinitionIfRequired</span><span class="params">(Element ele, BeanDefinitionHolder originalDef)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.decorateBeanDefinitionIfRequired(ele, originalDef, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateBeanDefinitionIfRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Element ele, BeanDefinitionHolder originalDef, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> </span>{</span><br><span class="line"></span><br><span class="line">    BeanDefinitionHolder finalDefinition = originalDef;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate based on custom attributes first.</span></span><br><span class="line">    <span class="comment">// 1. 获取并处理当前标签的属性集合</span></span><br><span class="line">    NamedNodeMap attributes = ele.getAttributes();</span><br><span class="line">    <span class="comment">// 遍历所有的属性，如果是目标自定义标签则进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) {</span><br><span class="line">        Node node = attributes.item(i);</span><br><span class="line">        finalDefinition = <span class="keyword">this</span>.decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate based on custom nested elements.</span></span><br><span class="line">    <span class="comment">// 2. 获取并处理当前标签的子标签集合</span></span><br><span class="line">    NodeList children = ele.getChildNodes();</span><br><span class="line">    <span class="comment">// 遍历所有的子标签，如果是目标自定义标签则进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) {</span><br><span class="line">        Node node = children.item(i);</span><br><span class="line">        <span class="keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) {</span><br><span class="line">            finalDefinition = <span class="keyword">this</span>.decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> finalDefinition;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的实现逻辑分为两步执行：第一步处理当前标签所有的自定义属性；第二步处理当前标签的所有自定义子标签。不过，这两步最终都是通过调用 <code>BeanDefinitionParserDelegate#decorateIfRequired</code> 方法完成处理，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateIfRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Node node, BeanDefinitionHolder originalDef, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取自定义标签的命名空间</span></span><br><span class="line">    String namespaceUri = <span class="keyword">this</span>.getNamespaceURI(node);</span><br><span class="line">    <span class="keyword">if</span> (namespaceUri != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.isDefaultNamespace(namespaceUri)) {</span><br><span class="line">        <span class="comment">// 根据命名空间找到对应的 NamespaceHandler</span></span><br><span class="line">        NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 调用 decorate 方法处理自定义标签</span></span><br><span class="line">            BeanDefinitionHolder decorated =</span><br><span class="line">                    handler.decorate(node, originalDef, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">            <span class="keyword">if</span> (decorated != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> decorated;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (namespaceUri.startsWith(<span class="string">"http://www.springframework.org/schema/"</span>)) {</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, node);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// A custom namespace, not to be handled by Spring - maybe "xml:...".</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"No Spring NamespaceHandler found for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> originalDef;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>解析过程与我们定义自定义标签的过程相呼应。首先获取标签的命名空间，并以此来判断当前属性或标签是否是自定义的，如果是则获取对应的 NamespaceHandler 类对象，也就是我们之前自定义的 PropertyNamespaceHandler 类，我们在该类的 <code>PropertyNamespaceHandler#init</code> 方法中注册了我们的 BeanDefinitionDecorator 实例：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.registerBeanDefinitionDecorator(<span class="string">"property"</span>, <span class="keyword">new</span> PropertyBeanDefinitionDecorator());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>然后调用 handler 处理自定义的标签，这里本质上还是调用了我们自定义实现的 <code>PropertyBeanDefinitionDecorator#decorate</code> 方法，这样就将我们自定义的实现和 Spring 框架集成在了一起。</p>

        <h4 id="注册-BeanDefinition-对象">
          <a href="#注册-BeanDefinition-对象" class="heading-link"><i class="fas fa-link"></i></a>注册 BeanDefinition 对象</h4>
      <p>在将 bean 的默认标签和自定义标签都设置到 BeanDefinition 实例中后，接下来就是向 IoC 容器注册 BeanDefinition 对象啦。Spring 定义了 BeanDefinitionHolder 类用于封装 BeanDefinition 对象，以及 bean 对应的唯一 name 和 alias 列表，并将 BeanDefinition 以 BeanDefinitionHolder 对象的形式注册到容器中。BeanDefinitionHolder 类的定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>往容器注册 BeanDefinitionHolder 对象的实现位于工具方法 <code>BeanDefinitionReaderUtils#registerBeanDefinition</code>  中，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以 beanName 作为唯一标识进行注册</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立 alias 与 beanName 之间的映射关系</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) {</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>整个注册过程主要做了两件事情：</p>
<ol>
<li>以唯一的 beanName 作为 key，注册 BeanDefinition 实例，本质上就是以 map 进行内存存储；</li>
<li>建立 alias 与 beanName 之间的映射关系。</li>
</ol>
<p>下面分别对这两个过程展开分析。</p>

        <h5 id="往容器注册-BeanDefinition-对象">
          <a href="#往容器注册-BeanDefinition-对象" class="heading-link"><i class="fas fa-link"></i></a>往容器注册 BeanDefinition 对象</h5>
      <p>注册 BeanDefinition 实例由 <code>DefaultListableBeanFactory#registerBeanDefinition</code> 方法实现，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line">    Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 校验 AbstractBeanDefinition 的 methodOverrides 属性，</span></span><br><span class="line"><span class="comment">             * 验证 methodOverrides 是否与工厂方法并存或覆盖的方法根本不存在</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        } <span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    beanDefinition.getResourceDescription(), beanName, <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取 beanName 已绑定的 BeanDefinition</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="comment">// 当前 beanName 已经绑定了某个 BeanDefinition 实例</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 不允许覆盖绑定，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isAllowBeanDefinitionOverriding()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 覆盖后的 bean 的应用场景变小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * role 用于定义 bean 的应用场景：</span></span><br><span class="line"><span class="comment">             * ROLE_APPLICATION：值为 0，用户</span></span><br><span class="line"><span class="comment">             * ROLE_SUPPORT：值为 1，某些复杂配置的一部分</span></span><br><span class="line"><span class="comment">             * ROLE_INFRASTRUCTURE：值为 2，完全内部使用</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">                <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">                logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with a framework-generated bean definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with a different definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">                logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 注册到容器中，本质上用 map 保存注册信息</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 当前 beanName 未绑定任何 BeanDefinition 实例</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasBeanCreationStarted()) {</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) {</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                <span class="keyword">this</span>.removeManualSingletonName(beanName);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="keyword">this</span>.removeManualSingletonName(beanName);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空当前 beanName 对应的 BeanDefinition 缓存</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || <span class="keyword">this</span>.containsSingleton(beanName)) {</span><br><span class="line">        <span class="keyword">this</span>.resetBeanDefinition(beanName);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>往容器注册 BeanDefinition 时首先会判断 BeanDefinition 是否是 AbstractBeanDefinition 类型实例，如果是则进一步验证其 methodOverrides 属性，防止出现与工厂方法并存或覆盖的方法根本不存在的情况。然后检查 beanName 是否已经绑定了 BeanDefinition 实例，如果已经绑定且允许覆盖已有的实例，则执行覆盖操作，如果没有绑定则直接注册。注册操作本质上是以 beanName 作为 key，以 BeanDefinition 实例作为 value 记录到 map 数据结构中，后续加载 bean 时会从依据给定的 beanName 从中获取 BeanDefinition,并依据 BeanDefinition 创建 bean 对象。</p>

        <h5 id="建立-alias-到-beanName-之间的映射">
          <a href="#建立-alias-到-beanName-之间的映射" class="heading-link"><i class="fas fa-link"></i></a>建立 alias 到 beanName 之间的映射</h5>
      <p>往容器注册 BeanDefinition 的第二步是建立 alias 与 beanName 之间的映射关系。如果把 BeanDefinition 实例看做是文件的话，那么 beanName 可以看作是文件的硬链接，而 alias 则可以看作是软连接，是 beanName 的快捷方式。建立映射的过程由 <code>SimpleAliasRegistry#registerAlias</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>{</span><br><span class="line">    Assert.hasText(name, <span class="string">"'name' must not be empty"</span>);</span><br><span class="line">    Assert.hasText(alias, <span class="string">"'alias' must not be empty"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.aliasMap) {</span><br><span class="line">        <span class="comment">// alias 与 name 相同，则将 alias 从映射关系中删除</span></span><br><span class="line">        <span class="keyword">if</span> (alias.equals(name)) {</span><br><span class="line">            <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"Alias definition '"</span> + alias + <span class="string">"' ignored since it points to same name"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// alias 与 name 不同，建立映射关系</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">            <span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 已经建立了正确的映射，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (registeredName.equals(name)) {</span><br><span class="line">                    <span class="comment">// An existing alias - no need to re-register</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 已经与其它 beanName 建立了映射，且不允许覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.allowAliasOverriding()) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot define alias '"</span> + alias + <span class="string">"' for name '"</span> +</span><br><span class="line">                            name + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 检测 name 和 alias 之间是否构成环路，如果构成环路则抛出异常</span></span><br><span class="line">            <span class="keyword">this</span>.checkForAliasCircle(name, alias);</span><br><span class="line">            <span class="comment">// 不存在环路，建立 alias 与 name 之间的映射关系</span></span><br><span class="line">            <span class="keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现比较简单，如代码注释，不再多做撰述。</p>

        <h4 id="发布事件通知">
          <a href="#发布事件通知" class="heading-link"><i class="fas fa-link"></i></a>发布事件通知</h4>
      <p>至此，Spring 完成了对 <code>&lt;bean /&gt;</code> 标签的解析过程，将 <code>&lt;bean /&gt;</code> 标签配置转换成 BeanDefinition 对象注册到 IoC 容器中。考虑到一些应用可能需要感知这一事件，Spring 在完成对一个 <code>&lt;bean /&gt;</code> 标签的解析之后会发布事件通知，通过调用 <code>ReaderContext#fireComponentRegistered</code> 方法将消息通知到具体的监听者。如果用户希望监听这一事件，可以实现 ReaderEventListener 接口，Spring 会在发布事件通知时回调 <code>ReaderEventListener#componentRegistered</code> 方法。</p>

        <h3 id="标签-import-的解析过程">
          <a href="#标签-import-的解析过程" class="heading-link"><i class="fas fa-link"></i></a>标签 import 的解析过程</h3>
      <p>标签 <code>&lt;import /&gt;</code> 也是我们比较常用的标签，尤其是在大型项目中，通过将各个模块的 Spring 配置分开定义，并在需要的地方通过 <code>&lt;import /&gt;</code> 标签引入，可以让配置更加的清晰，易于管理。该标签的解析过程位于 <code>DefaultBeanDefinitionDocumentReader#importBeanDefinitionResource</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">importBeanDefinitionResource</span><span class="params">(Element ele)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 resource 属性，例如 &lt;import resource="xx.xml"/&gt;</span></span><br><span class="line">    String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(location)) {</span><br><span class="line">        <span class="keyword">this</span>.getReaderContext().error(<span class="string">"Resource location must not be empty"</span>, ele);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析路径中的系统属性，比如可能存在如 ${user.dir} 的占位符</span></span><br><span class="line">    location = <span class="keyword">this</span>.getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line"></span><br><span class="line">    Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是绝对路径，还是相对路径</span></span><br><span class="line">    <span class="keyword">boolean</span> absoluteLocation = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">    } <span class="keyword">catch</span> (URISyntaxException ex) {</span><br><span class="line">        <span class="comment">// cannot convert to an URI, considering the location relative</span></span><br><span class="line">        <span class="comment">// unless it is the well-known Spring prefix "classpath*:"</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    <span class="keyword">if</span> (absoluteLocation) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 加载 bean 定义，并返回加载的数目</span></span><br><span class="line">            <span class="keyword">int</span> importCount = <span class="keyword">this</span>.getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">                logger.trace(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from URL location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (BeanDefinitionStoreException ex) {</span><br><span class="line">            <span class="keyword">this</span>.getReaderContext().error(<span class="string">"Failed to import bean definitions from URL location ["</span> + location + <span class="string">"]"</span>, ele, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// No URL -&gt; considering resource location as relative to the current file.</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">int</span> importCount;</span><br><span class="line">            <span class="comment">// Resource 存在多个子类，各子类的 createRelative 实现不一样，这里先使用子类的方法尝试解析</span></span><br><span class="line">            Resource relativeResource = <span class="keyword">this</span>.getReaderContext().getResource().createRelative(location);</span><br><span class="line">            <span class="keyword">if</span> (relativeResource.exists()) {</span><br><span class="line">                <span class="comment">// 加载 bean 定义，并返回加载的数目</span></span><br><span class="line">                importCount = <span class="keyword">this</span>.getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">                actualResources.add(relativeResource);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 解析不成功，使用默认的解析器 ResourcePatternResolver 进行解析</span></span><br><span class="line">                String baseLocation = <span class="keyword">this</span>.getReaderContext().getResource().getURL().toString();</span><br><span class="line">                importCount = <span class="keyword">this</span>.getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">                        StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">                logger.trace(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from relative location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">            <span class="keyword">this</span>.getReaderContext().error(<span class="string">"Failed to resolve current resource location"</span>, ele, ex);</span><br><span class="line">        } <span class="keyword">catch</span> (BeanDefinitionStoreException ex) {</span><br><span class="line">            <span class="keyword">this</span>.getReaderContext().error(<span class="string">"Failed to import bean definitions from relative location ["</span> + location + <span class="string">"]"</span>, ele, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 解析完成之后，发布事件通知</span></span><br><span class="line">    <span class="keyword">this</span>.getReaderContext().fireImportProcessed(location, actResArray, <span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>标签 <code>&lt;import /&gt;</code> 仅包含一个 resource 属性，该属性指定了配置文件的路径。路径可以是相对路径，也可以是绝对路径，路径中还可能存在一些系统属性占位符，比如 <code>${user.dir}</code>。上述方法首先对系统属性进行了处理，然后判断当前路径属于绝对路径还是相对路径，并分而治之。</p>

        <h3 id="标签-alias-的解析过程">
          <a href="#标签-alias-的解析过程" class="heading-link"><i class="fas fa-link"></i></a>标签 alias 的解析过程</h3>
      <p>标签 <code>&lt;alias /&gt;</code> 用于为一个已定义的 bean 设置别名，虽然在 <code>&lt;bean /&gt;</code> 标签中可以通过 name 属性定义别名，但是存在即合理，标签 <code>&lt;alias/&gt;</code> 总有它的应用场景。针对该标签的解析由 <code>DefaultBeanDefinitionDocumentReader#processAliasRegistration</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAliasRegistration</span><span class="params">(Element ele)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 name 属性</span></span><br><span class="line">    String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    <span class="comment">// 获取 alias 属性</span></span><br><span class="line">    String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// name 不允许为空</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(name)) {</span><br><span class="line">        <span class="keyword">this</span>.getReaderContext().error(<span class="string">"Name must not be empty"</span>, ele);</span><br><span class="line">        valid = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// alias 不允许为空</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(alias)) {</span><br><span class="line">        <span class="keyword">this</span>.getReaderContext().error(<span class="string">"Alias must not be empty"</span>, ele);</span><br><span class="line">        valid = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (valid) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 注册 alias</span></span><br><span class="line">            <span class="keyword">this</span>.getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            <span class="keyword">this</span>.getReaderContext().error(<span class="string">"Failed to register alias '"</span> + alias + <span class="string">"' for bean with name '"</span> + name + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 注册完成，发布事件通知</span></span><br><span class="line">        <span class="keyword">this</span>.getReaderContext().fireAliasRegistered(name, alias, <span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>标签 <code>&lt;alias/&gt;</code> 的解析过程复用了上面介绍的 <code>SimpleAliasRegistry#registerAlias</code> 方法，用于建立 alias 与 beanName 之间的映射关系，同时避免出现环路。</p>

        <h3 id="标签-beans-的解析过程">
          <a href="#标签-beans-的解析过程" class="heading-link"><i class="fas fa-link"></i></a>标签 beans 的解析过程</h3>
      <p>上面介绍的几种标签都是位于 <code>&lt;beans /&gt;</code> 标签下面，本小节将要分析的 <code>&lt;beans /&gt;</code> 标签是嵌套在外围 <code>&lt;beans /&gt;</code> 标签中的，本质上没有什么区别，所以 Spring 的解析过程也是递归调用了之前的解析过程，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>{</span><br><span class="line">    <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">    <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">    <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">    <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">    <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">    <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = <span class="keyword">this</span>.createDelegate(<span class="keyword">this</span>.getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 profile 标签（其作用类比 pom.xml 中的 profile）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) {</span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) {</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported in XML config. See SPR-12458 for details.</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                    logger.debug(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line">                            <span class="string">"] not matching: "</span> + <span class="keyword">this</span>.getReaderContext().getResource());</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法，预处理</span></span><br><span class="line">    <span class="keyword">this</span>.preProcessXml(root);</span><br><span class="line">    <span class="comment">// 解析并注册 BeanDefinition</span></span><br><span class="line">    <span class="keyword">this</span>.parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 模板方法，后处理</span></span><br><span class="line">    <span class="keyword">this</span>.postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法用于解析 <code>&lt;beans /&gt;</code> 标签。慢着！是不是看着有点眼熟，没错，本文最开始就是从这个方法中的 <code>DefaultBeanDefinitionDocumentReader#parseBeanDefinitions</code> 方法开挖的。饶了一大圈，我们又回到了起点，突然想到了一部电影 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://movie.douban.com/subject/3011051/">《恐怖游轮》</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，不多说了，睡觉~</p>

        <h3 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h3>
      <ol>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/25866350/">Spring 源码深度解析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2017/05/18/spring/spring-ioc-default-element/">https://plotor.github.io/2017/05/18/spring/spring-ioc-default-element/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/Spring/">Spring</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2017/05/19/spring/spring-ioc-custom-element/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Spring IoC 源码解析：自定义标签的解析过程</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2017/05/10/spring/spring-ioc-bean-factory/"><span class="paginator-prev__text">Spring IoC 源码解析：简单容器的初始化过程</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-bean-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">
          标签 bean 的解析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.</span> <span class="toc-text">
          解析默认标签元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%B1%9E%E6%80%A7%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          解析属性元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%AD%90%E6%A0%87%E7%AD%BE%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          解析子标签元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.</span> <span class="toc-text">
          解析自定义标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C-BeanDefinition-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">
          注册 BeanDefinition 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%80%E5%AE%B9%E5%99%A8%E6%B3%A8%E5%86%8C-BeanDefinition-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          往容器注册 BeanDefinition 对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B-alias-%E5%88%B0-beanName-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          建立 alias 到 beanName 之间的映射</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5"><span class="toc-number">1.4.</span> <span class="toc-text">
          发布事件通知</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-import-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">
          标签 import 的解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-alias-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">
          标签 alias 的解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-beans-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">
          标签 beans 的解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">95</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2024</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>