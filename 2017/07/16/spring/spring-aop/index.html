<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="IoC 和 AOP 被称为 Spring 两大基础模块，支撑着上层扩展的实现和运行。虽然 AOP 同样建立在 IoC 的实现基础之上，但是作为对 OOP(Object-Oriented Programing) 的补充，AOP(Aspect-Oriented Programming) 在程序设计领域拥有其不可替代的适用场景和地位。Spring AOP 作为 AOP 思想的实现，被誉为 Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring AOP 源码解析：注解式切面增强机制">
<meta property="og:url" content="https://plotor.github.io/2017/07/16/spring/spring-aop/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="IoC 和 AOP 被称为 Spring 两大基础模块，支撑着上层扩展的实现和运行。虽然 AOP 同样建立在 IoC 的实现基础之上，但是作为对 OOP(Object-Oriented Programing) 的补充，AOP(Aspect-Oriented Programming) 在程序设计领域拥有其不可替代的适用场景和地位。Spring AOP 作为 AOP 思想的实现，被誉为 Spring">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://plotor.github.io/images/2017/spring-aop-proxy-creator.png">
<meta property="article:published_time" content="2017-07-16T08:58:00.000Z">
<meta property="article:modified_time" content="2025-03-21T03:30:50.665Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://plotor.github.io/images/2017/spring-aop-proxy-creator.png"><title>Spring AOP 源码解析：注解式切面增强机制 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2017/07/16/spring/spring-aop/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Spring AOP 源码解析：注解式切面增强机制</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2017-07-16</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">7.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">37分</span></span></div></header><div class="post-body"><p>IoC 和 AOP 被称为 Spring 两大基础模块，支撑着上层扩展的实现和运行。虽然 AOP 同样建立在 IoC 的实现基础之上，但是作为对 OOP(Object-Oriented Programing) 的补充，AOP(Aspect-Oriented Programming) 在程序设计领域拥有其不可替代的适用场景和地位。Spring AOP 作为 AOP 思想的实现，被誉为 Spring 框架的基础模块也算是实至名归。Spring 在 1.0 版本的时候就引入了对 AOP 的支持，并且随着版本的迭代逐渐提供了基于 XML 配置、注解，以及 schema 配置的使用方式，考虑到实际开发中使用注解配置的方式相对较多，所以本文主要分析注解式 AOP 的实现和运行机制。<a id="more"></a></p>

        <h3 id="注解式-AOP-示例">
          <a href="#注解式-AOP-示例" class="heading-link"><i class="fas fa-link"></i></a>注解式 AOP 示例</h3>
      <p>首先我们还是通过一个简单的示例演示一下注解式 AOP 的具体使用。假设我们声明了一个 IService 接口，并提供了相应的实现类 ServiceImpl，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHelloTo</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayByebye</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayByebyeTo</span><span class="params">(String name)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.sayHelloTo(<span class="string">"zhenchao"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloTo</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"hello, "</span> + name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayByebye</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.sayByebyeTo(<span class="string">"zhenchao"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayByebyeTo</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"byebye, "</span> + name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>现在我们希望借助 Spring AOP 实现对方法调用的打点功能。首先我们需要定义一个切面：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricAspect</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before("execution(* sayHello*(..))")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMetrics4sayHello</span><span class="params">(JoinPoint point)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"[BEFORE] metrics for method: "</span> + point.getSignature().getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around("execution(* say*(..))")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundMetrics4say</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        System.out.println(<span class="string">"[AROUND] before metrics for method: "</span> + point.getSignature().getName());</span><br><span class="line">        Object obj = point.proceed();</span><br><span class="line">        System.out.println(<span class="string">"[AROUND] after metrics for method: "</span> + point.getSignature().getName());</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After("execution(* sayByebye*(..))")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMetrics4sayByebye</span><span class="params">(JoinPoint point)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"[AFTER] metrics for method: "</span> + point.getSignature().getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>通过 <code>@Aspect</code> 注解标记 MetricAspect 是一个切面，通过注解 <code>@Before</code>、<code>@After</code>，以及 <code>@Around</code>，我们在切面中定义了相应的前置、后置，以及环绕增强。然后我们需要在 XML 配置中添加一行如下配置以启用注解式 AOP：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>现在，我们就算大功告成了。</p>
<p>当然，上面的实现只是注解式 AOP 使用的一个简单示例，并没有覆盖所有的特性。对于 Spring AOP 特性的介绍不属于本文的范畴，不过我们还是会在下面分析源码的过程中进行针对性的介绍。</p>

        <h3 id="注解式-AOP-实现机制">
          <a href="#注解式-AOP-实现机制" class="heading-link"><i class="fas fa-link"></i></a>注解式 AOP 实现机制</h3>
      <p>下面从启用注解式 AOP 的那一行配置切入，即 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 标签。前面在分析 Spring IoC 实现的文章中，曾专门分析过 Spring 默认标签和自定义标签的解析过程。对于一个标签而言，除了标签的定义，还需要有对应的标签的解析器，并在 Spring 启动时将标签及其解析器注册到 Spring 容器中。标签 <code>&lt;aop:aspectj-autoproxy /&gt;</code> 的注册过程由 <code>AopNamespaceHandler#init</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 &lt;aspectj-autoproxy/&gt; 标签及其解析器</span></span><br><span class="line"><span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br></pre></td></tr></tbody></table></div></figure>
<p>AspectJAutoProxyBeanDefinitionParser 类是标签 <code>&lt;aop:aspectj-autoproxy /&gt;</code> 的解析器，该类实现了 BeanDefinitionParser 接口，并实现了 <code>BeanDefinitionParser#parse</code> 接口方法，属于标准的标签解析器定义。Spring 容器在启动时会调用 <code>AspectJAutoProxyBeanDefinitionParser#parse</code> 方法解析标签，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>{</span><br><span class="line">    <span class="comment">// 注册标签解析器，默认使用 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">    <span class="comment">// 解析 &lt;aop:include /&gt; 子标签，记录到 BeanDefinition 到 includePatterns 属性中</span></span><br><span class="line">    <span class="keyword">this</span>.extendBeanDefinition(element, parserContext);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>该方法做了两件事情：注册标签解析器和处理 <code>&lt;aop:include /&gt;</code> 子标签。本文我们重点来看标签解析器的注册过程，即 <code>AopNamespaceUtils#registerAspectJAnnotationAutoProxyCreatorIfNecessary</code> 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(ParserContext parserContext, Element sourceElement)</span> </span>{</span><br><span class="line">    <span class="comment">// 1. 注册或更新代理创建器 ProxyCreator 的 BeanDefinition 对象</span></span><br><span class="line">    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">            parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">    <span class="comment">// 2. 获取并处理标签的 proxy-target-class 和 expose-proxy 属性</span></span><br><span class="line">    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">    <span class="comment">// 3. 注册组件，并发布事件通知</span></span><br><span class="line">    registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>我们在代码注释中标明了该方法所做的 3 件事情，其中 1 和 2 是我们分析的关键，首先来看 1 过程所做的事情：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; cls, BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果名为 org.springframework.aop.config.internalAutoProxyCreator 的 bean 已经在册</span></span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {</span><br><span class="line">        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">        <span class="comment">// 已经在册的 ProxyCreator 与当前期望的类型不一致，则依据优先级进行选择</span></span><br><span class="line">        <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) {</span><br><span class="line">            <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">            <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">            <span class="comment">// 选择优先级高的 ProxyCreator 更新注册</span></span><br><span class="line">            <span class="keyword">if</span> (currentPriority &lt; requiredPriority) {</span><br><span class="line">                apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有对应在册的 ProxyCreator，注册一个新的</span></span><br><span class="line">    RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">    beanDefinition.setSource(source);</span><br><span class="line">    beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">    <span class="keyword">return</span> beanDefinition;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现的逻辑还是挺简单的，即注册一个名为 <code>org.springframework.aop.config.internalAutoProxyCreator</code> 的 BeanDefinition，我们称之为代理创建器（ProxyCreator）。这里使用的默认实现为 AnnotationAwareAspectJAutoProxyCreator 类，如果存在多个候选实现，则选择优先级最高的进行注册。</p>
<p>接下来看一下过程 2，这一步主要是用来解析标签 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 的 <code>proxy-target-class</code> 和 <code>expose-proxy</code> 属性配置，由 <code>AopNamespaceUtils#useClassProxyingIfNecessary</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useClassProxyingIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Element sourceElement)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (sourceElement != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取并处理 proxy-target-class 属性：</span></span><br><span class="line"><span class="comment">         * - false 表示使用 java 原生动态代理</span></span><br><span class="line"><span class="comment">         * - true 表示使用 CGLib 动态</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 但是对于一些没有接口实现的类来说，即使设置为 false 也会使用 CGlib 进行代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> proxyTargetClass = Boolean.parseBoolean(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">        <span class="keyword">if</span> (proxyTargetClass) {</span><br><span class="line">            <span class="comment">// 为之前注册的 ProxyCreator 添加一个名为 proxyTargetClass 的属性，值为 true</span></span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取并处理 expose-proxy 标签，实现对于内部方法调用的 AOP 增强</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> exposeProxy = Boolean.parseBoolean(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line">        <span class="keyword">if</span> (exposeProxy) {</span><br><span class="line">            <span class="comment">// 为之前注册的 ProxyCreator 添加一个名为 exposeProxy 的属性，值为 true</span></span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>其中 <code>proxy-target-class</code> 属性用来配置是否使用 CGLib 代理，而 <code>expose-proxy</code> 属性则用来配置是否对内部方法调用启用 AOP 增强。属性 <code>proxy-target-class</code> 的作用大家应该都比较熟悉，下面介绍一下 <code>expose-proxy</code> 属性。前面给出的 AOP 示例中，我们在 <code>IService#sayHello</code> 方法中调用了 <code>IService#sayHelloTo</code> 方法，虽然两个方法都满足对应的 AOP 增强定义，但是只有 <code>IService#sayHello</code> 方法被增强了，这主要是因为 <code>IService#sayHelloTo</code> 方法是在对象内部调用的，调用该方法的对象并不是代理对象。如果期望内部调用时也能够被增强，我们需要配置 <code>expose-proxy=true</code>，并修改 <code>IService#sayHello</code> 方法对于 <code>IService#sayHelloTo</code> 方法的调用方式：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>{</span><br><span class="line">    ((IService) AopContext.currentProxy()).sayHelloTo(<span class="string">"zhenchao"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上面分析了这么多，总的说来就是向 Spring 容器中注册了一个 AnnotationAwareAspectJAutoProxyCreator 类型的 ProxyCreator，并将配置的 <code>proxy-target-class</code> 和 <code>expose-proxy</code> 属性添加到对应 BeanDefinition 的属性列表中。那么 AnnotationAwareAspectJAutoProxyCreator 到底是来做什么的呢？我们先来看一下它的类继承关系图：</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2017/spring-aop-proxy-creator.png" alt="image">
      </p>
<p>从类继承关系图中可以看到该类实现了 BeanPostProcessor 接口，该接口定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由之前对 Spring IoC 容器启动过程的分析，我们知道在容器启动过程中会在初始化 bean 实例的前后分别调用 BeanPostProcessor 中定义的这两个方法。针对这两个方法的实现主要位于继承链的 AbstractAutoProxyCreator 类中，并且主要是实现了 <code>BeanPostProcessor#postProcessAfterInitialization</code> 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果 beanName 不为空则直接使用 beanName（FactoryBean 则使用 &amp;{beanName}），否则使用 bean 的 className</span></span><br><span class="line">        Object cacheKey = <span class="keyword">this</span>.getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) {</span><br><span class="line">            <span class="comment">// 尝试对 bean 进行增强，创建返回增强后的代理对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>该方法的核心在于调用 <code>AbstractAutoProxyCreator#wrapIfNecessary</code> 方法尝试基于 AOP 配置对当前 bean 进行增强，并返回增强后的代理对象。方法 <code>AbstractAutoProxyCreator#wrapIfNecessary</code> 的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>{</span><br><span class="line">    <span class="comment">// 已经处理过，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) {</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 不需要进行增强的 bean 实例，直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) {</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 对于 AOP 的基础支撑类，或者指定不需要被代理的类，设置为不进行代理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isInfrastructureClass(bean.getClass()) || <span class="keyword">this</span>.shouldSkip(bean.getClass(), beanName)) {</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取适用于当前 bean 的 Advisor</span></span><br><span class="line">    Object[] specificInterceptors = <span class="keyword">this</span>.getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 基于获取到的 Advisor 为当前 bean 创建代理对象</span></span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) {</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        Object proxy = <span class="keyword">this</span>.createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法主要的工作是对 bean 实例进行筛选，过滤掉那些已经增强过的、支持 AOP 基础运行的，以及指定不需要被代理的 bean 实例。对于剩下的 bean 实例来说，首先会调用 <code>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code> 方法获取适用于当前 bean 的增强器（Advisor），并基于这些增强器调用 <code>AbstractAutoProxyCreator#createProxy</code> 方法为当前 bean 创建增强后的代理对象。</p>

        <h4 id="筛选适用于-bean-的增强器">
          <a href="#筛选适用于-bean-的增强器" class="heading-link"><i class="fas fa-link"></i></a>筛选适用于 bean 的增强器</h4>
      <p>我们首先来看一下筛选适用于当前 bean 的合格增强器的过程，实现位于 <code>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">        Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) {</span><br><span class="line">    <span class="comment">// 获取适用于当前 bean 的 Advisor</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">this</span>.findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="comment">// 没有合格的 Advisor，不进行代理</span></span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY; <span class="comment">// null</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取所有候选的 Advisor（包括注解的、XML 中配置的）</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = <span class="keyword">this</span>.findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// 从所有 Advisor 中寻找适用于当前 bean 的 Advisor</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">this</span>.findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    <span class="comment">// 如果 Advisor 不为空，则在最前面追加一个 ExposeInvocationInterceptor</span></span><br><span class="line">    <span class="keyword">this</span>.extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="comment">// 对 Advisor 进行排序</span></span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) {</span><br><span class="line">        eligibleAdvisors = <span class="keyword">this</span>.sortAdvisors(eligibleAdvisors);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>整个方法的执行流程很简单，获取所有的候选增强器，并从中找出适用于当前 bean 的增强器。首先来看获取所有候选增强器的过程，实现位于 <code>AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 调用父类的 findCandidateAdvisors 方法，兼容父类查找 Advisor 的规则</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// 获取所有注解定义的 Advisor</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) {</span><br><span class="line">        advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先调用了父类的实现，这主要是为了兼容父类查找候选增强器的规则，例如我们的示例中使用的是注解方式定义的增强，但是父类却是基于 XML 配置的方式查找增强器，这里的兼容能够让我们在以注解方式编程时兼容其它以 XML 配置的方式定义的增强。下面还是将主要精力放在解析注解式增强定义上，该过程位于 <code>BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors</code> 方法中。不过该方法实现比较冗长，但是逻辑却很清晰，所以这里主要概括一下其执行流程：</p>
<ol>
<li>获取所有类型 bean 实例对应的 beanName 集合；</li>
<li>过滤不是切面类型的 bean 对应的 beanName，即没有被 <code>@Aspect</code> 注解，或包含以 <code>ajc$</code> 开头的字段，同时支持覆盖 <code>BeanFactoryAspectJAdvisorsBuilder#isEligibleBean</code> 方法扩展过滤规则；</li>
<li>对于切面 bean 类型，获取 bean 中定义的所有切点，并为每个切点生成对应的增强器；</li>
<li>缓存解析得到的增强器，避免重复解析。</li>
</ol>
<p>上述流程中我们重点看一下过程 3，实现位于 <code>ReflectiveAspectJAdvisorFactory#getAdvisors</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取切面 aspect 对应的 class 和 beanName</span></span><br><span class="line">    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">    <span class="comment">// 校验切面定义的合法性</span></span><br><span class="line">    <span class="keyword">this</span>.validate(aspectClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line">    <span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">            <span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 遍历处理切面中除被 @Pointcut 注解以外的方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : <span class="keyword">this</span>.getAdvisorMethods(aspectClass)) {</span><br><span class="line">        Advisor advisor = <span class="keyword">this</span>.getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">        <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) {</span><br><span class="line">            advisors.add(advisor);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果增强器不为空，同时又配置了增强延迟初始化，则需要追加实例化增强器 SyntheticInstantiationAdvisor</span></span><br><span class="line">    <span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {</span><br><span class="line">        Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">        advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取所有引介增强定义</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) {</span><br><span class="line">        <span class="comment">// 创建引介增强器 DeclareParentsAdvisor</span></span><br><span class="line">        Advisor advisor = <span class="keyword">this</span>.getDeclareParentsAdvisor(field);</span><br><span class="line">        <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) {</span><br><span class="line">            advisors.add(advisor);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现的整体执行流程如代码注释。拿到一个切面定义，Spring 首先会遍历获取切面中的增强方法，即被 <code>@Around</code>、<code>@Before</code>、<code>@After</code>、<code>@AfterReturning</code>，以及 <code>@AfterThrowing</code> 注解的方法，并调用 <code>ReflectiveAspectJAdvisorFactory#getAdvisor</code> 方法为每一个增强方法生成对应的增强器：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                          MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> declarationOrderInAspect,</span></span></span><br><span class="line"><span class="function"><span class="params">                          String aspectName)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验切面类定义的合法性</span></span><br><span class="line">    <span class="keyword">this</span>.validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取注解配置的切点信息，封装成 AspectJExpressionPointcut 对象</span></span><br><span class="line">    AspectJExpressionPointcut expressionPointcut = <span class="keyword">this</span>.getPointcut(</span><br><span class="line">            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">    <span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依据切点信息生成对应的增强器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(</span><br><span class="line">            expressionPointcut, candidateAdviceMethod, <span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现首先对当前切面定义执行合法性校验，如果切面配置合法则获取目标方法上的切点注解定义，并封装成 AspectJExpressionPointcut 对象。该过程位于 <code>ReflectiveAspectJAdvisorFactory#getPointcut</code> 方法中，实现比较简单。</p>
<p>拿到切点注解定义之后，方法会依据切点的配置信息使用 InstantiationModelAwarePointcutAdvisorImpl 实现类创建对应的增强器。类 InstantiationModelAwarePointcutAdvisorImpl 的实例化过程除了初始化了一些基本属性之外，主要是调用了 <code>InstantiationModelAwarePointcutAdvisorImpl#instantiateAdvice</code> 方法，依据增强类型对增强器实施相应的初始化操作：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Advice <span class="title">instantiateAdvice</span><span class="params">(AspectJExpressionPointcut pointcut)</span> </span>{</span><br><span class="line">    Advice advice = <span class="keyword">this</span>.aspectJAdvisorFactory.getAdvice(</span><br><span class="line">            <span class="keyword">this</span>.aspectJAdviceMethod, pointcut, <span class="keyword">this</span>.aspectInstanceFactory, <span class="keyword">this</span>.declarationOrder, <span class="keyword">this</span>.aspectName);</span><br><span class="line">    <span class="keyword">return</span> (advice != <span class="keyword">null</span> ? advice : EMPTY_ADVICE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory#getAdvice</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">(Method candidateAdviceMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                        AspectJExpressionPointcut expressionPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">                        MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> declarationOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String aspectName)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取切面 class 对象，并校验切面定义</span></span><br><span class="line">    Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">    <span class="keyword">this</span>.validate(candidateAspectClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取方法的切点注解定义</span></span><br><span class="line">    AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">    <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we get here, we know we have an AspectJ method.</span></span><br><span class="line">    <span class="comment">// Check that it's an AspectJ-annotated class</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isAspect(candidateAspectClass)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Advice must be declared inside an aspect type: "</span> +</span><br><span class="line">                <span class="string">"Offending method '"</span> + candidateAdviceMethod + <span class="string">"' in class ["</span> + candidateAspectClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    AbstractAspectJAdvice springAdvice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依据切点注解类型使用对应的增强类进行封装</span></span><br><span class="line">    <span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) {</span><br><span class="line">        <span class="comment">// @Pointcut</span></span><br><span class="line">        <span class="keyword">case</span> AtPointcut:</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="string">"'"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// @Around</span></span><br><span class="line">        <span class="keyword">case</span> AtAround:</span><br><span class="line">            springAdvice = <span class="keyword">new</span> AspectJAroundAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// @Before</span></span><br><span class="line">        <span class="keyword">case</span> AtBefore:</span><br><span class="line">            springAdvice = <span class="keyword">new</span> AspectJMethodBeforeAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// @After</span></span><br><span class="line">        <span class="keyword">case</span> AtAfter:</span><br><span class="line">            springAdvice = <span class="keyword">new</span> AspectJAfterAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// @AfterReturning</span></span><br><span class="line">        <span class="keyword">case</span> AtAfterReturning:</span><br><span class="line">            springAdvice = <span class="keyword">new</span> AspectJAfterReturningAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) {</span><br><span class="line">                springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// @AfterThrowing</span></span><br><span class="line">        <span class="keyword">case</span> AtAfterThrowing:</span><br><span class="line">            springAdvice = <span class="keyword">new</span> AspectJAfterThrowingAdvice(</span><br><span class="line">                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) {</span><br><span class="line">                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Unsupported advice type on method: "</span> + candidateAdviceMethod);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now to configure the advice...</span></span><br><span class="line">    springAdvice.setAspectName(aspectName);</span><br><span class="line">    springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">    String[] argNames = <span class="keyword">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line">    <span class="keyword">if</span> (argNames != <span class="keyword">null</span>) {</span><br><span class="line">        springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">    }</span><br><span class="line">    springAdvice.calculateArgumentBindings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> springAdvice;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法的整体执行流程如代码注释，逻辑比较清晰，Spring 会依据具体的增强注解类型，选择相应的增强类对切点定义进行封装。这里我们以 <code>@Before</code> 为例说明一下增强的执行流程，AspectJMethodBeforeAdvice 增强类关联注册的处理器是 MethodBeforeAdviceInterceptor，当我们调用一个被前置增强的目标方法时，<code>MethodBeforeAdviceInterceptor#invoke</code> 方法会被触发：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    <span class="comment">// 执行增强方法</span></span><br><span class="line">    <span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">    <span class="comment">// 执行目标方法</span></span><br><span class="line">    <span class="keyword">return</span> mi.proceed();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>这里执行的增强方法就对应着 <code>AspectJMethodBeforeAdvice#before</code> 方法，该方法会依据切点配置将相应的参数绑定传递给我们自定义的增强方法，并最终通过反射调用触发执行。</p>
<p>上面分析了普通方法级别增强的处理过程，对于另外一类增强（引介增强），方法 <code>ReflectiveAspectJAdvisorFactory#getAdvisors</code> 则使用专门的 DeclareParentsAdvisor 类创建对应的增强器：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 获取所有引介增强定义</span></span><br><span class="line"><span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) {</span><br><span class="line">    <span class="comment">// 创建引介增强器</span></span><br><span class="line">    Advisor advisor = <span class="keyword">this</span>.getDeclareParentsAdvisor(field);</span><br><span class="line">    <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) {</span><br><span class="line">        advisors.add(advisor);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Advisor <span class="title">getDeclareParentsAdvisor</span><span class="params">(Field introductionField)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 @DeclareParents 注解定义</span></span><br><span class="line">    DeclareParents declareParents = introductionField.getAnnotation(DeclareParents.class);</span><br><span class="line">    <span class="keyword">if</span> (declareParents == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有指定默认的接口实现类</span></span><br><span class="line">    <span class="keyword">if</span> (DeclareParents.class == declareParents.defaultImpl()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"'defaultImpl' attribute must be set on DeclareParents"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 DeclareParentsAdvisor 类型创建对应的引介增强器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DeclareParentsAdvisor(</span><br><span class="line">            introductionField.getType(), declareParents.value(), declareParents.defaultImpl());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于引介增强来说，Spring 会注入 DelegatePerTargetObjectIntroductionInterceptor 处理器对其进行专门的处理，思想上与前面分析前置增强大同小异，这里不再展开。</p>
<p>继续回到 <code>AbstractAdvisorAutoProxyCreator#findEligibleAdvisors</code> 方法，上面的过程我们分析了获取所有类型增强器的过程，但是这些增强器不一定都适用于当前 bean 实例，我们需要依据切点配置信息对其进行筛选。这一过程位于 <code>AbstractAdvisorAutoProxyCreator#findAdvisorsThatCanApply</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>{</span><br><span class="line">    ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.aop.support.AopUtils#findAdvisorsThatCanApply</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>{</span><br><span class="line">    <span class="comment">// 没有候选的增强器，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (candidateAdvisors.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">    }</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 筛选引介增强器</span></span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) {</span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) {</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 表示是否含有引介增强</span></span><br><span class="line">    <span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 筛选其它类型的增强器</span></span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) {</span><br><span class="line">        <span class="comment">// 引介增强已经处理过，这里直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) {</span><br><span class="line">            <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 筛选其它类型的增强器</span></span><br><span class="line">        <span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) {</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先会使用类过滤器（ClassFilter）筛选引介增强器，除了我们手动注册的类过滤器外，这里默认还会使用 TypePatternClassFilter 类过滤器执行过滤操作。然后，方法会过滤筛选其它类型的增强器，这里除了使用类过滤器外，考虑方法级别增强的定义形式，还会使用方法匹配器（MethodMatcher）进行筛选。如果增强器适用于当前 bean 类型，则将其加入到集合中用于下一步为当前 bean 创建增强代理对象。如果没有任何一个增强器适用于当前 bean 类型，则方法 <code>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code> 最终会返回值为 null 的 <code>DO_NOT_PROXY</code> 数组对象，表示当前 bean 不需要被增强。</p>

        <h4 id="为-bean-创建增强代理对象">
          <a href="#为-bean-创建增强代理对象" class="heading-link"><i class="fas fa-link"></i></a>为 bean 创建增强代理对象</h4>
      <p>完成了对于当前 bean 增强器的筛选，接下来我们继续回到 <code>AbstractAutoProxyCreator#wrapIfNecessary</code> 方法，看一下基于前面筛选出的增强器为当前 bean 创建增强代理对象的过程，实现位于 <code>AbstractAutoProxyCreator#createProxy</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="meta">@Nullable</span> Object[] specificInterceptors,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TargetSource targetSource)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) {</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ProxyFactory 用于为目标 bean 实例创建代理对象</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy-target-class = false，表示使用 JDK 原生动态代理</span></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) {</span><br><span class="line">        <span class="comment">// 检测当前 bean 是否应该基于类而非接口生成代理对象，即包含 preserveTargetClass=true 属性</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.shouldProxyTargetClass(beanClass, beanName)) {</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果是基于接口生成代理，则添加需要代理的接口到 ProxyFactory 中（除内置 callback 接口、语言内在接口，以及标记接口）</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">this</span>.evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将拦截器封装成 Advisor 对象</span></span><br><span class="line">    Advisor[] advisors = <span class="keyword">this</span>.buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    <span class="comment">// 模板方法，定制代理工厂</span></span><br><span class="line">    <span class="keyword">this</span>.customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置代理工厂被配置之后是否还允许修改，默认为 false，表示不允许修改</span></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.advisorsPreFiltered()) {</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于 ProxyFactory 创建代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(<span class="keyword">this</span>.getProxyClassLoader());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法的执行流程如代码注释。下面我们主要分析将拦截器封装成 Advisor 对象的过程，以及基于 ProxyFactory 创建增强代理对象的过程。</p>
<p>Spring 定义了非常多的拦截器、增强器，以及增强方法等，这里通过 <code>AbstractAutoProxyCreator#buildAdvisors</code> 方法统一将他们封装成 Advisor 对象，从而简化代理的创建过程。封装的核心步骤由 <code>DefaultAdvisorAdapterRegistry#wrap</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">wrap</span><span class="params">(Object adviceObject)</span> <span class="keyword">throws</span> UnknownAdviceTypeException </span>{</span><br><span class="line">    <span class="comment">// 已经是 Advisor，则无需多做处理</span></span><br><span class="line">    <span class="keyword">if</span> (adviceObject <span class="keyword">instanceof</span> Advisor) {</span><br><span class="line">        <span class="keyword">return</span> (Advisor) adviceObject;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 要求必须是 Advice 类型</span></span><br><span class="line">    <span class="keyword">if</span> (!(adviceObject <span class="keyword">instanceof</span> Advice)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(adviceObject);</span><br><span class="line">    }</span><br><span class="line">    Advice advice = (Advice) adviceObject;</span><br><span class="line">    <span class="comment">// 如果是 MethodInterceptor，则直接使用 DefaultPointcutAdvisor 进行包装</span></span><br><span class="line">    <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) {</span><br><span class="line">        <span class="comment">// So well-known it doesn't even need an adapter.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 否则遍历注册的适配器，如果存在关联的适配器则使用 DefaultPointcutAdvisor 进行包装</span></span><br><span class="line">    <span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) {</span><br><span class="line">        <span class="comment">// Check that it is supported.</span></span><br><span class="line">        <span class="keyword">if</span> (adapter.supportsAdvice(advice)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advice);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>接下来我们重点分析一下通过代理工厂 ProxyFactory 创建增强代理对象的过程，实现位于 <code>ProxyFactory#getProxy</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.createAopProxy() <span class="comment">// 1. 创建 AOP 代理</span></span><br><span class="line">            .getProxy(classLoader); <span class="comment">// 2. 基于 AOP 代理创建目标类的增强代理对象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>该方法的执行过程可以拆分成两个步骤：</p>
<ol>
<li>创建 AOP 代理，Spring 默认提供了两种 AOP 代理实现，即 java 原生代理和 CGLib 代理；</li>
<li>基于 AOP 代理创建目标类的增强代理对象。</li>
</ol>
<p>我们首先来看一下步骤 1 的实现，位于 <code>ProxyCreatorSupport#createAopProxy</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.active) {</span><br><span class="line">        <span class="keyword">this</span>.activate();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>{</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() <span class="comment">// 需要对代理策略进行优化</span></span><br><span class="line">            || config.isProxyTargetClass() <span class="comment">// // 指定使用 CGLib 生成代理对象</span></span><br><span class="line">            || <span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) <span class="comment">// 当前类没有接口定义，不得不使用 CGLib</span></span><br><span class="line">    {</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                    <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 目标类是接口或代理类，使用 JDK 原生代理</span></span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 使用 CGLib 动态代理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用 JDK 原生动态代理</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>这部分代码清晰说明了 Spring 在生成代理对象时如何在 java 原生代理和 CGLib 代理之间进行选择，可以概括如下：</p>
<ol>
<li>如果目标类实现了接口，则 Spring 默认会使用 java 原生代理。</li>
<li>如果目标类未实现接口，则 Spring 会使用 CGLib 生成代理。</li>
<li>如果目标类实现了接口，但是在配置时指定了 <code>proxy-target-class=true</code>，则使用 CGLib 生成代理。</li>
</ol>
<p>下面分别对基于 java 原生代理和 CGLib 代理生成增强代理对象的过程进行分析。</p>

        <h5 id="基于-java-原生代理创建增强代理对象">
          <a href="#基于-java-原生代理创建增强代理对象" class="heading-link"><i class="fas fa-link"></i></a>基于 java 原生代理创建增强代理对象</h5>
      <p>首先来看一下基于 java 原生代理生成增强代理对象的过程，位于 JdkDynamicAopProxy 类中。Java 原生代理要求代理类实现 InvocationHandler 接口，并在 <code>InvocationHandler#invoke</code> 方法中实现代理增强逻辑。JdkDynamicAopProxy 正好实现了该接口，对应的 <code>JdkDynamicAopProxy#invoke</code> 方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 当前是 equals 方法，但是被代理类接口中未定义 equals 方法</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.equals(args[<span class="number">0</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 当前是 hashCode 方法，但是被代理类接口中未定义 hashCode 方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.hashCode();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果是 DecoratingProxy 中定义的方法（即 DecoratingProxy#getDecoratedClass），直接返回目标类对象</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) {</span><br><span class="line">            <span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque <span class="comment">// 允许被转换成 Advised 类型</span></span><br><span class="line">                &amp;&amp; method.getDeclaringClass().isInterface() <span class="comment">// 接口类型</span></span><br><span class="line">                &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) <span class="comment">// 方法所在类是 Advised 类及其父类</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 直接反射调用该方法</span></span><br><span class="line">            <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果值</span></span><br><span class="line">        Object retVal;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定内部间调用也需要代理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) {</span><br><span class="line">            <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool.</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line">        <span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">        <span class="comment">// 拦截器链为空，则直接反射调用增强方法</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) {</span><br><span class="line">            <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">            <span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">            <span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则需要创建对应的 MethodInvocation，以链式调用拦截器方法和增强方法</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            MethodInvocation invocation =</span><br><span class="line">                    <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            <span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理返回值</span></span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {</span><br><span class="line">            <span class="comment">// Special case: it returned "this" and the return type of the method is type-compatible.</span></span><br><span class="line">            <span class="comment">// Note that we can't help if the target sets a reference to itself in another returned object.</span></span><br><span class="line">            retVal = proxy;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">                    <span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) {</span><br><span class="line">            <span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) {</span><br><span class="line">            <span class="comment">// Restore old proxy.</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由上述方法实现，我们可以概括出整个增强代理的执行过程，如下：</p>
<ol>
<li>特殊处理 <code>Object#equals</code>、<code>Object#hashCode</code>、<code>DecoratingProxy#getDecoratedClass</code>，以及 Advised 类及其父类中定义的方法；</li>
<li>如果配置了 expose-proxy 属性，则记录当前代理对象，以备在内部间调用时实施增强；</li>
<li>获取当前方法的拦截器链；</li>
<li>如果没有拦截器定义，则直接反射调用增强方法，否则先逐一执行拦截器方法，最后再应用增强方法；</li>
<li>处理返回值。</li>
</ol>
<p>重点来看一下步骤 4 中应用拦截器方法的实现，位于 <code>ReflectiveMethodInvocation#proceed</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    <span class="comment">// 如果所有的增强都执行完成，则执行增强方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.invokeJoinpoint();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个需要执行的拦截器</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">            <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="comment">// 动态拦截器，执行动态方法匹配</span></span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) {</span><br><span class="line">        <span class="comment">// Evaluate dynamic method matcher here: static part will already have been evaluated and found to match.</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">        <span class="comment">// 动态匹配成功，执行对应的拦截方法</span></span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) {</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 动态匹配失败，忽略当前拦截器方法，继续执行下一个拦截器</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.proceed();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 静态拦截器，直接应用拦截方法</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>拦截器方法的执行流程如上述代码注释，是一个递归调用的过程，并在最后应用增强方法。</p>
<p>完成了对于 AOP 代理对象 JdkDynamicAopProxy 的创建，最后来看一下获取该对象的过程，实现位于 <code>JdkDynamicAopProxy#getProxy</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取需要被代理的接口集合</span></span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 检测是否在被代理接口中声明了 equals 和 hashCode 方法</span></span><br><span class="line">    <span class="keyword">this</span>.findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    <span class="comment">// 基于 java 原生代理生成代理对象</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>这里的逻辑也就是 java 原生代理的模板代码，如果对 java 代理比较熟悉的话，应该不难理解。</p>

        <h5 id="基于-CGLib-代理创建增强代理对象">
          <a href="#基于-CGLib-代理创建增强代理对象" class="heading-link"><i class="fas fa-link"></i></a>基于 CGLib 代理创建增强代理对象</h5>
      <p>基于 CGLib 代理生成增强代理对象的过程位于 ObjenesisCglibAopProxy 类中，该类继承自 CglibAopProxy 类。获取 CGLib 代理类对象的方法定义在 CglibAopProxy 中，即 <code>CglibAopProxy#getProxy</code> 方法。该方法基于 CGLib 的 Enhancer 类创建代理对象，属于 CGLib 的标准使用模式，因为有多个 callback 实现，所以这里使用了 CallbackFilter 模式，依据场景选择并应用对应的 callback 拦截器。</p>
<p>我们重点关注 callback 的实现，位于 <code>CglibAopProxy#getCallbacks</code> 方法中。受制于 CGLib 在执行时一次只允许应用一个 callback 的约束，所以该方法依据参数配置实现了一组 callback，以覆盖不同的场景。核心的 AOP callback 实现是 DynamicAdvisedInterceptor 类，它实现了 MethodInterceptor 接口，对应的 <code>DynamicAdvisedInterceptor#intercept</code> 方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 指定内部间调用也需要代理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) {</span><br><span class="line">            <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">        <span class="comment">// 结果值</span></span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="comment">// Check whether we only have one InvokerInterceptor:</span></span><br><span class="line">        <span class="comment">// that is, no real advice, but just reflective invocation of the target.</span></span><br><span class="line">        <span class="comment">// 拦截器链为空，则直接反射调用增强方法</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) {</span><br><span class="line">            <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">            <span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">            <span class="comment">// it does nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则需要创建对应的 MethodInvocation，以链式调用拦截器方法和增强方法</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 处理返回值</span></span><br><span class="line">        retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) {</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) {</span><br><span class="line">            <span class="comment">// Restore old proxy.</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>可以看出上述方法在实现流程上与前面介绍的 <code>JdkDynamicAopProxy#invoke</code> 方法是一致的，只是这里是基于 CGLib 实现而已。</p>

        <h3 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>最后我们对 Spring AOP 的运行机制进行一个总结。Spring AOP 的实现本质上是一个动态代理的过程，Spring 引入了 java 原生代理和 CGLib 代理，并依据场景选择基于哪种代理机制对目标对象进行增强。由前面对于 Spring IoC 实现的分析可以了解到，Spring 容器在完成对 bean 对象的创建之后会执行初始化操作，而 AOP 初始化的过程就发生在 bean 的后置初始化阶段，整体流程可以概括为：</p>
<ol>
<li>从容器中获取所有的切面定义；</li>
<li>筛选适用于当前 bean 的增强器集合；</li>
<li>依据增强器集合基于动态代理机制生成相应的增强代理对象。</li>
</ol>
<p>当我们在调用一个被增强的方法时，相应的拦截器会依据连接点的方位在适当的位置触发对应的增强定义，从而最终实现 AOP 中定义的各类增强语义。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2017/07/16/spring/spring-aop/">https://plotor.github.io/2017/07/16/spring/spring-aop/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/Spring/">Spring</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2017/07/20/spring/spring-mvc-initialization/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Spring MVC 源码解析：Web 环境下容器的初始化过程</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2017/07/08/spring/spring-ioc-circular-reference/"><span class="paginator-prev__text">Spring IoC 源码解析：循环依赖的检测与处理</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%BC%8F-AOP-%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.</span> <span class="toc-text">
          注解式 AOP 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%BC%8F-AOP-%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">
          注解式 AOP 实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%9B%E9%80%89%E9%80%82%E7%94%A8%E4%BA%8E-bean-%E7%9A%84%E5%A2%9E%E5%BC%BA%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">
          筛选适用于 bean 的增强器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA-bean-%E5%88%9B%E5%BB%BA%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">
          为 bean 创建增强代理对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-java-%E5%8E%9F%E7%94%9F%E4%BB%A3%E7%90%86%E5%88%9B%E5%BB%BA%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">
          基于 java 原生代理创建增强代理对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-CGLib-%E4%BB%A3%E7%90%86%E5%88%9B%E5%BB%BA%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.2.</span> <span class="toc-text">
          基于 CGLib 代理创建增强代理对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">
          总结</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">95</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2025</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>