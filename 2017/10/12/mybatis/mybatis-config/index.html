<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="上一篇我们曾约定 mybatis-config.xml 文件为配置文件，SQL 语句配置文件为映射文件，本文我们将沿用上一篇中的示例程序，一起探究一下 MyBatis 加载和解析配置文件（即 mybatis-config.xml）的过程。                     配置文件的加载过程       在示例程序中，执行配置文件（包括后面要介绍的映射文件）加载与解析的过程位于第一行代码中（">
<meta property="og:type" content="article">
<meta property="og:title" content="MyBatis 源码解析：配置文件的加载与解析">
<meta property="og:url" content="https://plotor.github.io/2017/10/12/mybatis/mybatis-config/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="上一篇我们曾约定 mybatis-config.xml 文件为配置文件，SQL 语句配置文件为映射文件，本文我们将沿用上一篇中的示例程序，一起探究一下 MyBatis 加载和解析配置文件（即 mybatis-config.xml）的过程。                     配置文件的加载过程       在示例程序中，执行配置文件（包括后面要介绍的映射文件）加载与解析的过程位于第一行代码中（">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-10-12T13:35:30.000Z">
<meta property="article:modified_time" content="2025-07-05T07:02:00.445Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="MyBatis">
<meta name="twitter:card" content="summary"><title>MyBatis 源码解析：配置文件的加载与解析 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2017/10/12/mybatis/mybatis-config/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">MyBatis 源码解析：配置文件的加载与解析</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2017-10-12</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">9.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">46分</span></span></div></header><div class="post-body"><p>上一篇我们曾约定 <code>mybatis-config.xml</code> 文件为配置文件，SQL 语句配置文件为映射文件，本文我们将沿用上一篇中的示例程序，一起探究一下 MyBatis 加载和解析配置文件（即 <code>mybatis-config.xml</code>）的过程。</p>

        <h3 id="配置文件的加载过程">
          <a href="#配置文件的加载过程" class="heading-link"><i class="fas fa-link"></i></a>配置文件的加载过程</h3>
      <p>在示例程序中，执行配置文件（包括后面要介绍的映射文件）加载与解析的过程位于第一行代码中（如下）。其中，Resources 是一个简单的基于类路径或其它位置获取数据流的工具类，借助该工具类可以获取配置文件的 InputStream 流对象，然后将其传递给 <code>SqlSessionFactoryBuilder#build</code> 方法以构造 SqlSessionFactory 对象。<a id="more"></a></p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">                .build(Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>));</span><br></pre></td></tr></tbody></table></div></figure>
<p>SqlSessionFactoryBuilder 由名字可知它是一个构造器，用于构造 SqlSessionFactory 对象。按照 MyBatis 的官方文档来说，SqlSessionFactoryBuilder 一旦构造完 SqlSessionFactory 对象便完成了其使命。其实现也比较简单，只定义了 <code>SqlSessionFactoryBuilder#build</code> 这一个方法及其重载版本，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 创建 XML 配置文件解析器，期间会创建 Configuration 对象</span></span><br><span class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">        <span class="comment">// 解析配置文件填充 Configuration 对象，并基于配置构造 SqlSessionFactory</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.build(parser.parse());</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 执行关闭前的清理工作</span></span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            inputStream.close();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现的核心在于如下两行：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line"><span class="number">2.</span> <span class="keyword">return</span> <span class="keyword">this</span>.build(parser.parse());</span><br></pre></td></tr></tbody></table></div></figure>
<p>第一行用来构造 XMLConfigBuilder 对象，XMLConfigBuilder 可以看作是 <code>mybatis-config.xml</code> 配置文件的解析器；第二行则调用该对象的 <code>XMLConfigBuilder#parse</code> 方法对配置文件进行解析，并记录相关配置项到 Configuration 对象中，然后基于该配置对象创建 SqlSessionFactory 对象返回。Configuration 可以看作是 MyBatis 框架内部全局唯一的配置类，用于记录几乎所有的配置和映射，以及运行过程中的中间值。后面我们会经常遇到这个类，现在可以将其理解为 MyBatis 框架的配置中心。</p>
<p>我们来看一下 XMLConfigBuilder 对象的构造过程：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XMLConfigBuilder</span><span class="params">(InputStream inputStream, String environment, Properties props)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(</span><br><span class="line">        <span class="comment">// 构造 XPath 解析器</span></span><br><span class="line">        <span class="keyword">new</span> XPathParser(inputStream, <span class="keyword">true</span>, props, <span class="keyword">new</span> XMLMapperEntityResolver()),</span><br><span class="line">        environment,</span><br><span class="line">        props);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">XMLConfigBuilder</span><span class="params">(XPathParser parser, // XPath 解析器</span></span></span><br><span class="line"><span class="function"><span class="params">                         String environment, // 当前使用的配置文件组 ID</span></span></span><br><span class="line"><span class="function"><span class="params">                         Properties props)</span> <span class="comment">// 参数指定的配置项</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 构造 Configuration 对象</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> Configuration());</span><br><span class="line">    ErrorContext.instance().resource(<span class="string">"SQL Mapper Configuration"</span>);</span><br><span class="line">    <span class="comment">// 将参数指定的配置项记录到 Configuration#variables 属性中</span></span><br><span class="line">    <span class="keyword">this</span>.configuration.setVariables(props);</span><br><span class="line">    <span class="comment">// 标识配置文件还未被解析</span></span><br><span class="line">    <span class="keyword">this</span>.parsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    <span class="keyword">this</span>.parser = parser;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>构造方法各参数的释义见代码注释。这里针对一些比较不太直观的参数作进一步说明，首先看一下 XPathParser 类型的构造参数。我们需要知道的一点是，MyBatis 基于 DOM 树对 XML 配置文件进行解析，而操作 DOM 树的方式则是基于 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/XPath">XPath(XML Path Language)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。它是一种能够极大简化 XML 操作的路径语言，优点在于简单、直观，并且好用，没有接触过的同学可以针对性的学习一下。XPathParser 基于 XPath 语法对 XML 进行解析，其实现比较简单，这里不展开说明。</p>
<p>接着看一下 environment 参数。基于配置的框架一般都允许配置多套环境，以应对开发、测试、灰度，以及生产环境。除了后面会讲到的 <code>&lt;environment/&gt;</code> 配置，MyBatis 也允许我们通过参数指定实际生效的配置环境，我们在调用 <code>SqlSessionFactoryBuilder#build</code> 方法时，可以以参数形式指定当前使用的配置环境。</p>

        <h3 id="配置文件的解析过程">
          <a href="#配置文件的解析过程" class="heading-link"><i class="fas fa-link"></i></a>配置文件的解析过程</h3>
      <p>完成了 XMLConfigBuilder 对象的构造，下一步会调用其 <code>XMLConfigBuilder#parse</code> 方法执行对配置文件的解析操作。在具体分析配置文件的解析过程之前，先简单介绍一下后续过程依赖的一些基础组件。</p>
<p>上面用到的 XMLConfigBuilder 类派生自 BaseBuilder 抽象类，包括后面会介绍的 XMLMapperBuilder、XMLStatementBuilder，以及 SqlSourceBuilder 等都继承自该抽象类。先来看一下 BaseBuilder 的字段定义：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 全局唯一的配置对象 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="comment">/** 记录别名与类型的映射关系 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry;</span><br><span class="line"><span class="comment">/** 记录类型对应的类型处理器 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br></pre></td></tr></tbody></table></div></figure>
<p>BaseBuilder 仅定义了三个属性，各属性的作用见代码注释。XMLConfigBuilder 构造方法调用了父类 BaseBuilder 的构造方法以实现对这三个属性的初始化，前面我们提及到的封装全局配置的 Configuration 对象就记录在这里。接下来分析一下属性 <code>BaseBuilder#typeAliasRegistry</code> 和 <code>BaseBuilder#typeHandlerRegistry</code> 分别对应的 TypeAliasRegistry 类和 TypeHandlerRegistry 类的功能和实现。</p>
<ul>
<li><strong>TypeAliasRegistry</strong></li>
</ul>
<p>我们都知道在编写 SQL 语句时可以为表名或列名定义别名（alias），以减少书写量，而 TypeAliasRegistry 是对别名这一机制的延伸，借助于此，我们可以为任意类型定义别名。</p>
<p>TypeAliasRegistry 中仅定义了一个 Map 类型的属性 <code>TypeAliasRegistry#typeAliases</code> 充当内存数据库，记录着别名与具体类型之间的映射关系。TypeAliasRegistry 持有一个无参数的构造方法，其中只做一件事，即调用 <code>TypeAliasRegistry#registerAlias</code> 方法为常用类型注册对应的别名。该方法的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String alias, Class&lt;?&gt; value)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (alias == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"The parameter alias cannot be null"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 将别名转换成小写</span></span><br><span class="line">    String key = alias.toLowerCase(Locale.ENGLISH);</span><br><span class="line">    <span class="comment">// 防止重复注册</span></span><br><span class="line">    <span class="keyword">if</span> (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != <span class="keyword">null</span> &amp;&amp; !typeAliases.get(key).equals(value)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"The alias '"</span> + alias + <span class="string">"' is already mapped to the value '"</span> + typeAliases.get(key).getName() + <span class="string">"'."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 建立映射关系记录到 Map 中</span></span><br><span class="line">    typeAliases.put(key, value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>整个方法的执行过程本质上就是将 <code>(alias, value)</code> 键值对写入 Map 集合中，只是在插入之前需要保证 alias 不为 null，且不允许相同的别名和类型重复注册。除了这里的单个注册，TypeAliasRegistry 还提供了 <code>TypeAliasRegistry#registerAliases</code> 方法，允许扫描注册指定 package 下面的所有类或指定类型及其子类型。在批量扫描注册时，我们可以利用 <code>@Alias</code> 注解为类指定别名，否则 MyBatis 将会以当前类的 simple name 作为类型别名。</p>
<p>当然，能够注册就能够获取，方法 <code>TypeAliasRegistry#resolveAlias</code> 提供了获取指定别名对应类型的能力。实现比较简单，无非就是从 Map 集合中获取指定 key 对应的 value。</p>
<ul>
<li><strong>TypeHandlerRegistry</strong></li>
</ul>
<p>再来看一下 TypeHandlerRegistry 类，在开始分析之前我们必须对 TypeHandler 接口有一个了解。我们都知道 JDBC 定义的类型（枚举类 JdbcType 对已有 JDBC 类型进行了封装）与 java 定义的类型并不是完全匹配的，所以就需要在这中间执行一些转换操作，而 TypeHandler 的职责就在于此。TypeHandler 是一个接口，其中定义了 4 个方法：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 为 {<span class="doctag">@link</span> PreparedStatement} 对象绑定参数（将数据由 java 类型转换成 JDBC 类型） */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取结果集中对应的参数值（将数据由 JDBC 类型转换成 java 类型） */</span></span><br><span class="line">    <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取存储过程中输出类型的参数值（将数据由 JDBC 类型转换成 java 类型） */</span></span><br><span class="line">    <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>围绕 TypeHandler 接口的实现类用于处理特定类型，具体可以参考 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
<p>对 TypeHandler 有一个基本认识之后，继续来看 TypeHandlerRegistry。顾名思义，这是一个 TypeHandler 的注册中心。TypeHandlerRegistry 中定义了多个 final 类型 Map 类型属性，以记录类型及其类型处理器 TypeHandler 之间的映射关系，其中最核心的两个属性定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录 JDBC 类型与 {<span class="doctag">@link</span> TypeHandler} 之间映射关系，</span></span><br><span class="line"><span class="comment"> * 用于从结果集读取数据时，将 JDBC 类型转换对应的 java 类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcTypeHandlerMap = <span class="keyword">new</span> EnumMap&lt;&gt;(JdbcType.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录 java 类型转 JDBC 类型时所需要的 {<span class="doctag">@link</span> TypeHandler}，</span></span><br><span class="line"><span class="comment"> * 一个 java 类型可能存在多个 JDBC 类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></tbody></table></div></figure>
<p>在构造 TypeHandlerRegistry 对象时，会调用 <code>TypeHandlerRegistry#register</code> 方法注册类型及其对应的类型处理器，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果 javaType 不为空，则添加对应的类型处理器到 typeHandlerMap 集合中</span></span><br><span class="line">    <span class="keyword">if</span> (javaType != <span class="keyword">null</span>) {</span><br><span class="line">        Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = typeHandlerMap.get(javaType);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span> || map == NULL_TYPE_HANDLER_MAP) {</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        }</span><br><span class="line">        map.put(jdbcType, handler);</span><br><span class="line">        typeHandlerMap.put(javaType, map);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 记录所有的 TypeHandler 对象</span></span><br><span class="line">    allTypeHandlersMap.put(handler.getClass(), handler);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的核心逻辑在于往 <code>TypeHandlerRegistry#typeHandlerMap</code> 属性中注册 java 类型及其类型处理器。MyBatis 基于该方法封装了多层重载版本，其中大部分实现都比较简单，下面就基于注解 <code>@MappedJdbcTypes</code> 和注解 <code>@MappedTypes</code> 指定对应类型的版本进一步说明。</p>
<p>注解 <code>@MappedJdbcTypes</code> 用于指定类型处理器 TypeHandler 关联的 JDBC 类型列表，对应的解析实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 MappedJdbcTypes 注解配置</span></span><br><span class="line">    MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);</span><br><span class="line">    <span class="keyword">if</span> (mappedJdbcTypes != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 一个 TypeHandler 可以关联多个 JDBC 类型，遍历逐一注册</span></span><br><span class="line">        <span class="keyword">for</span> (JdbcType handledJdbcType : mappedJdbcTypes.value()) {</span><br><span class="line">            <span class="keyword">this</span>.register(javaType, handledJdbcType, typeHandler);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 允许处理 null 值</span></span><br><span class="line">        <span class="keyword">if</span> (mappedJdbcTypes.includeNullJdbcType()) {</span><br><span class="line">            <span class="keyword">this</span>.register(javaType, <span class="keyword">null</span>, typeHandler);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">this</span>.register(javaType, <span class="keyword">null</span>, typeHandler);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先获取注解 <code>@MappedJdbcTypes</code> 配置的 JDBC 类型列表，然后遍历挨个注册。注解 <code>@MappedJdbcTypes</code> 定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MappedJdbcTypes {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前类型处理器能够处理的 JDBC 类型列表 */</span></span><br><span class="line">    JdbcType[] value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 是否允许处理 null 值 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">includeNullJdbcType</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>该注解还允许通过 <code>MappedJdbcTypes#includeNullJdbcType</code> 属性指定是否允许当前类型处理器处理 null 值。</p>
<p>能够指定 JDBC 类型，当然也就能够指定 JAVA 类型。注解 <code>@MappedTypes</code> 用于指定与类型处理器 TypeHandler 关联的 java 类型，对应的解析实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(TypeHandler&lt;T&gt; typeHandler)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> mappedTypeFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取 MappedTypes 注解配置</span></span><br><span class="line">    MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class);</span><br><span class="line">    <span class="keyword">if</span> (mappedTypes != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 一个 TypeHandler 可以关联多个 java 类型，遍历逐一注册</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; handledType : mappedTypes.value()) {</span><br><span class="line">            <span class="keyword">this</span>.register(handledType, typeHandler);</span><br><span class="line">            mappedTypeFound = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 尝试基于 typeHandler 自动发现对应的 java 类型，需要实现 TypeReference 接口（@since 3.1.0）</span></span><br><span class="line">    <span class="keyword">if</span> (!mappedTypeFound &amp;&amp; typeHandler <span class="keyword">instanceof</span> TypeReference) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler;</span><br><span class="line">            <span class="keyword">this</span>.register(typeReference.getRawType(), typeHandler);</span><br><span class="line">            mappedTypeFound = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            <span class="comment">// maybe users define the TypeReference with a different type and are not assignable, so just ignore it</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!mappedTypeFound) {</span><br><span class="line">        <span class="keyword">this</span>.register((Class&lt;T&gt;) <span class="keyword">null</span>, typeHandler);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先获取 <code>@MappedTypes</code> 注解配置，并针对关联的 java 类型逐一注册。如果未指定 <code>@MappedTypes</code> 注解配置，则 MyBatis 会尝试自动发现并注册 TypeHandler 能够处理的 java 类型。</p>
<p>能够注册也就能够获取，TypeHandlerRegistry 中提供了 <code>TypeHandlerRegistry#getTypeHandler</code> 方法的多种重载实现，比较简单，不再展开。</p>
<p>回过头再来看一下 BaseBuilder 抽象类的实现，其中定义了许多方法，但是只要了解上面介绍的 TypeAliasRegistry 和 TypeHandlerRegistry 类，那么这些方法的作用在理解上应该非常容易，这里就不多做撰述，有兴趣的同学可以参考上面的分析去阅读一下源码。</p>
<p>下面正式进入主题，回到 <code>XMLConfigBuilder#parse</code> 方法分析配置文件的解析过程，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 配置文件已经被解析过，避免重复解析</span></span><br><span class="line">    <span class="keyword">if</span> (parsed) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">    }</span><br><span class="line">    parsed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 解析 mybatis-config.xml 中的各项配置，填充 Configuration 对象</span></span><br><span class="line">    <span class="keyword">this</span>.parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>配置文件 <code>mybatis-config.xml</code> 以 <code>&lt;configuration/&gt;</code> 标签作为配置文件根节点，上述方法的核心在于触发调用 <code>XMLConfigBuilder#parseConfiguration</code> 方法对配置文件的各个元素进行解析，并封装解析结果到 Configuration 对象中，最终返回该配置对象。方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 解析 &lt;properties/&gt; 配置</span></span><br><span class="line">        <span class="keyword">this</span>.propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;settings/&gt; 配置</span></span><br><span class="line">        Properties settings = <span class="keyword">this</span>.settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">        <span class="comment">// 获取并设置 vfsImpl 属性</span></span><br><span class="line">        <span class="keyword">this</span>.loadCustomVfs(settings);</span><br><span class="line">        <span class="comment">// 获取并设置 logImpl 属性</span></span><br><span class="line">        <span class="keyword">this</span>.loadCustomLogImpl(settings);</span><br><span class="line">        <span class="comment">// 解析 &lt;typeAliases/&gt; 配置</span></span><br><span class="line">        <span class="keyword">this</span>.typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;plugins/&gt; 配置</span></span><br><span class="line">        <span class="keyword">this</span>.pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;objectFactory/&gt; 配置</span></span><br><span class="line">        <span class="keyword">this</span>.objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;objectWrapperFactory/&gt; 配置</span></span><br><span class="line">        <span class="keyword">this</span>.objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;reflectorFactory/&gt; 配置</span></span><br><span class="line">        <span class="keyword">this</span>.reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">        <span class="comment">// 将 settings 配置设置到 Configuration 对象中</span></span><br><span class="line">        <span class="keyword">this</span>.settingsElement(settings);</span><br><span class="line">        <span class="comment">// 解析 &lt;environments/&gt; 配置</span></span><br><span class="line">        <span class="keyword">this</span>.environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;databaseIdProvider/&gt; 配置</span></span><br><span class="line">        <span class="keyword">this</span>.databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;typeHandlers/&gt; 配置</span></span><br><span class="line">        <span class="keyword">this</span>.typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;mappers/&gt; 配置</span></span><br><span class="line">        <span class="keyword">this</span>.mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法在实现上比较直观，各配置项的解析都采用专门的方法进行封装，接下来会逐一进行分析。其中 <code>&lt;plugins/&gt;</code> 标签用于配置自定义插件，以拦截 SQL 语句的执行过程，相应的解析过程暂时先不展开，留到后面专门介绍插件的实现机制的文章中一并分析。</p>

        <h4 id="解析-properties-标签">
          <a href="#解析-properties-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 properties 标签</h4>
      <p>先来看一下 <code>&lt;properties/&gt;</code> 标签怎么玩，其中的配置项可以在整个配置文件中用来动态替换占位符。配置项可以从外部 properties 文件读取，也可以通过 <code>&lt;property/&gt;</code> 子标签指定。假设我们希望通过该标签指定数据源配置，如下：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"datasource.properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为占位符启用默认值配置，默认关闭，需要采用如下方式开启--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"org.apache.ibatis.parsing.PropertyParser.enable-default-value"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>文件 <code>datasource.properties</code> 内容：</p>
<figure class="highlight properties"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>然后可以基于 OGNL 表达式在其它配置项中引用这些配置值，如下：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span> <span class="comment">&lt;!--or UNPOOLED or JNDI--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"${driver}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${url}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${username:zhenchao}"</span>/&gt;</span> <span class="comment">&lt;!--占位符设置默认值，需要专门开启--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${password}"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>其中，除了 driver 属性值来自 <code>&lt;property/&gt;</code> 子标签，其余属性值均是从 <code>datasource.properties</code> 配置文件中获取的。</p>
<p>MyBatis 针对配置的读取顺序约定如下：</p>
<ol>
<li>在 <code>&lt;properties/&gt;</code> 标签体内指定的属性首先被读取；</li>
<li>然后，根据 <code>&lt;properties/&gt;</code> 标签中 resource 属性读取类路径下配置文件，或根据 url 属性指定的路径读取指向的配置文件，并覆盖已读取的同名配置项；</li>
<li>最后，读取方法参数传递的配置项，并覆盖已读取的同名配置项。</li>
</ol>
<p>下面分析一下 <code>&lt;properties/&gt;</code> 标签的解析过程，由 <code>XMLConfigBuilder#propertiesElement</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">propertiesElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 获取 &lt;property/&gt; 子标签列表，封装成 Properties 对象</span></span><br><span class="line">        Properties defaults = context.getChildrenAsProperties();</span><br><span class="line">        <span class="comment">// 支持通过 resource 或 url 属性指定外部配置文件</span></span><br><span class="line">        String resource = context.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">        String url = context.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">        <span class="comment">// 这两种类型的配置是互斥的</span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"The properties element cannot specify both a URL "</span> +</span><br><span class="line">                <span class="string">"and a resource based property file reference.  Please specify one or the other."</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从类路径加载配置文件</span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span>) {</span><br><span class="line">            defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从 url 指定位置加载配置文件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (url != <span class="keyword">null</span>) {</span><br><span class="line">            defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 合并已有的配置项</span></span><br><span class="line">        Properties vars = configuration.getVariables();</span><br><span class="line">        <span class="keyword">if</span> (vars != <span class="keyword">null</span>) {</span><br><span class="line">            defaults.putAll(vars);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 填充 XPathParser 和 Configuration 对象</span></span><br><span class="line">        parser.setVariables(defaults);</span><br><span class="line">        configuration.setVariables(defaults);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由 MyBatis 的官方文档可知，标签 <code>&lt;properties/&gt;</code> 支持以 resource 属性或 url 属性指定配置文件所在的路径，由上述实现也可以看出这两个属性配置是互斥的。在将对应的配置加载成为 Properties 对象之后，上述方法会合并 Configuration 对象中已有的配置项，并将结果再次填充到 XPathParser 和 Configuration 对象中，以备后用。</p>

        <h4 id="解析-settings-标签">
          <a href="#解析-settings-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 settings 标签</h4>
      <p>MyBatis 通过 <code>&lt;settings/&gt;</code> 标签提供一些全局性的配置，这些配置会影响 MyBatis 的运行行为。<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 对这些配置项进行了详细的说明，下面的配置摘自官方文档，其中各项的含义可以参考文档说明：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"multipleResultSetsEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useColumnLabel"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedKeys"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingBehavior"</span> <span class="attr">value</span>=<span class="string">"PARTIAL"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingUnknownColumnBehavior"</span> <span class="attr">value</span>=<span class="string">"WARNING"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"SIMPLE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultStatementTimeout"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultFetchSize"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"safeRowBoundsEnabled"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"jdbcTypeForNull"</span> <span class="attr">value</span>=<span class="string">"OTHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadTriggerMethods"</span> <span class="attr">value</span>=<span class="string">"equals,clone,hashCode,toString"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>MyBatis 对于该标签的解析实现十分简单，首先调用 <code>XMLConfigBuilder#settingsAsProperties</code> 方法获取配置项对应的 Properties 对象，同时会检查配置项是否是可识别的，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">settingsAsProperties</span><span class="params">(XNode context)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Properties();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解析 &lt;setting/&gt; 配置，封装成 Properties 对象</span></span><br><span class="line">    Properties props = context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 构造 Configuration 对应的 MetaClass 对象，用于对 Configuration 类提供反射操作</span></span><br><span class="line">    MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">    <span class="comment">// 遍历配置项，确保配置项是 MyBatis 可识别的</span></span><br><span class="line">    <span class="keyword">for</span> (Object key : props.keySet()) {</span><br><span class="line">        <span class="comment">// 属性对应的 setter 方法不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!metaConfig.hasSetter(String.valueOf(key))) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(</span><br><span class="line">                <span class="string">"The setting "</span> + key + <span class="string">" is not known.  Make sure you spelled it correctly (case sensitive)."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>接下来调用 <code>XMLConfigBuilder#loadCustomVfs</code> 方法和 <code>XMLConfigBuilder#loadCustomLogImpl</code> 方法分别解析 <code>vfsImpl</code> 和 <code>logImpl</code> 配置项，其中 <code>vfsImpl</code> 配置项用于设置自定义 VFS 的实现类全限定名，以逗号分隔。所有的 <code>&lt;settings/&gt;</code> 配置项最后都会通过 <code>XMLConfigBuilder#settingsElement</code> 方法记录到 Configuration 对象对应的属性中。</p>

        <h4 id="解析-typeAliases-和-typeHandlers-标签">
          <a href="#解析-typeAliases-和-typeHandlers-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 typeAliases 和 typeHandlers 标签</h4>
      <p>前面介绍了 TypeAliasRegistry 和 TypeHandlerRegistry 两个类的功能和实现，本小节介绍的这两个标签分别对应这两个类的相关配置，前者用于配置类型及其别名的映射关系，后者用于配置类型及其类型处理器 TypeHandler 之间的映射关系。二者在实现上基本相同，这里以 <code>&lt;typeAliases/&gt;</code> 标签的解析过程为例进行分析（由 <code>XMLConfigBuilder#typeAliasesElement</code> 方法实现），有兴趣的读者可以自己阅读 <code>&lt;typeHandlers/&gt;</code> 标签的相关实现。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">typeAliasesElement</span><span class="params">(XNode parent)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (XNode child : parent.getChildren()) {</span><br><span class="line">            <span class="comment">// 子标签是 &lt;package name=""/&gt; 配置</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) {</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果指定了一个包名，MyBatis 会在包名下搜索需要的 Java Bean，并处理 @Alias 注解，</span></span><br><span class="line"><span class="comment">                 * 在没有注解的情况下，会使用 Bean 的首字母小写的简单名称作为它的别名。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                String typeAliasPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">                configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 子标签是 &lt;typeAlias alias="" type=""/&gt; 配置</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                String alias = child.getStringAttribute(<span class="string">"alias"</span>); <span class="comment">// 别名</span></span><br><span class="line">                String type = child.getStringAttribute(<span class="string">"type"</span>); <span class="comment">// 类型限定名</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 获取类型对应的 Class 对象</span></span><br><span class="line">                    Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">                    <span class="comment">// 未配置 alias，先尝试获取 @Alias 注解，如果没有则使用类的简单名称</span></span><br><span class="line">                    <span class="keyword">if</span> (alias == <span class="keyword">null</span>) {</span><br><span class="line">                        typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 配置了 alias，使用该 alias 进行注册</span></span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error registering typeAlias for '"</span> + alias + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>标签 <code>&lt;typeAliases/&gt;</code> 具备两种配置方式，单一注册与批量扫描，具体使用可以参考 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。对应的实现也需要区分这两种情况，如果是批量扫描，即子标签是 <code>&lt;package/&gt;</code>，则会调用 <code>TypeAliasRegistry#registerAliases</code> 方法进行扫描注册：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAliases</span><span class="params">(String packageName)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.registerAliases(packageName, Object.class);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAliases</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取指定 package 下所有 superType 类型及其子类型</span></span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil&lt;&gt;();</span><br><span class="line">    resolverUtil.find(<span class="keyword">new</span> ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();</span><br><span class="line">    <span class="comment">// 遍历处理扫描到的类型</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; type : typeSet) {</span><br><span class="line">        <span class="comment">// 忽略内部类、接口，以及抽象类</span></span><br><span class="line">        <span class="keyword">if</span> (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) {</span><br><span class="line">            <span class="comment">// 尝试获取类的 @Alias 注解，如果没有则使用类的简单名称的小写形式作为别名进行注册</span></span><br><span class="line">            <span class="keyword">this</span>.registerAlias(type);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果子标签是 <code>&lt;typeAlias alias="" type=""/&gt;</code> 这种配置形式，则会获取 alias 和 type 属性值，然后基于一定规则进行注册，具体过程如代码注释。</p>

        <h4 id="解析-objectFactory-标签">
          <a href="#解析-objectFactory-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 objectFactory 标签</h4>
      <p>在具体分析 <code>&lt;objectFactory/&gt;</code> 标签的解析实现之前，我们必须先了解与之密切相关的 ObjectFactory 接口。由名字我们可以猜测这是一个工厂类，并且是创建对象的工厂，定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span> </span>{</span><br><span class="line">    <span class="comment">/** 设置配置信息 */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>{ }</span><br><span class="line">    <span class="comment">/** 基于无参构造方法创建指定类型对象 */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line">    <span class="comment">/** 基于指定的构造参数（类型）选择对应的构造方法创建目标对象 */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span></span>;</span><br><span class="line">    <span class="comment">/** 检测指定类型是否是集合类型 */</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>各方法的作用如代码注释，DefaultObjectFactory 类是该接口的默认实现。下面重点看一下基于指定构造参数（类型）选择对应的构造方法创建目标对象的实现细节：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果传入的是接口类型，则选择具体的实现类型以创建对象，毕竟接口类型不能被实例化</span></span><br><span class="line">    Class&lt;?&gt; classToCreate = <span class="keyword">this</span>.resolveInterface(type);</span><br><span class="line">    <span class="comment">// 基于入参选择合适的构造方法进行实例化</span></span><br><span class="line">    <span class="keyword">return</span> (T) <span class="keyword">this</span>.instantiateClass(classToCreate, constructorArgTypes, constructorArgs);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先会判断当前指定的类型是否是接口类型，因为接口类型无法实例化，所以需要选择相应的实现类代替。例如当我们传递的是一个 List 接口类型会返回相应的 ArrayList 实现类型。再来看一下 <code>DefaultObjectFactory#instantiateClass</code> 方法的实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Constructor&lt;T&gt; constructor;</span><br><span class="line">        <span class="comment">// 如果没有传递构造参数或类型，则使用无参构造方法创建对象</span></span><br><span class="line">        <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) {</span><br><span class="line">            constructor = type.getDeclaredConstructor();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">            } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line">                <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) {</span><br><span class="line">                    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则选择对应的构造方法创建对象</span></span><br><span class="line">        constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">        } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line">            <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) {</span><br><span class="line">                constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="comment">// ... 异常处理略</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法主要基于传递的参数以决策具体创建对象的构造方法版本，并基于反射机制创建对象。</p>
<p>所以说 ObjectFactory 接口的作用主要是对我们传递的类型进行实例化，默认的实现版本比较简单。如果默认实现不能满足需求，则可以扩展 ObjectFactory 接口，并将相应的自定义实现通过 <code>&lt;objectFactory/&gt;</code> 标签进行注册，具体的使用方式参见 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。我们继续分析针对该标签的解析过程，由 <code>XMLConfigBuilder#objectFactoryElement</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">objectFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 获取 type 属性配置，对应自定义对象工厂类</span></span><br><span class="line">        String type = context.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">        <span class="comment">// 获取 &lt;property/&gt; 子标签列表，封装成 Properties 对象</span></span><br><span class="line">        Properties properties = context.getChildrenAsProperties();</span><br><span class="line">        <span class="comment">// 实例化自定义工厂类对象</span></span><br><span class="line">        ObjectFactory factory = (ObjectFactory) <span class="keyword">this</span>.resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">// 设置属性配置</span></span><br><span class="line">        factory.setProperties(properties);</span><br><span class="line">        <span class="comment">// 填充 Configuration 对象</span></span><br><span class="line">        configuration.setObjectFactory(factory);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>解析 <code>&lt;objectFactory/&gt;</code> 标签的基本流程就是获取我们在标签中通过 type 属性指定的自定义 ObjectFactory 实现类的全限定名和相应属性配置；然后构造自定义 ObjectFactory 实现类对象，并将获取到的配置项列表记录到对象中；最后将自定义 ObjectFactory 对象填充到 Configuration 对象中。</p>

        <h4 id="解析-reflectorFactory-标签">
          <a href="#解析-reflectorFactory-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 reflectorFactory 标签</h4>
      <p>标签 <code>&lt;reflectorFactory/&gt;</code> 用于注册自定义 ReflectorFactory 实现，该标签的解析过程与 <code>&lt;objectFactory/&gt;</code> 标签基本相同，不再重复撰述，本小节重点分析一下该标签涉及到相关类的功能与实现。</p>
<p>ReflectorFactory 顾名思义是一个 Reflector 工厂，接口定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReflectorFactory</span> </span>{</span><br><span class="line">    <span class="comment">/** 是否缓存 {<span class="doctag">@link</span> Reflector} 对象 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isClassCacheEnabled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/** 设置是否缓存 {<span class="doctag">@link</span> Reflector} 对象 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setClassCacheEnabled</span><span class="params">(<span class="keyword">boolean</span> classCacheEnabled)</span></span>;</span><br><span class="line">    <span class="comment">/** 获取指定类型的 {<span class="doctag">@link</span> Reflector} 对象 */</span></span><br><span class="line">    <span class="function">Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>默认实现类 DefaultReflectorFactory 通过一个 boolean 变量 <code>DefaultReflectorFactory#classCacheEnabled</code> 记录是否启用缓存，并通过一个线程安全的 Map 集合 <code>DefaultReflectorFactory#reflectorMap</code> 记录缓存的 Reflector 对象，相应的方法实现都十分简单，不再展开。</p>
<p>ReflectorFactory 本质上是用来创建和管理 Reflector 对象，那么 Reflector 又是什么呢？我们先来看一下 Reflector 的属性和构造方法定义：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflector</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 隶属的 Class 类型 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">    <span class="comment">/** 可读属性名称集合 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line">    <span class="comment">/** 可写属性名称集合 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames;</span><br><span class="line">    <span class="comment">/** 属性对应的 setter 方法（封装成 Invoker 对象） */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;String, Invoker&gt;();</span><br><span class="line">    <span class="comment">/** 属性对应的 getter 方法（封装成 Invoker 对象） */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;String, Invoker&gt;();</span><br><span class="line">    <span class="comment">/** 属性对应 setter 方法的入参类型 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">/** 属性对应 getter 方法的返回类型 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">/** 记录默认构造方法 */</span></span><br><span class="line">    <span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line">    <span class="comment">/** 记录所有的属性名称 */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>{</span><br><span class="line">        type = clazz;</span><br><span class="line">        <span class="comment">// 解析获取默认构造方法（无参构造方法）</span></span><br><span class="line">        <span class="keyword">this</span>.addDefaultConstructor(clazz);</span><br><span class="line">        <span class="comment">// 解析获取所有的 getter 方法，并记录到 getMethods 与 getTypes 属性中</span></span><br><span class="line">        <span class="keyword">this</span>.addGetMethods(clazz);</span><br><span class="line">        <span class="comment">// 解析获取所有的 setter 方法，并记录到 setMethods 与 setTypes 属性中</span></span><br><span class="line">        <span class="keyword">this</span>.addSetMethods(clazz);</span><br><span class="line">        <span class="comment">// 解析获取所有没有 setter/getter 方法的字段，并添加到相应的集合中</span></span><br><span class="line">        <span class="keyword">this</span>.addFields(clazz);</span><br><span class="line">        <span class="comment">// 填充可读属性名称数组</span></span><br><span class="line">        readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[getMethods.keySet().size()]);</span><br><span class="line">        <span class="comment">// 填充可写属性名称数组</span></span><br><span class="line">        writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[setMethods.keySet().size()]);</span><br><span class="line">        <span class="comment">// 记录所有属性名称到 Map 集合中</span></span><br><span class="line">        <span class="keyword">for</span> (String propName : readablePropertyNames) {</span><br><span class="line">            caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (String propName : writablePropertyNames) {</span><br><span class="line">            caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ... 省略方法实现</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>可以看到 Reflector 是对指定 Class 对象的封装，记录了对应的 Class 类型、属性、getter 和 setter 方法列表等信息，是反射操作的基础，其中的方法实现虽然较长，但是逻辑都比较简单，读者可以自行阅读源码。</p>

        <h4 id="解析-objectWrapperFactory-标签">
          <a href="#解析-objectWrapperFactory-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 objectWrapperFactory 标签</h4>
      <p>标签 <code>&lt;objectWrapperFactory/&gt;</code> 用于注册自定义 ObjectWrapperFactory 实现，该标签的解析过程与 <code>&lt;objectFactory/&gt;</code> 标签基本相同，同样不再重复撰述，本小节重点分析该标签涉及到相关类的功能与实现。</p>
<p>ObjectWrapperFactory 顾名思义是一个 ObjectWrapper 工厂，其默认实现 DefaultObjectWrapperFactory 并没有实现有用的逻辑，所以可以忽略。然而，借助 <code>&lt;reflectorFactory/&gt;</code> 标签，我们可以注册自定义的 ObjectWrapperFactory 实现。</p>
<p>被 ObjectWrapperFactory 创建和管理的 ObjectWrapper 是一个接口，用于包装和处理对象，其中声明了多个操作对象的方法，包括获取、更新对象属性等，接口定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapper</span> </span>{</span><br><span class="line">    <span class="comment">/** 获取对应属性的值（对于集合而言，则是获取对应下标的值） */</span></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span></span>;</span><br><span class="line">    <span class="comment">/** 设置对应属性的值（对于集合而言，则是设置对应下标的值）*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span></span>;</span><br><span class="line">    <span class="comment">/** 查找属性表达式对应的属性 */</span></span><br><span class="line">    <span class="function">String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span></span>;</span><br><span class="line">    <span class="comment">/** 获取可读属性名称集合 */</span></span><br><span class="line">    String[] getGetterNames();</span><br><span class="line">    <span class="comment">/** 获取可写属性名称集合 */</span></span><br><span class="line">    String[] getSetterNames();</span><br><span class="line">    <span class="comment">/** 获取属性表达式指定属性 setter 方法的入参类型 */</span></span><br><span class="line">    Class&lt;?&gt; getSetterType(String name);</span><br><span class="line">    <span class="comment">/** 获取属性表达式指定属性 getter 方法的返回类型 */</span></span><br><span class="line">    Class&lt;?&gt; getGetterType(String name);</span><br><span class="line">    <span class="comment">/** 判断属性是否有 setter 方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="comment">/** 判断属性是否有 getter 方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="comment">/** 为属性表达式指定的属性创建对应的 {<span class="doctag">@link</span> MetaObject} 对象 */</span></span><br><span class="line">    <span class="function">MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span></span>;</span><br><span class="line">    <span class="comment">/** 是否是 {<span class="doctag">@link</span> java.util.Collection} 类型 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/** 调用 {<span class="doctag">@link</span> java.util.Collection} 对应的 add 方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line">    <span class="comment">/** 调用 {<span class="doctag">@link</span> java.util.Collection} 对应的 addAll 方法 */</span></span><br><span class="line">    &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>由接口定义可以看出，ObjectWrapper 的主要作用在于简化调用方对于对象的操作。</p>

        <h4 id="解析-environments-标签">
          <a href="#解析-environments-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 environments 标签</h4>
      <p>标签 <code>&lt;environments/&gt;</code> 用于配置多套数据库环境，典型的应用场景就是在开发、测试、灰度，以及生产等环境通过该标签分别指定相应的配置。当应用需要同时操作多套数据源时，也可以基于该标签分别配置，具体的使用请参阅 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#environments">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。MyBatis 解析该标签的过程由 <code>XMLConfigBuilder#environmentsElement</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 未通过参数指定生效的 environment 配置，获取 default 属性值</span></span><br><span class="line">        <span class="keyword">if</span> (environment == <span class="keyword">null</span>) {</span><br><span class="line">            environment = context.getStringAttribute(<span class="string">"default"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 遍历处理 &lt;environment/&gt; 子标签</span></span><br><span class="line">        <span class="keyword">for</span> (XNode child : context.getChildren()) {</span><br><span class="line">            <span class="comment">// 获取 id 属性配置</span></span><br><span class="line">            String id = child.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">            <span class="comment">// 处理指定生效的 &lt;environment/&gt; 配置</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isSpecifiedEnvironment(id)) {</span><br><span class="line">                <span class="comment">// 处理 &lt;transactionManager/&gt; 子标签</span></span><br><span class="line">                TransactionFactory txFactory = <span class="keyword">this</span>.transactionManagerElement(child.evalNode(<span class="string">"transactionManager"</span>));</span><br><span class="line">                <span class="comment">// 处理 &lt;dataSource/&gt; 子标签</span></span><br><span class="line">                DataSourceFactory dsFactory = <span class="keyword">this</span>.dataSourceElement(child.evalNode(<span class="string">"dataSource"</span>));</span><br><span class="line">                <span class="comment">// 基于解析到的值构造 Environment 对象填充 Configuration 对象</span></span><br><span class="line">                DataSource dataSource = dsFactory.getDataSource();</span><br><span class="line">                Environment.Builder environmentBuilder = <span class="keyword">new</span> Environment.Builder(id)</span><br><span class="line">                    .transactionFactory(txFactory)</span><br><span class="line">                    .dataSource(dataSource);</span><br><span class="line">                configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先会判断是否通过参数指定了 environment 配置，如果没有则尝试获取 <code>&lt;environments/&gt;</code> 标签的 default 属性，说明参数指定相对于 default 属性配置优先级更高。然后开始遍历寻找并解析指定激活的 <code>&lt;environment/&gt;</code> 配置。整个解析过程主要是对 <code>&lt;transactionManager/&gt;</code> 和 <code>&lt;dataSource/&gt;</code> 两个子标签进行解析，前者用于指定 MyBatis 的事务管理器，后者用于配置数据源。</p>
<p>数据源的配置解析比较直观，下面主要看一下事务管理器配置的解析过程，由 <code>XMLConfigBuilder#transactionManagerElement</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionFactory <span class="title">transactionManagerElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 获取事务管理器类型配置：JDBC or MANAGED</span></span><br><span class="line">        String type = context.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">        <span class="comment">// 获取 &lt;property/&gt; 子标签列表，封装成 Properties 对象</span></span><br><span class="line">        Properties props = context.getChildrenAsProperties();</span><br><span class="line">        <span class="comment">// 构造对应的 TransactionFactory 对象，并填充属性值</span></span><br><span class="line">        TransactionFactory factory = (TransactionFactory) <span class="keyword">this</span>.resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">        factory.setProperties(props);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Environment declaration requires a TransactionFactory."</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>MyBatis 允许我们配置两种类型的事务管理器，即 JDBC 类型和 MANAGED 类型，引用官方文档的话来理解二者的区别：</p>
<blockquote>
<p>在 MyBatis 中有两种类型的事务管理器（也就是 <code>type="[JDBC|MANAGED]"</code>）：</p>
<ul>
<li>JDBC：这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。</li>
<li>MANAGED：这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。例如:</li>
</ul>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"MANAGED"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"closeConnection"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>

<p>提示：如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</p>
</blockquote>
<p>Transaction 接口定义了事务，并为 JDBC 类型和 MANAGED 类型提供了相应的实现，即 JdbcTransaction 和 ManagedTransaction。正如上面引用的官方文档所说的那样，MyBatis 的事务操作实现的比较简单，考虑实际应用中更多是依赖于 Spring 的事务管理器，这里也就不再深究。</p>

        <h4 id="解析-databaseIdProvider-标签">
          <a href="#解析-databaseIdProvider-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 databaseIdProvider 标签</h4>
      <p>生产环境中可能会存在同时操作多套不同类型数据库的场景，而 <code>&lt;databaseIdProvider/&gt;</code> 标签则用于配置数据库厂商标识。我们知道 SQL 不能完全做到数据库无关，且 MyBatis 暂时也还不能做到对上层完全屏蔽底层数据库的实现细节，所以在这种情况下执行 SQL 语句时，我们需要通过 databaseId 指定 SQL 应用的具体数据库类型。</p>
<p>该标签的解析过程由 <code>XMLConfigBuilder#databaseIdProviderElement</code> 方法实现，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">databaseIdProviderElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    DatabaseIdProvider databaseIdProvider = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) {</span><br><span class="line">        String type = context.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">        <span class="comment">// awful patch to keep backward compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"VENDOR"</span>.equals(type)) {</span><br><span class="line">            type = <span class="string">"DB_VENDOR"</span>; <span class="comment">// 保持兼容</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获取 &lt;property/&gt; 子节点配置</span></span><br><span class="line">        Properties properties = context.getChildrenAsProperties();</span><br><span class="line">        <span class="comment">// 构造 DatabaseIdProvider 对象</span></span><br><span class="line">        databaseIdProvider = (DatabaseIdProvider) resolveClass(type).newInstance();</span><br><span class="line">        <span class="comment">// 设置配置的属性</span></span><br><span class="line">        databaseIdProvider.setProperties(properties);</span><br><span class="line">    }</span><br><span class="line">    Environment environment = configuration.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (environment != <span class="keyword">null</span> &amp;&amp; databaseIdProvider != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 获取当前数据库环境对应的 databaseId，并记录到 Configuration.databaseId 中，已备后用</span></span><br><span class="line">        String databaseId = databaseIdProvider.getDatabaseId(environment.getDataSource());</span><br><span class="line">        configuration.setDatabaseId(databaseId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>解析过程如上述代码注释，关于该标签的使用可以参考 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>

        <h4 id="解析-mappers-标签">
          <a href="#解析-mappers-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 mappers 标签</h4>
      <p>标签 <code>&lt;mappers/&gt;</code> 用于指定映射文件列表，这是一个我们非常熟悉的标签。MyBatis 广受欢迎的一个很重要的原因是支持自己定义 SQL 语句，这样就可以保证 SQL 的优化可控。抛去注解配置 SQL 的形式（注解对于复杂 SQL 的支持较弱，一般仅用于编写简单的 SQL），对于框架自动生成的 SQL 和用户自定义的 SQL 都记录在映射 XML 文件中，标签 <code>&lt;mappers/&gt;</code> 用于指定映射文件所在的路径。</p>
<p>我们可以通过 <code>&lt;mapper resource=""&gt;</code> 或 <code>&lt;mapper url=""&gt;</code> 子标签指定映射 XML 文件所在的位置，也可以通过 <code>&lt;mapper class=""&gt;</code> 子标签指定一个或多个具体的 Mapper 接口，甚至可以通过 <code>&lt;package name=""/&gt;</code> 子标签指定映射文件所在的包名，扫描注册。</p>
<p>该标签的解析过程由 <code>XMLConfigBuilder#mapperElement</code> 方法实现，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (XNode child : parent.getChildren()) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 配置了 package 属性，从指定包下面扫描注册</span></span><br><span class="line"><span class="comment">             * &lt;mappers&gt;</span></span><br><span class="line"><span class="comment">             *      &lt;package name="org.mybatis.builder"/&gt;</span></span><br><span class="line"><span class="comment">             * &lt;/mappers&gt;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) {</span><br><span class="line">                String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">                <span class="comment">// 调用 MapperRegistry 进行注册</span></span><br><span class="line">                configuration.addMappers(mapperPackage);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 处理 resource、url，以及 class 配置的场景</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">                String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">                String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * &lt;!-- Using classpath relative resources --&gt;</span></span><br><span class="line"><span class="comment">                 * &lt;mappers&gt;</span></span><br><span class="line"><span class="comment">                 *      &lt;mapper resource="org/mybatis/builder/AuthorMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">                 *      &lt;mapper resource="org/mybatis/builder/BlogMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">                 *      &lt;mapper resource="org/mybatis/builder/PostMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">                 * &lt;/mappers&gt;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) {</span><br><span class="line">                    ErrorContext.instance().resource(resource);</span><br><span class="line">                    <span class="comment">// 从类路径获取文件输入流</span></span><br><span class="line">                    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">                    <span class="comment">// 构建 XMLMapperBuilder 对象</span></span><br><span class="line">                    XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">                    <span class="comment">// 执行映射文件解析</span></span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * &lt;!-- Using url fully qualified paths --&gt;</span></span><br><span class="line"><span class="comment">                 * &lt;mappers&gt;</span></span><br><span class="line"><span class="comment">                 *      &lt;mapper url="file:///var/mappers/AuthorMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">                 *      &lt;mapper url="file:///var/mappers/BlogMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">                 *      &lt;mapper url="file:///var/mappers/PostMapper.xml"/&gt;</span></span><br><span class="line"><span class="comment">                 * &lt;/mappers&gt;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) {</span><br><span class="line">                    ErrorContext.instance().resource(url);</span><br><span class="line">                    <span class="comment">// 基于 url 获取配置文件输入流</span></span><br><span class="line">                    InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">                    <span class="comment">// 构建 XMLMapperBuilder 对象</span></span><br><span class="line">                    XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">                    <span class="comment">// 执行映射文件解析</span></span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * &lt;!-- Using mapper interface classes --&gt;</span></span><br><span class="line"><span class="comment">                 * &lt;mappers&gt;</span></span><br><span class="line"><span class="comment">                 *      &lt;mapper class="org.mybatis.builder.AuthorMapper"/&gt;</span></span><br><span class="line"><span class="comment">                 *      &lt;mapper class="org.mybatis.builder.BlogMapper"/&gt;</span></span><br><span class="line"><span class="comment">                 *      &lt;mapper class="org.mybatis.builder.PostMapper"/&gt;</span></span><br><span class="line"><span class="comment">                 * &lt;/mappers&gt;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// 获取指定接口 Class 对象</span></span><br><span class="line">                    Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                    <span class="comment">// 调用 MapperRegistry 进行注册</span></span><br><span class="line">                    configuration.addMapper(mapperInterface);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先会判断当前是否是 package 配置，如果是则会获取配置的 package 名称，然后执行扫描注册逻辑。如果是 resource 或 url 配置，则先获取指定路径映射文件的输入流，然后构造 XMLMapperBuilder 对象对映射文件进行解析。对于 class 配置而言，则会构建接口限定名对应的 Class 对象，并调用 <code>MapperRegistry#addMapper</code> 方法执行注册。</p>
<p>整个方法的运行逻辑还是比较直观的，其中涉及到对映射文件的解析注册过程，即 XMLMapperBuilder 相关类实现，将留到下一篇介绍映射文件加载与解析时专门介绍。</p>
<p>下面来重点分析一下 MapperRegistry 类及其周边类的功能和实现。我们在使用 MyBatis 框架时需要实现数据表对应的 Mapper 接口（以后统称为 Mapper 接口），其中声明了一系列数据库操作方法。我们可以通过注解的方式在方法上编写 SQL 语句，也可以通过映射 XML 文件的方式编写和关联对应的 SQL 语句。上面解析 <code>&lt;mappers/&gt;</code> 标签实现时我们看到方法通过调用 <code>MapperRegistry#addMapper</code> 方法注册相应的 Mapper 接口，包括以 package 配置的方式在扫描获取到相应的 Mapper 接口之后，也需要通过调用该方法进行注册。MapperRegistry 类中定义了两个属性：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 全局唯一配置对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line"><span class="comment">/** 记录 Mapper 接口（Class 对象）与 {<span class="doctag">@link</span> MapperProxyFactory} 之间的映射关系 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></tbody></table></div></figure>
<p>上面调用的 <code>MapperRegistry#addMapper</code> 方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) {</span><br><span class="line">        <span class="comment">// 对应 Mapper 接口已注册</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasMapper(type)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 标记整个过程是否成功完成</span></span><br><span class="line">        <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 注册 Mapper 接口 Class 对象与 MapperProxyFactory 之间的映射关系</span></span><br><span class="line">            knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">            <span class="comment">// It's important that the type is added before the parser is run</span></span><br><span class="line">            <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">            <span class="comment">// mapper parser. If the type is already known, it won't try.</span></span><br><span class="line">            MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">            <span class="comment">// 解析 Mapper 接口中的注解 SQL 配置</span></span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (!loadCompleted) {</span><br><span class="line">                knownMappers.remove(type);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Mapper 方法必须是一个接口才会被注册，这主要是为了配合 JDK 内置的动态代理机制。上一篇介绍 MyBatis 的基本运行原理时我们曾说过，MyBatis 通过为 Mapper 接口创建相应的动态代理类以执行具体的数据库操作，这一部分的详细过程将留到后面介绍 SQL 语句执行机制时再细讲，这里先知道有这样一个概念即可。如果当前 Mapper 接口还没有被注册，则会创建对应的 MapperProxyFactory 对象并记录到 <code>MapperRegistry#knownMappers</code> 属性中，然后解析 Mapper 接口中注解的 SQL 配置，这一过程留到下一篇分析映射文件解析过程时再一并介绍。</p>

        <h3 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>到此，我们完成了对配置文件 <code>mybatis-config.xml</code> 加载和解析过程的分析。总的来说，对于配置文件的解析实际上就是将静态的 XML 配置解析成内存中的 Configuration 对象的过程。Configuration 可以看作是 MyBatis 全局的配置中心，后续对于映射文件的解析，以及 SQL 语句的执行都依赖于其中的配置项。下一篇，我们将一起来探究映射文件的加载和解析过程。</p>

        <h3 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h3>
      <ol>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis 官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/27087564/">MyBatis 技术内幕</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2017/10/12/mybatis/mybatis-config/">https://plotor.github.io/2017/10/12/mybatis/mybatis-config/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/MyBatis/">MyBatis</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2017/10/14/mybatis/mybatis-mapper/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">MyBatis 源码解析：映射文件的加载与解析</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2017/10/10/mybatis/mybatis-overview/"><span class="paginator-prev__text">MyBatis 源码解析：架构初探</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">
          配置文件的加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">
          配置文件的解析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-properties-%E6%A0%87%E7%AD%BE"><span class="toc-number">2.1.</span> <span class="toc-text">
          解析 properties 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-settings-%E6%A0%87%E7%AD%BE"><span class="toc-number">2.2.</span> <span class="toc-text">
          解析 settings 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-typeAliases-%E5%92%8C-typeHandlers-%E6%A0%87%E7%AD%BE"><span class="toc-number">2.3.</span> <span class="toc-text">
          解析 typeAliases 和 typeHandlers 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-objectFactory-%E6%A0%87%E7%AD%BE"><span class="toc-number">2.4.</span> <span class="toc-text">
          解析 objectFactory 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-reflectorFactory-%E6%A0%87%E7%AD%BE"><span class="toc-number">2.5.</span> <span class="toc-text">
          解析 reflectorFactory 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-objectWrapperFactory-%E6%A0%87%E7%AD%BE"><span class="toc-number">2.6.</span> <span class="toc-text">
          解析 objectWrapperFactory 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-environments-%E6%A0%87%E7%AD%BE"><span class="toc-number">2.7.</span> <span class="toc-text">
          解析 environments 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-databaseIdProvider-%E6%A0%87%E7%AD%BE"><span class="toc-number">2.8.</span> <span class="toc-text">
          解析 databaseIdProvider 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-mappers-%E6%A0%87%E7%AD%BE"><span class="toc-number">2.9.</span> <span class="toc-text">
          解析 mappers 标签</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">
          总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">96</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">14</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">29</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2025</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>