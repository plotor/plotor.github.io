<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="通过前面两篇文章，我们完成了对 MyBatis 所有配置文件（包括配置文件和映射文件）解析过程的分析。回忆一下我们最开始给出的小示例（如下），经过前面的跋山涉水，我们终于完成了第一行代码的 99% （手动滑稽），这最后的 1% 就是创建 SqlSessionFactory 对象。所有的配置解析最后都会封装到 Configuration 对象中，接下去就是调用 SqlSessionFactoryBu">
<meta property="og:type" content="article">
<meta property="og:title" content="MyBatis 源码解析：SQL 语句的执行机制">
<meta property="og:url" content="https://plotor.github.io/2017/10/15/mybatis/mybatis-execute-sql/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="通过前面两篇文章，我们完成了对 MyBatis 所有配置文件（包括配置文件和映射文件）解析过程的分析。回忆一下我们最开始给出的小示例（如下），经过前面的跋山涉水，我们终于完成了第一行代码的 99% （手动滑稽），这最后的 1% 就是创建 SqlSessionFactory 对象。所有的配置解析最后都会封装到 Configuration 对象中，接下去就是调用 SqlSessionFactoryBu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://plotor.github.io/images/2017/mybatis-execute-sql.png">
<meta property="og:image" content="https://plotor.github.io/images/2017/mybatis-sqlsession.png">
<meta property="og:image" content="https://plotor.github.io/images/2017/mybatis-executor.png">
<meta property="og:image" content="https://plotor.github.io/images/2017/mybatis-cache.png">
<meta property="og:image" content="https://plotor.github.io/images/2017/mybatis-statementhandler.png">
<meta property="article:published_time" content="2017-10-15T07:01:01.000Z">
<meta property="article:modified_time" content="2024-06-15T06:56:17.949Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="MyBatis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://plotor.github.io/images/2017/mybatis-execute-sql.png"><title>MyBatis 源码解析：SQL 语句的执行机制 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2017/10/15/mybatis/mybatis-execute-sql/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">MyBatis 源码解析：SQL 语句的执行机制</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2017-10-15</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">15.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">70分</span></span></div></header><div class="post-body"><p>通过前面两篇文章，我们完成了对 MyBatis 所有配置文件（包括配置文件和映射文件）解析过程的分析。回忆一下我们最开始给出的小示例（如下），经过前面的跋山涉水，我们终于完成了第一行代码的 99% （手动滑稽），这最后的 1% 就是创建 SqlSessionFactory 对象。所有的配置解析最后都会封装到 Configuration 对象中，接下去就是调用 <code>SqlSessionFactoryBuilder#build</code> 方法创建 SqlSessionFactory 对象，实际使用的是 DefaultSqlSessionFactory 实现类进行实例化。<a id="more"></a></p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">        .build(Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>));</span><br><span class="line"><span class="keyword">try</span> (SqlSession sqlSession = sessionFactory.openSession()) {</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    User user = mapper.selectByName(<span class="string">"zhenchao"</span>);</span><br><span class="line">    <span class="comment">// ... use user object</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>SqlSessionFactory 是一个工厂类，用于创建 SqlSession 对象。按照官方文档的说明，SqlSessionFactory 对象一旦被创建就应该在应用的运行期间一直存在，不应该在运行期间对其进行清除或重建。调用该工厂的 <code>SqlSessionFactory#openSession</code> 方法可以开启一次会话，即创建一个 SqlSession 对象。SqlSession 封装了面向数据库执行 SQL 的所有 API，它不是线程安全的，因此不能被共享，所以该对象的最佳作用域是请求或方法作用域。在上面的示例中，我们用 SqlSession 拿到相应的 Mapper 接口对象（更准确的说是一个动态代理对象），然后执行指定的数据库操作，最后关闭此次会话。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2017/mybatis-execute-sql.png" alt="image">
      </p>
<p>上面这张时序图我们在本系列开篇的文章中已经引用过，描绘了 MyBatis 在一次会话生命周期内执行数据库操作的交互时序。下面对这幅图中所描绘的执行过程中类之间的交互时序关系作进一步说明，稍后我们会对图中涉及到的类和接口从源码层面进行分析，执行时序如下：</p>
<ol>
<li>调用 <code>SqlSessionFactory#openSession</code> 方法创建 SqlSession 对象，开启一次会话；</li>
<li>调用 <code>SqlSession#getMapper</code> 方法获取指定的 Mapper 接口对象，这里实际上将请求委托给 <code>Configuration#getMapper</code> 方法执行，由前面分析映射文件解析过程时我们知道所有的 Mapper 接口都会注册到全局唯一的配置对象 Configuration 的 MapperRegistry 类型属性中；</li>
<li>MapperRegistry 在执行 <code>MapperRegistry#getMapper</code> 操作时会反射创建 Mapper 接口的动态代理对象并返回；</li>
<li>执行对应的数据库操作方法（例如 <code>UserMapper#selectByName</code>），即调用 Mapper 接口动态代理对象的 <code>MapperProxy#invoke</code> 方法，在该方法中会获取封装执行方法的 MapperMethod 对象；</li>
<li>执行 <code>MapperMethod#execute</code> 方法，该方法会判定当前数据库操作类型（例如 SELECT），依据类型选择执行 SqlSession 对应的数据库操作方法；</li>
<li>SqlSession 会将数据库操作委托给具体的 Executor 执行。对于动态 SQL 语句而言，在这里会依据参数执行解析；对于查询语句而言，Executor 在条件允许的情况下会尝试先从缓存中进行查询，缓存不命中才会操作具体的数据库并更新缓存。MyBatis 强大的结果集映射操作也在这里完成；</li>
<li>返回查询结果；</li>
<li>调用当前会话的 <code>SqlSession#close</code> 方法关闭本次会话。</li>
</ol>
<p>整个过程围绕一次查询操作展开，虽然不能覆盖 MyBatis 执行 SQL 语句的各个方面，但主线上还是能够说明白 MyBatis 针对一次 SQL 执行的大概过程。在下面的篇幅中，我们将一起分析这一整套时序背后的实现机制。</p>

        <h3 id="SQL-会话管理">
          <a href="#SQL-会话管理" class="heading-link"><i class="fas fa-link"></i></a>SQL 会话管理</h3>
      <p>SqlSession 接口是 MyBatis 对外提供的数据库操作 API，是 MyBatis 的核心接口之一，用于管理一次数据库会话。围绕 SqlSession 接口的类继承关系如下图所示，其中 DefaultSqlSession 是默认的 SqlSession 实现。SqlSessionFactory 是一个工厂接口，其功能是用来创建 SqlSession 对象，该接口中声明了多个重载版本的 <code>SqlSessionFactory#openSession</code> 方法，DefaultSqlSessionFactory 是该接口的默认实现。上述示例程序中 <code>SqlSessionFactoryBuilder#build</code> 方法就是基于该实现类创建的 SqlSessionFactory 对象。SqlSessionManager 类实现了这两个接口，所以具备创建、使用，以及管理 SqlSession 对象的能力，后面会详细说明。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2017/mybatis-sqlsession.png" alt="image">
      </p>
<p>SqlSession 接口中声明的方法都比较直观，感兴趣的读者可以自行阅读源码。我们来看一下针对该接口的默认实现类 DefaultSqlSession，该类的属性定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 全局唯一的配置对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="comment">/** SQL 语句执行器 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="comment">/** 是否自动提交事务 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit;</span><br><span class="line"><span class="comment">/** 标记当前缓存中是否存在脏数据 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> dirty;</span><br><span class="line"><span class="comment">/** 记录已经打开的游标 */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;</span><br></pre></td></tr></tbody></table></div></figure>
<p>DefaultSqlSession 中的方法实现基本上都是对 Executor 接口方法的封装，实现上都比较简单。这里解释一下 <code>DefaultSqlSession#cursorList</code> 这个属性，在 <code>DefaultSqlSession#selectCursor</code> 方法中会记录查询返回的游标（Cursor）对象，并在关闭 SqlSession 会话时遍历集合逐一关闭，从而防止打开的游标没有被关闭的现象。</p>
<p>DefaultSqlSessionFactory 是 SqlSessionFactory 接口的默认实现，用于创建 SqlSession 对象。该实现类提供了两种创建 SqlSession 对象的方式，分别是基于当前数据源创建会话和基于当前数据库连接创建会话，对应的实现如下。</p>
<ul>
<li><strong>基于数据源创建会话</strong></li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>{</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获取当前激活的数据库环境配置</span></span><br><span class="line">        <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">        <span class="comment">// 获取当前数据库环境对应的 TransactionFactory 对象，不存在的话就创建一个</span></span><br><span class="line">        <span class="keyword">final</span> TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        <span class="comment">// 依据指定的 Executor 类型创建对应的 Executor 对象</span></span><br><span class="line">        <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        <span class="comment">// 创建 SqlSession 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">this</span>.closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<ul>
<li><strong>基于数据库连接创建会话</strong></li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromConnection</span><span class="params">(ExecutorType execType, Connection connection)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">boolean</span> autoCommit;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            autoCommit = connection.getAutoCommit();</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            <span class="comment">// 考虑到很多驱动或者数据库不支持事务，设置自动提交事务</span></span><br><span class="line">            autoCommit = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获取当前激活的数据库环境配置</span></span><br><span class="line">        <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">        <span class="comment">// 获取当前数据库环境对应的 TransactionFactory 对象，不存在的话就创建一个</span></span><br><span class="line">        <span class="keyword">final</span> TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        <span class="keyword">final</span> Transaction tx = transactionFactory.newTransaction(connection);</span><br><span class="line">        <span class="comment">// 依据指定的 Executor 类型创建对应的 Executor 对象</span></span><br><span class="line">        <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        <span class="comment">// 创建 SqlSession 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>两种创建会话的方式在执行流程上基本一致，具体细节如上述代码注释。</p>
<p>SqlSessionManager 同时实现了 SqlSessionFactory 和 SqlSession 两个接口，所以具备这两个接口全部的功能。该实现类的属性定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 封装的 {<span class="doctag">@link</span> SqlSessionFactory} 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"><span class="comment">/** 线程私有的 SqlSession 对象的动态代理对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line"><span class="comment">/** 线程私有的 SqlSession 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;SqlSession&gt; localSqlSession = <span class="keyword">new</span> ThreadLocal&lt;SqlSession&gt;();</span><br></pre></td></tr></tbody></table></div></figure>
<p>针对 SqlSessionFactory 接口中声明的方法，SqlSessionManager 均委托给持有的 SqlSessionFactory 对象完成。对于 SqlSession 接口中声明的方法，SqlSessionManager 提供了两种实现方式：如果当前线程已经绑定了一个 SqlSession 对象，那么只要未主动调用 <code>SqlSessionManager#close</code> 方法，就会一直复用该线程私有的 SqlSession 对象；否则会在每次执行数据库操作时创建一个新的 SqlSession 对象，并在使用完毕之后关闭会话。相关逻辑位于 SqlSessionInterceptor 类中，这是一个定义在 SqlSessionManager 中的内部类，属性 <code>SqlSessionManager#sqlSessionProxy</code> 是基于该类实现的动态代理对象：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sqlSessionProxy = (SqlSession) Proxy.newProxyInstance(</span><br><span class="line">            SqlSessionFactory.class.getClassLoader(), <span class="keyword">new</span> Class[]{SqlSession.class}, <span class="keyword">new</span> SqlSessionInterceptor());</span><br></pre></td></tr></tbody></table></div></figure>
<p>SqlSessionInterceptor 类实现自 InvocationHandler 接口，对应的 <code>SqlSessionInterceptor#invoke</code> 方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    <span class="comment">// 获取当前线程私有的 SqlSession 对象</span></span><br><span class="line">    <span class="keyword">final</span> SqlSession sqlSession = localSqlSession.get();</span><br><span class="line">    <span class="comment">// 会话未被关闭</span></span><br><span class="line">    <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 直接反射调用相应的方法</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(sqlSession, args);</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 没有 SqlSession，或已关闭，创建一个，使用完毕之后即关闭会话</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">try</span> (SqlSession autoSqlSession = SqlSessionManager.<span class="keyword">this</span>.openSession()) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 反射调用相应的方法</span></span><br><span class="line">                <span class="keyword">final</span> Object result = method.invoke(autoSqlSession, args);</span><br><span class="line">                <span class="comment">// 提交事务</span></span><br><span class="line">                autoSqlSession.commit();</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">                <span class="comment">// 回滚事务</span></span><br><span class="line">                autoSqlSession.rollback();</span><br><span class="line">                <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>SqlSessionInterceptor 首先会尝试获取线程私有的 SqlSession 对象，对于未绑定的线程来说会创建一个新的 SqlSession 对象，并在使用完毕之后立刻关闭。</p>

        <h3 id="动态代理-Mapper-接口">
          <a href="#动态代理-Mapper-接口" class="heading-link"><i class="fas fa-link"></i></a>动态代理 Mapper 接口</h3>
      <p>MyBatis 要求所有的 Mapper 都定义成接口的形式，这主要是为了配合 JDK 内置的动态代理机制，JDK 内置的动态代理要求被代理的类必须抽象出一个接口。常用的动态代理除了 JDK 内置的方式，还有基于 CGlib 等第三方组件的方式，MyBatis 采用了 JDK 内置的方式创建 Mapper 接口的动态代理对象。</p>
<p>我们先来复习一下 JDK 内置的动态代理机制，假设现在有一个接口 Mapper 及其实现类如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperImpl</span> <span class="keyword">implements</span> <span class="title">Mapper</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"do select."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>现在我们希望在方法执行之前打印一行调用日志，基于动态代理的实现方式如下。我们需要定义一个实现了 InvocationHandler 接口的代理类，然后在其 <code>InvocationHandler#invoke</code> 方法中实现增强逻辑：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(Mapper mapper)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        System.out.println(<span class="string">"before invoke."</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.mapper, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>客户端调用代码：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mapper mapper = <span class="keyword">new</span> MapperImpl();</span><br><span class="line">Mapper mapperProxy = (Mapper) Proxy.newProxyInstance(</span><br><span class="line">        mapper.getClass().getClassLoader(), mapper.getClass().getInterfaces(), <span class="keyword">new</span> MapperProxy(mapper));</span><br><span class="line">mapperProxy.select();</span><br></pre></td></tr></tbody></table></div></figure>
<p>回到 MyBatis 框架本身，我们在执行目标数据库操作时，一般会直接调用目标 Mapper 接口的相应方法，这里框架返回给我们的实际上是 Mapper 接口的动态代理类对象。MyBatis 基于 JDK 的动态代理机制实现了 Mapper 接口中声明的方法，这其中包含了 <strong>获取 SQL 语句、参数绑定、缓存操作、数据库操作，以及结果集映射处理</strong> 等步骤，下面就 Mapper 接口动态代理机制涉及到的相关类和方法进行分析。</p>
<p>上一篇在分析映射文件时我们介绍了在 <code>MapperRegistry#knownMappers</code> 属性中记录了 Mapper 接口与 MapperProxyFactory 的映射关系，MapperProxyFactory 顾名思义是 MapperProxy 的工厂类，其中定义了创建 Mapper 接口代理对象的方法，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 Mapper 接口对应的动态代理对象（基于 JDK 内置的动态代理机制）</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">        mapperInterface.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[] {mapperInterface},</span><br><span class="line">        mapperProxy);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>来看一下 MapperProxy 实现，该类实现了 InvocationHandler 接口，对应的 <code>InvocationHandler#invoke</code> 实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 对于 Object 类中声明的方法，直接调用</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) {</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 对于非 Object 类中声明的方法</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 获取方法关联的 MapperMethodInvoker 对象，并执行数据库操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的核心逻辑在于获取当前执行方法 Method 对象对应的 MapperMethodInvoker 方法调用器，并执行 <code>MapperMethodInvoker#invoke</code> 方法触发对应的数据库操作。</p>
<p>围绕 MapperMethodInvoker 接口，MyBatis 提供了两种实现，即 DefaultMethodInvoker 和 PlainMethodInvoker，其中前者用于支持 JDK 7 引入的动态类型语言特性，后者则是对 MapperMethod 的封装。MapperMethod 中主要定义两个内部类：</p>
<ul>
<li><strong>SqlCommand</strong> ：用于封装方法关联的 SQL 语句名称和类型。</li>
<li><strong>MethodSignature</strong> ：用来封装方法相关的签名信息。</li>
</ul>
<p>先来看一下 SqlCommand 的具体实现，该类定义了 <code>SqlCommand#name</code> 和 <code>SqlCommand#type</code> 两个属性，分别用于记录对应 SQL 语句的名称和类型，并在构造方法中实现了相应的解析逻辑和初始化操作，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取方法名称</span></span><br><span class="line">    <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">    <span class="comment">// 获取方法隶属的类或接口的 Class 对象</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">    <span class="comment">// 解析方法关联的 SQL 语句对应的 MappedStatement 对象（用于封装 SQL 语句）</span></span><br><span class="line">    MappedStatement ms = <span class="keyword">this</span>.resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration);</span><br><span class="line">    <span class="comment">// 未找当前方法对应的 MappedStatement 对象</span></span><br><span class="line">    <span class="keyword">if</span> (ms == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果对应方法注解了 @Flush，表示执行缓存的批量更新语句，则进行标记</span></span><br><span class="line">        <span class="keyword">if</span> (method.getAnnotation(Flush.class) != <span class="keyword">null</span>) {</span><br><span class="line">            name = <span class="keyword">null</span>;</span><br><span class="line">            type = SqlCommandType.FLUSH;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(</span><br><span class="line">                <span class="string">"Invalid bound statement (not found): "</span> + mapperInterface.getName() + <span class="string">"."</span> + methodName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 找当前方法对应的 MappedStatement 对象，初始化 SQL 语句名称和类型</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        name = ms.getId();</span><br><span class="line">        type = ms.getSqlCommandType();</span><br><span class="line">        <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> MappedStatement <span class="title">resolveMappedStatement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; mapperInterface, String methodName, Class&lt;?&gt; declaringClass, Configuration configuration)</span> </span>{</span><br><span class="line">    <span class="comment">// 接口名称.方法名</span></span><br><span class="line">    String statementId = mapperInterface.getName() + <span class="string">"."</span> + methodName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法存在关联的 SQL 语句，则获取封装该 SQL 语句的 MappedStatement 对象</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasStatement(statementId)) {</span><br><span class="line">        <span class="keyword">return</span> configuration.getMappedStatement(statementId);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 已经递归到该方法隶属的最上层类，但是仍然没有找到关联的 MappedStatement 对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mapperInterface.equals(declaringClass)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 沿着继承关系向上递归检索</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) {</span><br><span class="line">        <span class="keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) {</span><br><span class="line">            <span class="comment">// 递归检索</span></span><br><span class="line">            MappedStatement ms = <span class="keyword">this</span>.resolveMappedStatement(</span><br><span class="line">                superInterface, methodName, declaringClass, configuration);</span><br><span class="line">            <span class="keyword">if</span> (ms != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> ms;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>SqlCommand 在实例化时所做的主要工作就是解析当前 Mapper 方法关联的 SQL 对应的 MappedStatement 对象，并初始化记录的 SQL 语句名称和类型，整个解析过程如上述代码注释。</p>
<p>再来看一下 MethodSignature 类，该类用于封装一个具体 Mapper 方法的相关签名信息，其中定义的方法实现都比较简单，这里列举一下其属性定义：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 标记返回值是否是 {<span class="doctag">@link</span> java.util.Collection} 或数组类型 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMany;</span><br><span class="line"><span class="comment">/** 标记返回值是否是 {<span class="doctag">@link</span> Map} 类型 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMap;</span><br><span class="line"><span class="comment">/** 标记返回值是否是 {<span class="doctag">@link</span> Void} 类型 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsVoid;</span><br><span class="line"><span class="comment">/** 标记返回值是否是 {<span class="doctag">@link</span> Cursor} 类型 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsCursor;</span><br><span class="line"><span class="comment">/** 标记返回值是否是 {<span class="doctag">@link</span> Optional} 类型 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsOptional;</span><br><span class="line"><span class="comment">/** 返回值类型 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; returnType;</span><br><span class="line"><span class="comment">/** 对于 Map 类型的返回值，用于记录 key 的别名 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mapKey;</span><br><span class="line"><span class="comment">/** 标记参数列表中 {<span class="doctag">@link</span> ResultHandler} 的下标 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer resultHandlerIndex;</span><br><span class="line"><span class="comment">/** 标记参数列表中 {<span class="doctag">@link</span> RowBounds} 的下标 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer rowBoundsIndex;</span><br><span class="line"><span class="comment">/** 参数名称解析器 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ParamNameResolver paramNameResolver;</span><br></pre></td></tr></tbody></table></div></figure>
<p>上面属性中重点介绍一下 ParamNameResolver 这个类，它的作用在于解析 Mapper 方法的参数列表，以便于在方法实参和方法关联的 SQL 语句的参数之间建立映射关系。其中一个比较重要的属性是 <code>ParamNameResolver#names</code>，定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录参数在参数列表中的下标和参数名称之间的对应关系。</span></span><br><span class="line"><span class="comment"> * 参数名称通过 {<span class="doctag">@link</span> Param} 注解指定，如果没有指定则使用参数下标作为参数名称，</span></span><br><span class="line"><span class="comment"> * 需要注意的是，如果参数列表中包含 {<span class="doctag">@link</span> RowBounds} 或 {<span class="doctag">@link</span> ResultHandler} 类型的参数，</span></span><br><span class="line"><span class="comment"> * 这两种功能型参数不会记录到集合中，此时如果用下标表示参数名称，索引值 key 与对应的参数名称（实际索引）可能会不一致。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The key is the index and the value is the name of the parameter.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * The name is obtained from {<span class="doctag">@link</span> Param} if specified. When {<span class="doctag">@link</span> Param} is not specified,</span></span><br><span class="line"><span class="comment"> * the parameter index is used. Note that this index could be different from the actual index</span></span><br><span class="line"><span class="comment"> * when the method has special parameters (i.e. {<span class="doctag">@link</span> RowBounds} or {<span class="doctag">@link</span> ResultHandler}).</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;aMethod(<span class="doctag">@Param</span>("M") int a, <span class="doctag">@Param</span>("N") int b) -&amp;gt; {{0, "M"}, {1, "N"}}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;aMethod(int a, int b) -&amp;gt; {{0, "0"}, {1, "1"}}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;aMethod(int a, RowBounds rb, int b) -&amp;gt; {{0, "0"}, {2, "1"}}&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; names;</span><br></pre></td></tr></tbody></table></div></figure>
<p>我把它的英文注释和我的理解都写在代码注释中，应该可以清楚理解该属性的作用。至于为什么需要跳过 RowBounds 和 ResultHandler 这两个类型的参数，是因为前者用于设置 LIMIT 参数，后者用于设置结果集处理器，所以都不是真正意义上的参数，按照我的话说这两种类型的参数都是功能型的参数。</p>
<p>ParamNameResolver 在构造方法中实现了对参数列表的解析，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取参数类型列表</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">    <span class="comment">// 获取参数列表上的注解列表</span></span><br><span class="line">    <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">    <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历处理方法所有的参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) {</span><br><span class="line">        <span class="comment">// 跳过 RowBounds 和 ResultHandler 类型参数</span></span><br><span class="line">        <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找当前参数是否有 @Param 注解</span></span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) {</span><br><span class="line">            <span class="comment">// 获取注解指定的参数名称</span></span><br><span class="line">            <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) {</span><br><span class="line">                hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">                name = ((Param) annotation).value();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有 @Param 注解</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 基于配置开关决定是否获取参数的真实名称</span></span><br><span class="line">            <span class="keyword">if</span> (config.isUseActualParamName()) {</span><br><span class="line">                name = <span class="keyword">this</span>.getActualParamName(method, paramIndex);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 使用下标作为参数名称</span></span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// use the parameter index as the name ("0", "1", ...)</span></span><br><span class="line">                <span class="comment">// gcode issue #71</span></span><br><span class="line">                name = String.valueOf(map.size());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        map.put(paramIndex, name);</span><br><span class="line">    }</span><br><span class="line">    names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>整个过程概括来说就是遍历处理指定方法的参数列表，忽略 RowBounds 和 ResultHandler 类型的参数，并判断参数前面是否有 <code>@Param</code> 注解，如果有则尝试以注解指定的字符串作为参数名称，否则基于配置决定是否采用参数的真实名称作为这里的参数名，再不济就采用下标值作为参数名称。</p>
<p>考虑到会忽略 RowBounds 和 ResultHandler 两种类型的参数，但是属性 <code>ParamNameResolver#names</code> 对应的 key 又是递增的，所以就可能出现在以下标值作为参数名称时，参数名称与对应下标值不一致的情况。例如，假设有一个方法的参数列表为 <code>(int a, RowBounds rb, int b)</code>，因为有 RowBounds 类型夹在中间，如果以下标值作为参数名称的最终解析结果就是 <code>{0, "0"}, {2, "1"}</code>，下标与具体的参数名称不一致。</p>
<p>ParamNameResolver 中还有一个比较重要的方法 <code>ParamNameResolver#getNamedParams</code>，用于关联实参和形参列表，其中 args 参数是用户传递的实参数组，方法基于前面的参数列表解析结果将传递的实现与对应的方法参数进行关联，最终记录到 Object 对象中进行返回，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>{</span><br><span class="line">    <span class="comment">// names 属性记录参数在参数列表中的下标和参数名称之间的对应关系</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">    <span class="comment">// 无参方法，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 没有 @Param 注解，且只有一个参数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 有 @Param 注解，或存在多个参数</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历处理参数列表中的非功能性参数</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) {</span><br><span class="line">            <span class="comment">// 记录参数名称与参数值之间的映射关系</span></span><br><span class="line">            param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">            <span class="comment">// 构造一般参数名称，即 (param1, param2, ...) 形式参数</span></span><br><span class="line">            <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + (i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 以“param + 索引”的形式再记录一次，如果 @Param 指定的参数名称已经是这种形式则不覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (!names.containsValue(genericParamName)) {</span><br><span class="line">                param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>做了这么多的铺垫，是时候回来继续分析 MapperMethod 的核心方法 <code>MapperMethod#execute</code> 了。该方法的作用在于委托 SqlSession 对象执行方法对应的 SQL 语句，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>{</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) {</span><br><span class="line">        <span class="keyword">case</span> INSERT: {</span><br><span class="line">            <span class="comment">// 关联实参与方法参数列表</span></span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            <span class="comment">// 调用 SqlSession#insert 方法执行插入操作，并对执行结果进行转换</span></span><br><span class="line">            result = <span class="keyword">this</span>.rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> UPDATE: {</span><br><span class="line">            <span class="comment">// 关联实参与方法参数列表</span></span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            <span class="comment">// 调用 SqlSession#update 方法执行更新操作，并对执行结果进行转换</span></span><br><span class="line">            result = <span class="keyword">this</span>.rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> DELETE: {</span><br><span class="line">            <span class="comment">// 关联实参与方法参数列表</span></span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            <span class="comment">// 调用 SqlSession#delete 方法执行删除操作，并对执行结果进行转换</span></span><br><span class="line">            result = <span class="keyword">this</span>.rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> SELECT:</span><br><span class="line">            <span class="comment">// 返回值是 void 类型，且指定了 ResultHandler 处理结果集</span></span><br><span class="line">            <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {</span><br><span class="line">                <span class="keyword">this</span>.executeWithResultHandler(sqlSession, args);</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 返回值为 Collection 或数组</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) {</span><br><span class="line">                result = <span class="keyword">this</span>.executeForMany(sqlSession, args);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 返回值为 Map 类型</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) {</span><br><span class="line">                result = <span class="keyword">this</span>.executeForMap(sqlSession, args);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 返回值为 Cursor 类型</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) {</span><br><span class="line">                result = <span class="keyword">this</span>.executeForCursor(sqlSession, args);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 处理其它返回类型</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">                result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">                <span class="keyword">if</span> (method.returnsOptional() <span class="comment">// Optional 类型</span></span><br><span class="line">                    &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) {</span><br><span class="line">                    result = Optional.ofNullable(result);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FLUSH:</span><br><span class="line">            <span class="comment">// 如果方法注解了 @Flush，则执行 SqlSession#flushStatements 方法提交缓存的批量更新操作</span></span><br><span class="line">            result = sqlSession.flushStatements();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</span><br><span class="line">            + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法会依据具体的 SQL 语句类型分而治之。对于 INSERT、UPDATE，以及 DELETE 类型而言，会先调用 <code>MethodSignature#convertArgsToSqlCommandParam</code> 方法关联实参与方法形参，本质上是调用前面介绍的 <code>ParamNameResolver#getNamedParams</code> 方法。然后就是调用 SqlSession 对应的方法执行数据库操作，并通过方法 <code>MapperMethod#rowCountResult</code> 对结果进行类型转换。关于 SqlSession 相关方法的具体实现留到下一节针对性介绍。对于 SELECT 类型而言，则需要考虑不同的返回类型，分为 void、Collection、数组、Map、Cursor，以及对象几类情况，这里所做的都是对于参数或返回结果的处理，核心逻辑也都位于 SqlSession 中，在这一层面的实现都比较简单，就不再一一展开。对于 FLUSH 类型来说，官方文档的说明如下：</p>
<blockquote>
<p>如果使用了这个注解，它将调用定义在 Mapper 接口中的 <code>SqlSession#flushStatements</code> 方法。</p>
</blockquote>
<p>具体的实现也就位于这里。</p>

        <h3 id="SQL-语句执行器">
          <a href="#SQL-语句执行器" class="heading-link"><i class="fas fa-link"></i></a>SQL 语句执行器</h3>
      <p>Executor 接口声明了基本的数据库操作，前面在介绍 SqlSession 时曾描述 SqlSession 是 MyBatis 框架对外提供的 API 接口，其中声明了对数据库的基本操作方法，而这些操作方法基本上都是对 Executor 方法的封装。Executor 接口定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>{</span><br><span class="line"></span><br><span class="line">    ResultHandler NO_RESULT_HANDLER = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 执行数据库更新操作：update、insert、delete */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 执行数据库查询操作 */</span></span><br><span class="line">    &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 执行数据库查询操作，返回游标对象 */</span></span><br><span class="line">    &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 批量提交 SQL 语句 */</span></span><br><span class="line">    <span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 提交事务 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 回滚事务 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 创建缓存 key 对象 */</span></span><br><span class="line">    <span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line">    <span class="comment">/** 判断是否缓存 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCached</span><span class="params">(MappedStatement ms, CacheKey key)</span></span>;</span><br><span class="line">    <span class="comment">/** 清空一级缓存 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/** 延迟加载一级缓存中的数据 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deferLoad</span><span class="params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line">    <span class="comment">/** 获取事务对象 */</span></span><br><span class="line">    <span class="function">Transaction <span class="title">getTransaction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/** 关闭当前 Executor */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">boolean</span> forceRollback)</span></span>;</span><br><span class="line">    <span class="comment">/** 是否已经关闭 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/** 设置装饰的 Executor 对象 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setExecutorWrapper</span><span class="params">(Executor executor)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>围绕 Executor 接口的类继承关系如下图，其中 CachingExecutor 实现类用于为 Executor 提供二级缓存支持。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2017/mybatis-executor.png" alt="image">
      </p>
<p>BaseExecutor 抽象类实现了 Executor 接口中声明的所有方法，并抽象了 4 个模板方法交由子类实现，这 4 个方法分别是：doUpdate、doFlushStatements、doQuery，以及 doQueryCursor。SimpleExecutor 派生自 BaseExecutor 抽象类，并为这 4 个模板方法提供了最简单的实现。ReuseExecutor 如其名，提供了重用的特性，提供对 Statement 对象的重用，以减少 SQL 预编译，以及创建和销毁 Statement 对象的开销。BatchExecutor 实现类则提供了对 SQL 语句批量执行的特性，也是针对提升性能的一种优化实现。</p>

        <h4 id="缓存结构设计">
          <a href="#缓存结构设计" class="heading-link"><i class="fas fa-link"></i></a>缓存结构设计</h4>
      <p>考虑到 Executor 在执行数据库操作时与缓存操作存在密切联系，所以在具体介绍 Executor 的实现之前我们先来了解一下 MyBatis 的缓存机制。</p>
<p>在谈论数据库架构设计时往往需要引入缓存的概念，数据库是相对脆弱且耗时的，所以需要尽量避免请求落库。在实际项目架构设计中，我们一般会引入 Redis、Memcached 这一类的组件对数据进行缓存，MyBatis 作为一个强大的 ORM 框架，也为缓存提供了内建的实现。前面我们在分析配置文件加载与解析时曾介绍过 MyBatis 缓存组件的具体实现，MyBatis 在数据存储上采用 HashMap 作为基本存储结构，并提供了多种装饰器从多个方面为缓存增加相应的特性。</p>
<p>本小节我们关注的是 MyBatis 在缓存结构方面的设计，MyBatis 缓存从结构上可以分为 <strong>一级缓存</strong> 和 <strong>二级缓存</strong> ，一级缓存相对于二级缓存在粒度上更细，生命周期也更短。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2017/mybatis-cache.png" alt="image">
      </p>
<p>上图描绘了 MyBatis 缓存的结构设计，当我们发起一次数据库查询时，如果启用了二级缓存的话，MyBatis 首先会从二级缓存中检索查询结果，如果缓存不命中则会继续检索一级缓存，只有在这两层缓存都不命中的情况下才会查询数据库，最后会以数据库返回的结果更新一级缓存和二级缓存。</p>
<p>MyBatis 的 <strong>一级缓存是会话级别的缓存（生命周期与本次会话相同）</strong> ，当我们开启一次数据库会话时，框架默认会为本次会话绑定一个一级缓存对象。此类缓存主要应对在一个会话范围内的冗余查询操作，比如使用同一个 SqlSession 对象同时连续执行多次相同的查询语句。这种情况下每次查询都落库是没有必要的，因为短时间内数据库变化的可能性会很小，但是每次都落库却是一笔不必要的开销。一级缓存默认是开启的，且无需进行配置，即一级缓存对开发者是透明的，如果确实希望干预一级缓存的内在运行，可以借助于插件来实现。</p>
<p>对于二级缓存而言，默认也是开启的，MyBatis 提供了相应的治理选项，具体可以参考官方文档。 <strong>二级缓存是应用级别的缓存</strong> ，随着服务的启动而存在，并随着服务的关闭消亡。前面我们在分析 <code>&lt;cache/&gt;</code> 和 <code>&lt;cache-ref/&gt;</code> 标签时介绍了一个二级缓存会与一个具体的 namespace 绑定，并且支持引用一个已定义 namespace 缓存，即多个 namespace 可以共享同一个缓存。</p>
<p>本小节从整体结构上对 MyBatis 的缓存实现机制进行说明，目的在于对 MyBatis 的缓存有一个整体感知，关于一级缓存和二级缓存的具体实现，留到下面介绍分析 Executor 接口具体实现时穿插说明。</p>

        <h4 id="Statement-处理器">
          <a href="#Statement-处理器" class="heading-link"><i class="fas fa-link"></i></a>Statement 处理器</h4>
      <p>StatementHandler 接口及其实现类是 Executor 实现的基础，可以将其看作是 MyBatis 与数据库操作之间的纽带，实现了对 <code>java.sql.Statement</code> 对象的获取，以及 SQL 语句参数绑定与执行的逻辑。StatementHandler 接口及其实现类的类继承关系如下图所示：</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2017/mybatis-statementhandler.png" alt="image">
      </p>
<p>其中 BaseStatementHandler 中实现了一些公共的逻辑；SimpleStatementHandler、PreparedStatementHandler，以及 CallableStatementHandler 实现类分别对应 Statement、PreparedStatement 和 CallableStatement 的相关实现；RoutingStatementHandler 并没有添加新的实现，而是对前面三种 StatementHandler 实现类的封装，它会在构造方法中依据当前传递的 Statement 类型创建对应的 StatementHandler 实现类对象。</p>
<p>StatementHandler 接口定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取对应的 {<span class="doctag">@link</span> Statement } 对象 */</span></span><br><span class="line">    <span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 绑定 Statement 执行 SQL 时需要的实参 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 批量执行 SQL 语句 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 执行数据库更新操作：insert、update、delete */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 执行 select 操作 */</span></span><br><span class="line">    &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 执行 select 操作，返回游标对象 */</span></span><br><span class="line">    &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">/** 获取对应的 SQL 对象 */</span></span><br><span class="line">    <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/** 获取对应的 {<span class="doctag">@link</span> ParameterHandler} 对象，用于参数绑定 */</span></span><br><span class="line">    <span class="function">ParameterHandler <span class="title">getParameterHandler</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>首先来看一下 BaseStatementHandler 实现，该类中主要实现了获取 Statement 对象的逻辑，该类的属性定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line"><span class="comment">/** 处理结果集映射 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ResultSetHandler resultSetHandler;</span><br><span class="line"><span class="comment">/** 用于为 SQL 语句绑定实参 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ParameterHandler parameterHandler;</span><br><span class="line"><span class="comment">/** SQL 语句执行器 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="comment">/** 对应 SQL 语句标签对象 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line"><span class="comment">/** 封装 LIMIT 参数 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> RowBounds rowBounds;</span><br><span class="line"><span class="comment">/** 可执行的 SQL 语句 */</span></span><br><span class="line"><span class="keyword">protected</span> BoundSql boundSql;</span><br></pre></td></tr></tbody></table></div></figure>
<p>BaseStatementHandler 之于 <code>StatementHandler#prepare</code> 方法的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 从数据库连接中获取 Statement 对象，由子类实现</span></span><br><span class="line">        statement = <span class="keyword">this</span>.instantiateStatement(connection);</span><br><span class="line">        <span class="comment">// 设置超时时间</span></span><br><span class="line">        <span class="keyword">this</span>.setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">        <span class="comment">// 设置返回的行数</span></span><br><span class="line">        <span class="keyword">this</span>.setFetchSize(statement);</span><br><span class="line">        <span class="keyword">return</span> statement;</span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        <span class="keyword">this</span>.closeStatement(statement);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">this</span>.closeStatement(statement);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Error preparing statement.  Cause: "</span> + e, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先会调用 <code>BaseStatementHandler#instantiateStatement</code> 方法获取一个 Statement 对象，这是一个模板方法交由子类实现；然后对拿到的 Statement 对象设置超时时间和返回的行数属性。</p>
<p>BaseStatementHandler 中定义了 ParameterHandler 类型的属性，主要用于为包含 <code>?</code> 占位符的 SQL 语句绑定实参。ParameterHandler 接口定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取输出类型参数 */</span></span><br><span class="line">    <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 为 SQL 语句绑定实参 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>其中，方法 <code>ParameterHandler#getParameterObject</code> 与存储过程相关，下面主要分析一下 <code>ParameterHandler#setParameters</code> 方法的实现。该方法用来为 SQL 语句绑定实参，具体操作等同于我们在直接使用 PreparedStatement 对象时注入相应类型的参数填充 SQL 语句。DefaultParameterHandler 是目前该接口的唯一实现，其 <code>DefaultParameterHandler#setParameters</code> 方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>{</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"setting parameters"</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">    <span class="comment">// 获取 BoundSql 中记录的参数映射关系列表</span></span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历为 SQL 语句绑定对应的参数值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) {</span><br><span class="line">            ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">            <span class="comment">// 忽略存储过程中的输出参数</span></span><br><span class="line">            <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) {</span><br><span class="line">                Object value; <span class="comment">// 用于记录对应的参数值</span></span><br><span class="line">                <span class="comment">// 获取参数名称</span></span><br><span class="line">                String propertyName = parameterMapping.getProperty();</span><br><span class="line">                <span class="comment">// 获取对应的参数值</span></span><br><span class="line">                <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) { <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">                    value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 用户未传递实参</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) {</span><br><span class="line">                    value = <span class="keyword">null</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 实参类型存在对应的类型处理器，即已经是最终的参数值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {</span><br><span class="line">                    value = parameterObject;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 获取实参对象中对应的参数值</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">                    value = metaObject.getValue(propertyName);</span><br><span class="line">                }</span><br><span class="line">                TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">                JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) {</span><br><span class="line">                    jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 为 SQL 语句绑定对应的实参到 PreparedStatement 对象中</span></span><br><span class="line">                    typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">                } <span class="keyword">catch</span> (TypeException | SQLException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现整体上就是获取 BoundSql 对象记录的参数名称与 SQL 语句中参数的映射关系，然后获取参数名称对应的用户传递的实参设置到 PreparedStatement 对象中。如果使用过原生 JDBC 操作过数据库，对往 PreparedStatement 中填充实参的过程应该不难理解。</p>
<p>关于其余几个 StatementHandler 实现类的都比较简单，就不再展开。</p>

        <h4 id="结果集映射">
          <a href="#结果集映射" class="heading-link"><i class="fas fa-link"></i></a>结果集映射</h4>
      <p>结果集映射是 MyBatis 提供的一个强大且易用的特性，标签 <code>&lt;resultMap/&gt;</code> 用于配置数据库返回的结果集 ResultSet 与实体类属性之间的映射关系。前面我们分析了该标签的解析过程，本小节一起来探究一下 MyBatis 是如何基于这些配置执行结果集映射操作。</p>
<p>SQL 语句执行器 Executor 在调用具体的 StatementHandler 执行数据库查询操作时会针对数据库返回的结果集调用 ResultSetHandler 中相应方法执行结果集到实体类对象的映射处理。例如下面的代码块是 PreparedStatementHandler 在执行 <code>PreparedStatementHandler#query</code> 时的具体逻辑：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="comment">// 调用 ResultSetHandler#handleResultSets 执行结果集映射</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>ResultSetHandler 接口定义了结果集映射所需要的方法，具体如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理结果集，返回对应的结果对象集合 */</span></span><br><span class="line">    &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理结果集，返回对应的游标对象 */</span></span><br><span class="line">    &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">handleCursorResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理存储过程中的输出类型参数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>DefaultResultSetHandler 是目前 ResultSetHandler 接口的唯一实现。MyBatis 为结果集映射提供了灵活的配置，灵活的背后是强（复）大（杂）的映射解析过程，尤其是对于嵌套映射配置的情况。本小节力图对整个映射过程做一个比较详细的介绍，不过还是建议读者自己亲自 debug 跟踪一下整个执行过程。接下来我们围绕 <code>ResultSetHandler#handleResultSets</code> 方法对结果集映射处理过程进行分析，该方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 处理普通映射情况 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于记录结果集映射的结果对象集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取第一个结果集</span></span><br><span class="line">    ResultSetWrapper rsw = <span class="keyword">this</span>.getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取之前解析得到的封装结果集映射配置的 ResultMap 对象集合</span></span><br><span class="line">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">    <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">    <span class="comment">// 验证，如果结果集不为 null，则 resultMaps 也不能为空</span></span><br><span class="line">    <span class="keyword">this</span>.validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">    <span class="comment">// 遍历处理所有的结果集，基于结果集映射规则进行映射，并将结果记录到 multipleResults 集合中</span></span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) {</span><br><span class="line">        <span class="comment">// 获取一个配置的结果集映射标签 &lt;resultMap/&gt; 配置</span></span><br><span class="line">        ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">        <span class="comment">// 依据结果集映射配置对结果集对象进行解析，并记录到 multipleResults 集合中</span></span><br><span class="line">        <span class="keyword">this</span>.handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获取下一个待处理的结果集</span></span><br><span class="line">        rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</span><br><span class="line">        <span class="comment">// 清空 nestedResultObjects</span></span><br><span class="line">        <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 2. 处理多结果集的情况</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 常见于存储过程，存在 &lt;select resultSets="aaa,bbb"/&gt; 类似的配置，</span></span><br><span class="line"><span class="comment">     * 针对过程 1 未执行映射的结果集进行映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">    <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) {</span><br><span class="line">            <span class="comment">// 获取 resultSet 配置名称对应的 ResultMapping 配置</span></span><br><span class="line">            ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">            <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 获取对应的 &lt;resultMap/&gt; 标签配置</span></span><br><span class="line">                String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">                ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">                <span class="comment">// 执行结果集映射</span></span><br><span class="line">                <span class="keyword">this</span>.handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 获取下一个待处理的结果集</span></span><br><span class="line">            rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</span><br><span class="line">            <span class="comment">// 清空 nestedResultObjects</span></span><br><span class="line">            <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</span><br><span class="line">            resultSetCount++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// multipleResults.size() == 1 ? (List&lt;Object&gt;) multipleResults.get(0) : multipleResults</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.collapseSingleResultList(multipleResults);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的执行过程可以分为两部分：普通结果集映射和多结果集映射。其中，多结果集映射一般用于存储过程，这是一个小众化的需求，所以大部分时候上述方法仅执行第一部分的逻辑。这一部分的执行过程如代码注释，其核心在于 <code>DefaultResultSetHandler#handleResultSet</code> 方法，该方法在第二部分中也会被调用，后面会针对该方法进行专门说明。</p>
<p>下面就第二部分的触发机制举例说明，能够执行到这里一般都伴随着存储过程，这里以 MySQL 数据库为例创建一个可以返回多结果集的存储过程，其中 t_blog 表和 t_post 表的定义参考官方文档示例：</p>
<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> usp_demo(<span class="keyword">IN</span> ID <span class="type">INT</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_blog <span class="keyword">WHERE</span> id <span class="operator">=</span> ID;</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_post <span class="keyword">WHERE</span> id <span class="operator">=</span> ID;</span><br><span class="line">    <span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></div></figure>
<p>对应的映射配置如下：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"usp_demo_result_map"</span> <span class="attr">type</span>=<span class="string">"org.zhenchao.mybatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">javaType</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"title"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"org.zhenchao.mybatis.entity.Post"</span> <span class="attr">resultSet</span>=<span class="string">"posts"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"subject"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"uspDemo"</span> <span class="attr">resultSets</span>=<span class="string">"blogs,posts"</span> <span class="attr">resultMap</span>=<span class="string">"usp_demo_result_map"</span> <span class="attr">statementType</span>=<span class="string">"CALLABLE"</span>&gt;</span></span><br><span class="line">    {CALL usp_demo(#{id, jdbcType=INTEGER, mode=IN})}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>上述配置中，我们基于 resultSets 属性分别为对应的结果集命名，在执行该存储过程时会先映射 t_blog 数据表对应的结果集，映射的过程中遇到名为 posts 的结果集时，MyBatis 不会转去解析该结果集，而是会将该结果集记录到 <code>DefaultResultSetHandler#nextResultMaps</code> 属性中，等运行到第二部分时再对这些未解析的结果集统一进行映射处理。</p>
<p>上述过程中处理结果集映射的核心逻辑均位于 <code>DefaultResultSetHandler#handleResultSet</code> 方法中。该方法执行的主要逻辑在于判断当前是否指定了结果集处理器（即前面介绍过的 ResultHandler），如果没有指定则会创建一个默认的结果集处理器（默认采用 DefaultResultHandler 实现），然后调用 <code>DefaultResultSetHandler#handleRowValues</code> 方法执行映射逻辑。方法 <code>DefaultResultSetHandler#handleResultSet</code> 的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResultSet</span><span class="params">(ResultSetWrapper rsw,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ResultMap resultMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                             List&lt;Object&gt; multipleResults,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 处理多结果集嵌套映射的情况</span></span><br><span class="line">            <span class="keyword">this</span>.handleRowValues(rsw, resultMap, <span class="keyword">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 未指定 ResultHandler，构造默认的处理器</span></span><br><span class="line">            <span class="keyword">if</span> (resultHandler == <span class="keyword">null</span>) {</span><br><span class="line">                DefaultResultHandler defaultResultHandler = <span class="keyword">new</span> DefaultResultHandler(objectFactory);</span><br><span class="line">                <span class="comment">// 对结果集进行映射，并将映射结果记录到 DefaultResultHandler 对象中</span></span><br><span class="line">                <span class="keyword">this</span>.handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 获取保存在 DefaultResultHandler 对象中映射结果，记录到 multipleResults 中</span></span><br><span class="line">                multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 用户指定了 ResultHandler，使用该处理器进行处理</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">this</span>.handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// issue #228 (close resultsets)</span></span><br><span class="line">        <span class="keyword">this</span>.closeResultSet(rsw.getResultSet());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法 <code>DefaultResultSetHandler#handleRowValues</code> 会判断当前映射配置中是否存在嵌套映射的情况，如果存在嵌套映射则执行方法 <code>DefaultResultSetHandler#handleRowValuesForNestedResultMap</code> 方法处理嵌套结果集映射，否则执行 <code>DefaultResultSetHandler#handleRowValuesForSimpleResultMap</code> 方法处理简单的结果集映射。下面以简单结果集映射的过程进行分析，对于嵌套结果集映射的过程还是强烈建议大家去 debug 跟踪理解，单凭静态文字很难说清楚。</p>
<p>方法 <code>DefaultResultSetHandler#handleRowValuesForSimpleResultMap</code> 实现了对简单（相对于嵌套而言）结果集映射的处理逻辑。首先会基于 RowBounds 设置定位具体的处理行，MyBatis 对于 LIMIT 分页的处理是逻辑分页，而不是物理分页，即将符合条件的记录全部载入内存，然后在内存中进行截取，如果希望执行物理分页，可以自己编码插件，或者使用第三方插件，然后会遍历结果集中目标记录行对其逐一映射。</p>
<p>方法 <code>DefaultResultSetHandler#handleRowValuesForSimpleResultMap</code> 实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               ResultMap resultMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               ResultHandler&lt;?&gt; resultHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               RowBounds rowBounds,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    DefaultResultContext&lt;Object&gt; resultContext = <span class="keyword">new</span> DefaultResultContext&lt;&gt;();</span><br><span class="line">    ResultSet resultSet = rsw.getResultSet();</span><br><span class="line">    <span class="comment">// 针对设置了 RowBounds 定位指定的记录行</span></span><br><span class="line">    <span class="keyword">this</span>.skipRows(resultSet, rowBounds);</span><br><span class="line">    <span class="comment">// 检测是否可以继续对后续的记录行进行映射操作，可以的话就一直循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) {</span><br><span class="line">        <span class="comment">// 确定具体使用的映射配置，如果配置了 &lt;discriminator/&gt; 标签则获取最终引用的 ResultMap，否则使用当前的 ResultMap 对象</span></span><br><span class="line">        ResultMap discriminatedResultMap = <span class="keyword">this</span>.resolveDiscriminatedResultMap(resultSet, resultMap, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 基于映射配置对当前记录行进行解析</span></span><br><span class="line">        Object rowValue = <span class="keyword">this</span>.getRowValue(rsw, discriminatedResultMap, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 保存映射得到的结果对象</span></span><br><span class="line">        <span class="keyword">this</span>.storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>针对记录行的映射处理，方法首先会获取记录行对应的真正 ResultMap 映射配置对象，因为可能存在配置了 <code>&lt;discriminator/&gt;</code> 标签执行条件映射的情况，如果没有配置该标签则会使用当前实参对应的 ResultMap 对象。标签 <code>&lt;discriminator/&gt;</code> 的处理过程位于 <code>DefaultResultSetHandler#resolveDiscriminatedResultMap</code> 方法中，对照配置应该比较容易理解。获取到 ResultMap 映射配置对象之后，下一步就可以调用 <code>DefaultResultSetHandler#getRowValue</code> 方法对当前记录行执行映射处理，该方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRowValue</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">final</span> ResultLoaderMap lazyLoader = <span class="keyword">new</span> ResultLoaderMap();</span><br><span class="line">    <span class="comment">// 创建记录行映射结果对象</span></span><br><span class="line">    Object rowValue = <span class="keyword">this</span>.createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">    <span class="comment">// 如果结果对象不为 null，且没有对应的类型处理器</span></span><br><span class="line">    <span class="keyword">if</span> (rowValue != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.hasTypeHandlerForResultObject(rsw, resultMap.getType())) {</span><br><span class="line">        <span class="comment">// 创建结果对象的 MetaObject 对象</span></span><br><span class="line">        <span class="keyword">final</span> MetaObject metaObject = configuration.newMetaObject(rowValue);</span><br><span class="line">        <span class="comment">// 标记是否成功映射任何一个属性</span></span><br><span class="line">        <span class="keyword">boolean</span> foundValues = <span class="keyword">this</span>.useConstructorMappings;</span><br><span class="line">        <span class="comment">// 是否需要自动映射</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.shouldApplyAutomaticMappings(resultMap, <span class="keyword">false</span>)) {</span><br><span class="line">            <span class="comment">// 自动映射未在 &lt;resultMap/&gt; 标签中指定的列</span></span><br><span class="line">            foundValues = <span class="keyword">this</span>.applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 映射在 &lt;resultMap/&gt; 标签中指定的列</span></span><br><span class="line">        foundValues = <span class="keyword">this</span>.applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span><br><span class="line">        foundValues = lazyLoader.size() &gt; <span class="number">0</span> || foundValues;</span><br><span class="line">        rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> rowValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先会调用 <code>DefaultResultSetHandler#createResultObject</code> 方法创建实体结果对象，然后为该对象执行属性映射注入。对于未配置映射关系的属性会基于配置决定是否执行自动映射，对于明确指定映射关系的属性，则调用 <code>DefaultResultSetHandler#applyPropertyMappings</code> 方法执行映射处理，该方法的具体实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyPropertyMappings</span><span class="params">(ResultSetWrapper rsw,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      ResultMap resultMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      MetaObject metaObject,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      ResultLoaderMap lazyLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="comment">// 获取所有指明了映射关系的列名集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">    <span class="keyword">boolean</span> foundValues = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取当前 ResultMap 包含的所有映射关系配置对象 ResultMapping 列表</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">    <span class="comment">// 遍历处理映射关系 ResultMapping 列表，执行映射过程</span></span><br><span class="line">    <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) {</span><br><span class="line">        <span class="comment">// 处理列前缀</span></span><br><span class="line">        String column = <span class="keyword">this</span>.prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">        <span class="comment">// 忽略嵌套的 ResultMap 映射</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMapping.getNestedResultMapId() != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// the user added a column attribute to a nested result map, ignore it</span></span><br><span class="line">            column = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 嵌套查询 | 配置了映射关系 | 多结果集</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMapping.isCompositeResult()</span><br><span class="line">            || (column != <span class="keyword">null</span> &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH)))</span><br><span class="line">            || propertyMapping.getResultSet() != <span class="keyword">null</span>) { <span class="comment">// 存在多结果集</span></span><br><span class="line">            <span class="comment">// 执行映射，返回属性值</span></span><br><span class="line">            Object value = <span class="keyword">this</span>.getPropertyMappingValue(</span><br><span class="line">                rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">            <span class="comment">// issue #541 make property optional</span></span><br><span class="line">            <span class="keyword">final</span> String property = propertyMapping.getProperty();</span><br><span class="line">            <span class="keyword">if</span> (property == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 延迟加载的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (value == DEFERRED) {</span><br><span class="line">                foundValues = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) {</span><br><span class="line">                foundValues = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 设置属性值</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span></span><br><span class="line">                || (configuration.isCallSettersOnNulls() &amp;&amp; !metaObject.getSetterType(property).isPrimitive())) {</span><br><span class="line">                <span class="comment">// gcode issue #377, call setter on nulls (value is not 'found')</span></span><br><span class="line">                metaObject.setValue(property, value);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> foundValues;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先会获取当前结果集对应的映射关系配置和列名集合，然后遍历处理映射配置。针对嵌套查询、多结果集映射，以及普通映射的情况分而治之，这一过程位于 <code>DefaultResultSetHandler#getPropertyMappingValue</code> 方法中（实现如下）。针对嵌套查询的情况我们后面专门进行分析；对于多结果集的情况会将对应的结果集配置对象记录到 <code>DefaultResultSetHandler#nextResultMaps</code> 属性中，稍后会专门处理（即前面的第二部分代码）；针对普通的映射则会基于 TypeHandler 获取属性对应的 java 类型值，也就是我们期望的值。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getPropertyMappingValue</span><span class="params">(ResultSet rs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       MetaObject metaResultObject,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       ResultMapping propertyMapping,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       ResultLoaderMap lazyLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="comment">// 嵌套查询</span></span><br><span class="line">    <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 多结果集情况，记录对应的 resultSet，后续处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getResultSet() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.addPendingChildRelation(rs, metaResultObject, propertyMapping);</span><br><span class="line">        <span class="keyword">return</span> DEFERRED;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 基于 TypeHandler 获取属性值</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span><br><span class="line">        <span class="keyword">final</span> String column = <span class="keyword">this</span>.prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">        <span class="keyword">return</span> typeHandler.getResult(rs, column);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>最后会调用 <code>DefaultResultSetHandler#storeObject</code> 方法将实体结果对象记录到 <code>DefaultResultHandler#list</code> 属性中，并在 <code>DefaultResultSetHandler#handleResultSet</code> 方法中调用 <code>DefaultResultHandler#getResultList</code> 方法拿到这些结果对象。</p>

        <h4 id="执行器实现">
          <a href="#执行器实现" class="heading-link"><i class="fas fa-link"></i></a>执行器实现</h4>
      <p>前面已经介绍了 Executor 接口以及相关的实现类继承关系，本小节将对这些执行器实现类逐一展开分析。</p>

        <h5 id="BaseExecutor">
          <a href="#BaseExecutor" class="heading-link"><i class="fas fa-link"></i></a>BaseExecutor</h5>
      <p>BaseExecutor 是一个抽象类，实现了 Executor 接口中声明的所有方法，并采用模板方法模式抽象出 4 个模板方法交由子类实现。需要强调的一点是，BaseExecutor 抽象类引入了一级缓存支持，在相应方法实现中增加了对一级缓存的操作，因此该抽象类的所有实现类都具备一级缓存的特性。BaseExecutor 抽象类的属性定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 事务对象 */</span></span><br><span class="line"><span class="keyword">protected</span> Transaction transaction;</span><br><span class="line"><span class="comment">/** 封装的 SQL 语句执行器 */</span></span><br><span class="line"><span class="keyword">protected</span> Executor wrapper;</span><br><span class="line"><span class="comment">/** 延迟加载队列 */</span></span><br><span class="line"><span class="keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;</span><br><span class="line"><span class="comment">/** 缓存结果对象（一级缓存） */</span></span><br><span class="line"><span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line"><span class="comment">/** 缓存存储过程输出类型参数（一级缓存） */</span></span><br><span class="line"><span class="keyword">protected</span> PerpetualCache localOutputParameterCache;</span><br><span class="line"><span class="comment">/** 全局唯一的配置对象 */</span></span><br><span class="line"><span class="keyword">protected</span> Configuration configuration;</span><br><span class="line"><span class="comment">/** 记录嵌套查询的层数 */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> queryStack;</span><br><span class="line"><span class="comment">/** 标记当前 Executor 是否已经关闭 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br></pre></td></tr></tbody></table></div></figure>
<p>下面针对一些比较复杂的方法实现展开说明，首先来看一下 <code>BaseExecutor#update</code> 方法实现（如下）。需要注意的是这里的 update 并不等同于 SQL 语句中的 UPDATE 操作，对于 Executor 而言数据库操作只包含 query 和 update 两大类，这里的 query 可以理解为 SQL 语句的 SELECT 操作，而 update 则对应着 SQL 语句中的 INSERT、UPDATE、DELECT 三类操作。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing an update"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 先清空一级缓存</span></span><br><span class="line">    <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">    <span class="comment">// 执行更新操作，交由子类实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doUpdate(ms, parameter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先会判定当前 Executor 是否已被关闭，对于没有关闭的 Executor 会首先清空一级缓存，然后调用 <code>BaseExecutor#doUpdate</code> 模板方法，该方法由子类实现。</p>
<p>再来看一下 <code>BaseExecutor#query</code> 方法，该方法用于执行数据库查询操作。因为引入了一级缓存，所以这里的查询不是简单的直接查询数据库，而是会先查询一级缓存，只有在缓存不命中的情况下才会查询数据库，并利用数据库返回的结果对象更新一级缓存。该方法的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">                         RowBounds rowBounds,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="comment">// 获取执行的 SQL 语句</span></span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">    <span class="comment">// 创建缓存 key</span></span><br><span class="line">    CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">    <span class="comment">// 调用重载的 query 方法执行查询操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">                         RowBounds rowBounds,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ResultHandler resultHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                         CacheKey key,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果是非嵌套查询，且配置 &lt;select flushCache="true"/&gt; 要求执行该语句时清空一级缓存和二级缓存</span></span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) {</span><br><span class="line">        <span class="comment">// 清空一级缓存</span></span><br><span class="line">        <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">    }</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        queryStack++;</span><br><span class="line">        <span class="comment">// 尝试从一级缓存中获取结果</span></span><br><span class="line">        list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 缓存名命中，针对存储过程特殊处理，获取缓存中保存的输出类型参数记录到实参对象中</span></span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 缓存不命中，查数据库并更新缓存，本质上调用的是 doQuery 方法</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        queryStack--;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 加载缓存中记录的嵌套查询的结果对象</span></span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) {</span><br><span class="line">            deferredLoad.load();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// issue #601</span></span><br><span class="line">        deferredLoads.clear();</span><br><span class="line">        <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {</span><br><span class="line">            <span class="comment">// issue #482</span></span><br><span class="line">            <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>整个 <code>BaseExecutor#query</code> 方法的执行过程如上述代码注释。</p>
<p>方法 <code>BaseExecutor#queryCursor</code> 与 <code>BaseExecutor#query</code> 都是提供数据库查询操作，区别在于前者返回的是一个游标（Cursor）对象，而后者返回的是已经完成结果集映射的结果对象，游标需要等待用户真正操作时才会执行结果集映射的过程。</p>

        <h5 id="SimpleExecutor">
          <a href="#SimpleExecutor" class="heading-link"><i class="fas fa-link"></i></a>SimpleExecutor</h5>
      <p>SimpleExecutor 提供了对 Executor 的简单实现，针对每一次数据库操作都会创建一个新的 Statement 对象，并在操作完毕之后进行关闭。SimpleExecutor 针对抽象类 BaseExecutor 中声明的方法实现流程都相同，下面以 <code>SimpleExecutor#doQuery</code> 方法为例进行分析，该方法的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Object parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RowBounds rowBounds,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ResultHandler resultHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        <span class="comment">// 创建 StatementHandler 对象</span></span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(</span><br><span class="line">            wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="comment">// 创建 Statement 对象并为 SQL 语句绑定实参</span></span><br><span class="line">        stmt = <span class="keyword">this</span>.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="comment">// 执行数据库查询操作，以及结果集映射</span></span><br><span class="line">        <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 关闭 Statement</span></span><br><span class="line">        <span class="keyword">this</span>.closeStatement(stmt);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先会基于 <code>Configuration#newStatementHandler</code> 创建对应的 StatementHandler 对象，这里实际上是采用了前面介绍的 RoutingStatementHandler 实现类依据入参进行创建。然后会调用 <code>SimpleExecutor#prepareStatement</code> 方法创建 Statement 对象，并为 SQL 语句绑定实参。接着执行具体的数据库查询操作，对于查询操作此时会执行结果集映射处理。最后关闭 Statement 对象。</p>
<p>方法 <code>SimpleExecutor#prepareStatement</code> 实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    Statement stmt;</span><br><span class="line">    <span class="comment">// 获取数据库连接</span></span><br><span class="line">    Connection connection = <span class="keyword">this</span>.getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 获取 Statement 对象</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">// 执行参数绑定</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>其中 <code>StatementHandler#prepare</code> 方法的运行逻辑前面已经分析过。方法 <code>StatementHandler#parameterize</code> 执行了参数绑定的操作，该方法在 SimpleStatementHandler 中为空实现，毕竟对于 Statement 来说不支持设置参数；而对于 PreparedStatementHandler 和 CallableStatementHandler 而言都是调用了 <code>ParameterHandler#setParameters</code> 方法，该方法在前面已经专门分析过，不再重复介绍。</p>
<ul>
<li><strong>ReuseExecutor</strong></li>
</ul>
<p>ReuseExecutor 提供了对 Statement 对象重用的机制，以减少该对象创建和销毁，以及 SQL 预编译所带来的开销。ReuseExecutor 类中定义了一个 <code>ReuseExecutor#statementMap</code> 属性（如下），其中 key 为 SQL 语句，value 为对应的 Statement 对象，以此实现对 Statement 对象的复用。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 缓存 Statement 对象，key 为对应的 SQL 语句（带有 ? 占位符） */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Statement&gt; statementMap = <span class="keyword">new</span> HashMap&lt;String, Statement&gt;();</span><br></pre></td></tr></tbody></table></div></figure>
<p>ReuseExecutor 中的方法实现也基本上沿用了同一套思路，仍然以 <code>ReuseExecutor#doQuery</code> 为例进行说明，该方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Object parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RowBounds rowBounds,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ResultHandler resultHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 创建对应的 StatementHandler 对象</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 先尝试从缓存中获取当前 SQL 对应的 Statement 对象，缓存不命中则创建一个新的并缓存</span></span><br><span class="line">    Statement stmt = <span class="keyword">this</span>.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 执行数据库查询操作，以及结果集映射</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法与 <code>SimpleExecutor#doQuery</code> 的区别在于在获取 Statement 对象时会先尝试从本地缓存中获取，如果缓存不命中则会创建一个新的 Statement 对象，并更新缓存，实现位于 <code>ReuseExecutor#prepareStatement</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    Statement stmt;</span><br><span class="line">    BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="comment">// 获取缓存的 Statement 对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasStatementFor(sql)) {</span><br><span class="line">        stmt = <span class="keyword">this</span>.getStatement(sql);</span><br><span class="line">        <span class="keyword">this</span>.applyTransactionTimeout(stmt);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 缓存不命中，新建一个 Statement 对象并缓存</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Connection connection = <span class="keyword">this</span>.getConnection(statementLog);</span><br><span class="line">        stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">        <span class="keyword">this</span>.putStatement(sql, stmt);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 绑定实参</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h5 id="BatchExecutor">
          <a href="#BatchExecutor" class="heading-link"><i class="fas fa-link"></i></a>BatchExecutor</h5>
      <p>BatchExecutor 用于批量执行 SQL 语句。通常应用程序都是单行的执行 SQL 语句，但是某些场景下单行执行数据库操作是比较耗时的，比如需要远程执行数据库操作。因此，JDBC 针对 INSERT、UPDATE，以及 DELETE 操作提供了批量执行的支持。</p>
<p>BatchExecutor 是批量 SQL 语句执行器，其属性定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 缓存多个 {<span class="doctag">@link</span> Statement} 对象，每个对象都对应多条 SQL 语句 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Statement&gt; statementList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/** 记录批处理的结果，每个 {<span class="doctag">@link</span> BatchResult} 对应一个 {<span class="doctag">@link</span> Statement} 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;BatchResult&gt; batchResultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/** 当前执行的 SQL 语句 */</span></span><br><span class="line"><span class="keyword">private</span> String currentSql;</span><br><span class="line"><span class="comment">/** 当前操作的 {<span class="doctag">@link</span> MappedStatement} 对象 */</span></span><br><span class="line"><span class="keyword">private</span> MappedStatement currentStatement;</span><br></pre></td></tr></tbody></table></div></figure>
<p>下面探究一下 BatchExecutor 的批处理执行过程。首先来看一下 <code>BatchExecutor#doUpdate</code> 方法实现，该方法用于添加批处理 SQL 语句：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 基于参数创建对应的 StatementHandler 对象</span></span><br><span class="line">    <span class="keyword">final</span> StatementHandler handler = configuration.newStatementHandler(</span><br><span class="line">        <span class="keyword">this</span>, ms, parameterObject, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">    <span class="keyword">final</span> String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">final</span> Statement stmt;</span><br><span class="line">    <span class="comment">// 当前执行的 SQL 语句与前一次执行的 SQL 语句（不包含实参）相同，且对应的 MappedStatement 对象也相同</span></span><br><span class="line">    <span class="keyword">if</span> (sql.equals(currentSql) &amp;&amp; ms.equals(currentStatement)) {</span><br><span class="line">        <span class="comment">// 获取缓存的最后一个 Statement 对象，即前一次使用的 Statement 对象</span></span><br><span class="line">        <span class="keyword">int</span> last = statementList.size() - <span class="number">1</span>;</span><br><span class="line">        stmt = statementList.get(last);</span><br><span class="line">        <span class="keyword">this</span>.applyTransactionTimeout(stmt);</span><br><span class="line">        <span class="comment">// 绑定实参</span></span><br><span class="line">        handler.parameterize(stmt);<span class="comment">//fix Issues 322</span></span><br><span class="line">        BatchResult batchResult = batchResultList.get(last);</span><br><span class="line">        batchResult.addParameterObject(parameterObject);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 当前执行的 SQL 语句与前一次执行的 SQL 语句不同</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Connection connection = <span class="keyword">this</span>.getConnection(ms.getStatementLog());</span><br><span class="line">        <span class="comment">// 获取一个新的 Statement 对象</span></span><br><span class="line">        stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">        <span class="comment">// 绑定实参</span></span><br><span class="line">        handler.parameterize(stmt);    <span class="comment">//fix Issues 322</span></span><br><span class="line">        <span class="comment">// 记录本次执行的 SQL 语句和 MappedStatement 对象</span></span><br><span class="line">        currentSql = sql;</span><br><span class="line">        currentStatement = ms;</span><br><span class="line">        <span class="comment">// 缓存新建的 Statement 对象</span></span><br><span class="line">        statementList.add(stmt);</span><br><span class="line">        batchResultList.add(<span class="keyword">new</span> BatchResult(ms, sql, parameterObject));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 基于 Statement#addBatch 方法添加批量 SQL 语句</span></span><br><span class="line">    handler.batch(stmt);</span><br><span class="line">    <span class="keyword">return</span> BATCH_UPDATE_RETURN_VALUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法中会判断当前执行的 SQL 模式（包含 <code>?</code> 占位符的 SQL 语句）是否与前一次执行的相同，如果相同就会获取上次执行的 Statement 对象，并为之绑定实参；否则就会创建一个新的 Statement 对象，并记录本次执行的 SQL 模式，最后基于底层的数据库批处理方法 <code>Statement#addBatch</code> 添加批量 SQL 语句。由上述方法我们可以知道，对于连续同模式的批处理 SQL 操作会共享同一个 Statement 对象。</p>
<p>那么这些添加的批量 SQL 又是如何被执行的呢？这个过程位于  <code>BatchExecutor#doFlushStatements</code> 方法中，方法如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 用于存储批量处理结果</span></span><br><span class="line">        List&lt;BatchResult&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (isRollback) {</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 遍历处理缓存的 Statement 集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = statementList.size(); i &lt; n; i++) {</span><br><span class="line">            Statement stmt = statementList.get(i);</span><br><span class="line">            <span class="keyword">this</span>.applyTransactionTimeout(stmt);</span><br><span class="line">            BatchResult batchResult = batchResultList.get(i);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 批量执行当前 Statement 蕴含的多条 SQL 语句，并记录每条 SQL 语句影响的行数</span></span><br><span class="line">                batchResult.setUpdateCounts(stmt.executeBatch());</span><br><span class="line">                MappedStatement ms = batchResult.getMappedStatement();</span><br><span class="line">                List&lt;Object&gt; parameterObjects = batchResult.getParameterObjects();</span><br><span class="line">                KeyGenerator keyGenerator = ms.getKeyGenerator();</span><br><span class="line">                <span class="keyword">if</span> (Jdbc3KeyGenerator.class.equals(keyGenerator.getClass())) {</span><br><span class="line">                    <span class="comment">// 获取数据库生成的主键，并记录到 parameterObjects 中</span></span><br><span class="line">                    Jdbc3KeyGenerator jdbc3KeyGenerator = (Jdbc3KeyGenerator) keyGenerator;</span><br><span class="line">                    jdbc3KeyGenerator.processBatch(ms, stmt, parameterObjects);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (!NoKeyGenerator.class.equals(keyGenerator.getClass())) { <span class="comment">//issue #141</span></span><br><span class="line">                    <span class="keyword">for</span> (Object parameter : parameterObjects) {</span><br><span class="line">                        keyGenerator.processAfter(<span class="keyword">this</span>, ms, stmt, parameter);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// Close statement to close cursor #1109</span></span><br><span class="line">                <span class="keyword">this</span>.closeStatement(stmt);</span><br><span class="line">            } <span class="keyword">catch</span> (BatchUpdateException e) {</span><br><span class="line">                <span class="comment">// ... 省略异常处理</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 记录封装当前 Statement 对象执行结果的 batchResult 到集合中</span></span><br><span class="line">            results.add(batchResult);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 关闭所有的 Statement 对象</span></span><br><span class="line">        <span class="keyword">for</span> (Statement stmt : statementList) {</span><br><span class="line">            <span class="keyword">this</span>.closeStatement(stmt);</span><br><span class="line">        }</span><br><span class="line">        currentSql = <span class="keyword">null</span>;</span><br><span class="line">        statementList.clear();</span><br><span class="line">        batchResultList.clear();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法会遍历我们在 <code>BatchExecutor#doUpdate</code> 中构造的 Statement 集合，分别执行集合中蕴含的 Statement 对象，并将执行的结果记录到 BatchResult 对象中（说明：在 <code>BatchExecutor#doUpdate</code> 方法中已经为每个 Statement 对象构造好了一个空的 BatchResult 对象，记录在 <code>BatchExecutor#batchResultList</code> 集合中），最后将 BatchResult 对象封装到集合中返回。因为都是数据库更新一类的操作，所以这里没有复杂的结果集映射，只需要记录每一条 SQL 语句执行所影响的行数即可。</p>

        <h5 id="CachingExecutor">
          <a href="#CachingExecutor" class="heading-link"><i class="fas fa-link"></i></a>CachingExecutor</h5>
      <p>由前面 Executor 的继承关系我们可以看到，CachingExecutor 相对于其它 Executor 实现来说似乎有其特别之处。CachingExecutor 直接实现了 Executor 接口，实际上它是一个 Executor 装饰器， <strong>用于为 Executor 提供二级缓存支持</strong> 。该接口的属性定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 装饰的 {<span class="doctag">@link</span> Executor} 对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;</span><br><span class="line"><span class="comment">/** 用于管理当前使用的二级缓存对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br></pre></td></tr></tbody></table></div></figure>
<p>其中第一个属性就是 CachingExecutor 具体修饰的 Executor 对象。我们来看一下第二个属性，TransactionalCacheManager 用来管理当前 CachingExecutor 对应的二级缓存对象，它的方法实现都比较简单，其中相对让人疑惑的是它的唯一一个属性：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** key 为对应的 {<span class="doctag">@link</span> CachingExecutor} 使用的二级缓存对象，value 为采用 {<span class="doctag">@link</span> TransactionalCache} 装饰的二级缓存对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></tbody></table></div></figure>
<p>该属性的 key 就是当前对应的二级缓存，而 value 则是对于该二级缓存对象采用 TransactionalCache 装饰后的对象。所以 key 和 value 本质上都映射到同一个缓存对象，只是 value 采用了 TransactionalCache 进行增强。TransactionalCache 也是一个缓存装饰器，在前面介绍缓存装饰器实现时特意留着没有说明，这里一起来分析一下。该装饰器的属性定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 被装饰的 {<span class="doctag">@link</span> Cache} 对象（二级缓存） */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">/** 是否在提交事务时清空缓存 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> clearOnCommit;</span><br><span class="line"><span class="comment">/** 用于缓存数据，当提交事务时会将其中的数据写入二级缓存 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; entriesToAddOnCommit;</span><br><span class="line"><span class="comment">/** 缓存未命中的 key */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Object&gt; entriesMissedInCache;</span><br></pre></td></tr></tbody></table></div></figure>
<p>对应的读缓存和写缓存操作，以及事务提交方法实现比较简单，读者可以自行阅读源码。</p>
<p>继续回来看 CachingExecutor 的实现，所有实现方法中只有 <code>CachingExecutor#query</code> 方法稍微复杂一些，该方法的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object parameterObject,</span></span></span><br><span class="line"><span class="function"><span class="params">                         RowBounds rowBounds,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="comment">// 获取对应的 BoundSql 对象，并创建对应的 CacheKey</span></span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="comment">// 调用重载的 query 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object parameterObject,</span></span></span><br><span class="line"><span class="function"><span class="params">                         RowBounds rowBounds,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ResultHandler resultHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                         CacheKey key,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="comment">// 获取当前命名空间对应的二级缓存对象</span></span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="comment">// 判断是否启用了二级缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 依据配置决定是否清空二级缓存</span></span><br><span class="line">        <span class="keyword">this</span>.flushCacheIfRequired(ms);</span><br><span class="line">        <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 确保不是存储过程输出类型的参数</span></span><br><span class="line">            <span class="keyword">this</span>.ensureNoOutParams(ms, boundSql);</span><br><span class="line">            <span class="comment">// 查询二级缓存</span></span><br><span class="line">            <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 二级缓存不命中，执行一级缓存查询，再不命中就查询数据库</span></span><br><span class="line">                list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                <span class="comment">// 缓存到 TransactionalCache#entriesToAddOnCommit 中</span></span><br><span class="line">                tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 未启用二级缓存，则查询一级缓存，再不命中就查询数据库</span></span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>正如我们一开始对于 MyBatis 缓存结构设计描绘的那样，上述方法首先在二级缓存中进行检索，如果二级缓存不命中则会执行被装饰的 Executor 对象的 <code>Executor#query</code> 方法。由前面的分析我们知道，Executor 的实现都自带一级缓存特性，所以接下去会查询一级缓存。只有在一级缓存也不命中的情况下，请求才会落库，并由数据库返回的结果对象更新一级缓存和二级缓存。</p>
<p>那么这里使用的二级缓存对象是在哪里创建的呢？实际上前面我们就定义说二级缓存是应用级别的，所以当应用启动时二级缓存就已经被创建了，这个过程发生在对映射文件进行解析时。在映射文件中我们会按照需要配置一定的 <code>&lt;cache/&gt;</code> 和 <code>&lt;cache-ref&gt;</code> 标签，而在解析 <code>&lt;cache/&gt;</code> 标签时会调用 <code>MapperBuilderAssistant#useNewCache</code> 方法创建对应的二级缓存对象。</p>

        <h3 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>本文对 MyBatis 执行 SQL 语句所涉及到的各个方面做了一个比较详细的分析。当我们基于 MyBatis 触发一次数据库操作时，首先需要开启一次数据库会话，然后获取目标 Mapper 接口，并调用相应的 Mapper 方法执行数据库操作，最后拿到操作结果。MyBatis 在这中间基于动态代理机制实现了 SQL 语句的检索、参数绑定、数据库操作，以及结果集映射等一系列操作，并引入了缓存机制优化数据库查询性能。</p>
<p>回过头来看，MyBatis 的整体设计还是非常巧妙的，却也很是直观且简单，是对动态代理机制的典型应用，其设计思想和对于设计模式的应用值得我们在实际开发中借鉴。</p>
<p>本文是 MyBatis 源码解析系列的最后一篇文章，由于时间仓促，再加上作者水平有限，整个系列的文章中不免有错误之处，还望批评指正！</p>

        <h3 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h3>
      <ol>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis 官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/27087564/">MyBatis 技术内幕</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2017/10/15/mybatis/mybatis-execute-sql/">https://plotor.github.io/2017/10/15/mybatis/mybatis-execute-sql/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/MyBatis/">MyBatis</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2017/10/18/solution/throttle/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">限流技术中的常用算法及其优缺点</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2017/10/14/mybatis/mybatis-mapper/"><span class="paginator-prev__text">MyBatis 源码解析：映射文件的加载与解析</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">
          SQL 会话管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-Mapper-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">
          动态代理 Mapper 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">
          SQL 语句执行器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">
          缓存结构设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Statement-%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">
          Statement 处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E9%9B%86%E6%98%A0%E5%B0%84"><span class="toc-number">3.3.</span> <span class="toc-text">
          结果集映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.</span> <span class="toc-text">
          执行器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BaseExecutor"><span class="toc-number">3.4.1.</span> <span class="toc-text">
          BaseExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SimpleExecutor"><span class="toc-number">3.4.2.</span> <span class="toc-text">
          SimpleExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BatchExecutor"><span class="toc-number">3.4.3.</span> <span class="toc-text">
          BatchExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CachingExecutor"><span class="toc-number">3.4.4.</span> <span class="toc-text">
          CachingExecutor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">
          总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">95</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2024</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>