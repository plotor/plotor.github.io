<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="上一篇我们分析了配置文件的加载与解析过程，本文将继续对映射文件的加载与解析实现进行分析。MyBatis 的映射文件用于配置 SQL 语句、二级缓存，以及结果集映射等，是区别于其它 ORM 框架的主要特色之一。 在上一篇分析配置文件 &lt;mappers&#x2F;&gt; 标签的解析实现时，了解到 MyBatis 最终通过调用 XMLMapperBuilder#parse 方法实现对映射文件的解析操作，本">
<meta property="og:type" content="article">
<meta property="og:title" content="MyBatis 源码解析：映射文件的加载与解析">
<meta property="og:url" content="https://plotor.github.io/2017/10/14/mybatis/mybatis-mapper/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="上一篇我们分析了配置文件的加载与解析过程，本文将继续对映射文件的加载与解析实现进行分析。MyBatis 的映射文件用于配置 SQL 语句、二级缓存，以及结果集映射等，是区别于其它 ORM 框架的主要特色之一。 在上一篇分析配置文件 &lt;mappers&#x2F;&gt; 标签的解析实现时，了解到 MyBatis 最终通过调用 XMLMapperBuilder#parse 方法实现对映射文件的解析操作，本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://plotor.github.io/images/2017/mybatis-sqlnode.png">
<meta property="og:image" content="https://plotor.github.io/images/2017/mybatis-sqlsource.png">
<meta property="article:published_time" content="2017-10-14T08:58:40.000Z">
<meta property="article:modified_time" content="2025-03-12T02:34:37.241Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="MyBatis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://plotor.github.io/images/2017/mybatis-sqlnode.png"><title>MyBatis 源码解析：映射文件的加载与解析 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2017/10/14/mybatis/mybatis-mapper/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">MyBatis 源码解析：映射文件的加载与解析</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2017-10-14</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">17k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">82分</span></span></div></header><div class="post-body"><p>上一篇我们分析了配置文件的加载与解析过程，本文将继续对映射文件的加载与解析实现进行分析。MyBatis 的映射文件用于配置 SQL 语句、二级缓存，以及结果集映射等，是区别于其它 ORM 框架的主要特色之一。</p>
<p>在上一篇分析配置文件 <code>&lt;mappers/&gt;</code> 标签的解析实现时，了解到 MyBatis 最终通过调用 <code>XMLMapperBuilder#parse</code> 方法实现对映射文件的解析操作，本文我们将以此方法作为入口，探究 MyBatis 加载和解析映射文件的实现机制。<a id="more"></a></p>
<p>方法 <code>XMLMapperBuilder#parse</code> 的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/* 1. 加载并解析映射文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) {</span><br><span class="line">        <span class="comment">// 加载并解析 &lt;mapper/&gt; 标签下的配置</span></span><br><span class="line">        <span class="keyword">this</span>.configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">        <span class="comment">// 标记该映射文件已被解析</span></span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        <span class="comment">// 注册当前映射文件关联的 Mapper 接口（标签 &lt;mapper namespace=""/&gt; 对应的 namespace 属性）</span></span><br><span class="line">        <span class="keyword">this</span>.bindMapperForNamespace();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 处理解析过程中失败的标签 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理解析失败的 &lt;resultMap/&gt; 标签</span></span><br><span class="line">    <span class="keyword">this</span>.parsePendingResultMaps();</span><br><span class="line">    <span class="comment">// 处理解析失败的 &lt;cache-ref/&gt; 标签</span></span><br><span class="line">    <span class="keyword">this</span>.parsePendingCacheRefs();</span><br><span class="line">    <span class="comment">// 处理解析失败的 SQL 语句标签</span></span><br><span class="line">    <span class="keyword">this</span>.parsePendingStatements();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>MyBatis 在解析映射文件时首先会判断该映射文件是否被解析过，对于没有被解析过的文件则会调用 <code>XMLMapperBuilder#configurationElement</code> 方法解析所有配置，并注册当前映射文件关联的 Mapper 接口。对于解析过程中处理异常的标签，MyBatis 会将其记录到 Configuration 对象对应的属性中，并在方法最后再次尝试二次解析。</p>
<p>整个 <code>XMLMapperBuilder#configurationElement</code> 方法实现了对映射文件解析的核心步骤，与配置文件解析的实现方式一样，这也是一个调度方法，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获取 &lt;mapper/&gt; 标签的 namespace 属性，设置当前映射文件关联的 Mapper 接口</span></span><br><span class="line">        String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">        <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">        }</span><br><span class="line">        builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">        <span class="comment">// 解析 &lt;cache-ref/&gt; 子标签，多个 mapper 可以共享同一个二级缓存</span></span><br><span class="line">        <span class="keyword">this</span>.cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;cache/&gt; 子标签</span></span><br><span class="line">        <span class="keyword">this</span>.cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;parameterMap/&gt; 子标签，已废弃</span></span><br><span class="line">        <span class="keyword">this</span>.parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;resultMap/&gt; 子标签，建立结果集与对象属性之间的映射关系</span></span><br><span class="line">        <span class="keyword">this</span>.resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;sql/&gt; 子标签</span></span><br><span class="line">        <span class="keyword">this</span>.sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">        <span class="comment">// 解析 &lt;select/&gt;、&lt;insert/&gt;、&lt;update/&gt; 和 &lt;delete/&gt; 子标签</span></span><br><span class="line">        <span class="keyword">this</span>.buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>每个映射文件都关联一个具体的 Mapper 接口，而 <code>&lt;mapper/&gt;</code> 节点的 namespace 属性则用于指定对应的 Mapper 接口限定名。上述方法首先会获取 namespace 属性，然后调用相应方法对每个子标签进行解析，下面逐一展开分析。</p>

        <h3 id="加载与解析映射文件">
          <a href="#加载与解析映射文件" class="heading-link"><i class="fas fa-link"></i></a>加载与解析映射文件</h3>
      <p>下面对各个子标签的解析过程逐一展开分析，考虑到 <code>&lt;parameterMap/&gt;</code> 子标签已废弃，所以不再对其多作介绍。</p>

        <h4 id="解析-cache-标签">
          <a href="#解析-cache-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 cache 标签</h4>
      <p>MyBatis 在设计上分为一级缓存和二级缓存（关于缓存机制将会在下一篇分析 SQL 语句执行过程时进行介绍，这里只要知道有这样两个概念即可），该标签用于对二级缓存进行配置。在具体分析 <code>&lt;cache/&gt;</code> 标签之前，我们需要对 MyBatis 的缓存类设计有一个了解，不然可能会云里雾里。MyBatis 的缓存类设计还是非常巧妙的，不管是一级缓存还是二级缓存，都实现自同一个 Cache 接口：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>{</span><br><span class="line">    <span class="comment">/** 缓存对象 ID */</span></span><br><span class="line">    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/** 添加数据到缓存，一般来说 key 是 {<span class="doctag">@link</span> CacheKey} 类型 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line">    <span class="comment">/** 从缓存中获取 key 对应的 value */</span></span><br><span class="line">    <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="comment">/** 从缓存中移除指定对象 */</span></span><br><span class="line">    <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="comment">/** 清空缓存 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存对象的个数（不是缓存的容量），</span></span><br><span class="line"><span class="comment">     * 该方法不会在 MyBatis 核心代码中被调用，可以是一个空实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存读写锁，</span></span><br><span class="line"><span class="comment">     * 该方法不会在 MyBatis 核心代码中被调用，可以是一个空实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Cache 接口中声明的缓存操作方法中规中矩。围绕该接口，MyBatis 实现了基于 HashMap 数据结构的基本实现 PerpetualCache 类，该实现类的各项方法实现都是对 HashMap API 的封装，比较简单。在整个缓存类设计方面，MyBatis 使用了典型的装饰模式为缓存对象增加不同的特性，下表对这些装饰器进行了简单介绍。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>实现类</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BlockingCache</td>
<td>阻塞式缓存装饰器</td>
<td>采用 ConcurrentHashMap 对象记录每个 key 对应的可重入锁对象，当执行 getObject 操作时会尝试获取 key 对应的锁对象，并应用带有超时机制的加锁操作，在获取到缓存值之后会释放锁。</td>
</tr>
<tr>
<td>FifoCache</td>
<td>先进先出缓存装饰器</td>
<td>采用双端队列记录 key 进入缓存的顺序，队列的大小默认是 1024，当执行 putObject 操作时，如果当前缓存的对象数超过缓存大小，则会触发 FIFO 策略。</td>
</tr>
<tr>
<td>LruCache</td>
<td>近期最少使用缓存装饰器</td>
<td>通过 LinkedHashMap 类型的 keyMap 属性记录缓存中每个 key 的使用情况，并使用 eldestKey 对象记录当前最少被使用的 key，当缓存达到容量上限时将会移除使用频率最小的缓存项。</td>
</tr>
<tr>
<td>LoggingCache</td>
<td>日志功能缓存装饰器</td>
<td>并不是如其字面意思是对缓存增加日志记录功能，该缓存装饰器中增加了两个属性：requests 和 hits，分别用于记录缓存被访问的次数和缓存命中的次数，并提供了 getHitRatio 方法以获取当前缓存的命中率。</td>
</tr>
<tr>
<td>ScheduledCache</td>
<td>周期性清理缓存装饰器</td>
<td>用于定期对缓存进行执行 clear 操作，其中定义了两个属性：clearInterval 和 lastClear，分别用来记录执行清理的时间间隔（默认为 1 小时）和最近一次执行清理的时间戳，在每次操作缓存时都会触发对缓存当前清理状态的检查，如果间隔时间达到设置值，就会触发对缓存的清理操作。</td>
</tr>
<tr>
<td>SerializedCache</td>
<td>序列化支持缓存装饰器</td>
<td>用于对缓存值进行序列化处理后再进行缓存，当我们执行 putObject 操作时，该装饰器会基于 java 的序列化机制对缓存值进行序列化（序列化结果存储在内存），反之，当我们执行 getObject 操作时，如果对应的缓存值存在，则会对该值执行反序列化再返回。</td>
</tr>
<tr>
<td>SoftCache</td>
<td>软引用缓存装饰器</td>
<td>通过软引用 Entry 内部类对缓存值进行修饰，值的生命周期受 GC 操作影响。</td>
</tr>
<tr>
<td>WeakCache</td>
<td>弱引用缓存装饰器</td>
<td>实现同 SoftCache，只是这里使用的是弱引用。</td>
</tr>
<tr>
<td>SynchronizedCache</td>
<td>同步缓存装饰器</td>
<td>通过在相应的缓存操作方法前都增加了 synchronized 关键字修饰，类似于 HashTable 的实现方式。</td>
</tr>
<tr>
<td>TransactionalCache</td>
<td>事务缓存装饰器</td>
<td>主要用于二级缓存，留到下一篇介绍缓存模块设计时再进行分析。</td>
</tr>
</tbody></table></div>
<p>介绍完了缓存类的基本设计，我们再回过头来继续分析 <code>&lt;cache/&gt;</code> 标签的解析过程，由 <code>XMLMapperBuilder#cacheElement</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 获取相应的是属性配置</span></span><br><span class="line">        String type = context.getStringAttribute(<span class="string">"type"</span>, <span class="string">"PERPETUAL"</span>); <span class="comment">// 缓存实现类型，可以指定自定义实现</span></span><br><span class="line">        Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">        String eviction = context.getStringAttribute(<span class="string">"eviction"</span>, <span class="string">"LRU"</span>); <span class="comment">// 缓存清除策略，默认是 LRU，还可以是 FIFO、SOFT，以及 WEAK</span></span><br><span class="line">        Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">        Long flushInterval = context.getLongAttribute(<span class="string">"flushInterval"</span>); <span class="comment">// 刷新间隔，单位：毫秒</span></span><br><span class="line">        Integer size = context.getIntAttribute(<span class="string">"size"</span>); <span class="comment">// 缓存大小，默认为 1024</span></span><br><span class="line">        <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">"readOnly"</span>, <span class="keyword">false</span>); <span class="comment">// 是否只读</span></span><br><span class="line">        <span class="keyword">boolean</span> blocking = context.getBooleanAttribute(<span class="string">"blocking"</span>, <span class="keyword">false</span>); <span class="comment">// 是否阻塞</span></span><br><span class="line">        Properties props = context.getChildrenAsProperties();</span><br><span class="line">        <span class="comment">// 创建二级缓存，并填充 Configuration 对象</span></span><br><span class="line">        builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先会获取 <code>&lt;cache/&gt;</code> 标签的相关属性配置，然后调用 <code>MapperBuilderAssistant#useNewCache</code> 方法创建缓存对象，并记录到 Configuration 对象中。方法 <code>MapperBuilderAssistant#useNewCache</code> 中使用了缓存对象构造器 CacheBuilder 创建缓存对象，一起来看一下 <code>CacheBuilder#build</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 如果没有指定自定义缓存实现类，则设置缓存默认实现（以 PerpetualCache 作为默认实现，以 LruCache 作为默认装饰器）</span></span><br><span class="line">    <span class="keyword">this</span>.setDefaultImplementations();</span><br><span class="line">    <span class="comment">// 反射创建缓存对象</span></span><br><span class="line">    Cache cache = <span class="keyword">this</span>.newBaseCacheInstance(implementation, id);</span><br><span class="line">    <span class="comment">// 初始化缓存对象</span></span><br><span class="line">    <span class="keyword">this</span>.setCacheProperties(cache);</span><br><span class="line">    <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">    <span class="comment">// 如果缓存采用 PerpetualCache 实现，则遍历使用注册的装饰器进行装饰</span></span><br><span class="line">    <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) {</span><br><span class="line">        <span class="comment">// 遍历装饰器集合，基于反射方式装饰缓存对象</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) {</span><br><span class="line">            cache = <span class="keyword">this</span>.newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">            <span class="keyword">this</span>.setCacheProperties(cache);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 采用标准装饰器进行装饰</span></span><br><span class="line">        cache = <span class="keyword">this</span>.setStandardDecorators(cache);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 采用日志缓存装饰器对缓存对象进行装饰</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) {</span><br><span class="line">        cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>构造缓存对象时首先会判断是否指定了自定义的缓存实现类，否则使用默认的缓存实现（即以 PerpetualCache 作为默认实现，以 LruCache 作为默认缓存装饰器）；然后选择 String 类型参数的构造方法构造缓存对象，并基于配置对缓存对象进行初始化；最后依据缓存实现采用相应的装饰器予以装饰。</p>
<p>方法 <code>CacheBuilder#setCacheProperties</code> 除了用于设置相应属性配置外，还会判断缓存类是否实现了 InitializingObject 接口，以决定是否调用 <code>InitializingObject#initialize</code> 初始化方法。</p>

        <h4 id="解析-cache-ref-标签">
          <a href="#解析-cache-ref-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 cache-ref 标签</h4>
      <p>标签 <code>&lt;cache/&gt;</code> 默认的作用域限定在标签所在的 namespace 范围内，如果希望能够让一个缓存对象在多个 namespace 之间共享，可以定义 <code>&lt;cache-ref/&gt;</code> 标签以引用其它命名空间中定义的缓存对象。标签 <code>&lt;cache-ref/&gt;</code> 的解析位于 <code>XMLMapperBuilder#cacheRefElement</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheRefElement</span><span class="params">(XNode context)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 记录 &lt;当前节点所在的 namespace, 引用缓存对象所在的 namespace&gt; 映射关系到 Configuration 中</span></span><br><span class="line">        configuration.addCacheRef(builderAssistant.getCurrentNamespace(), context.getStringAttribute(<span class="string">"namespace"</span>));</span><br><span class="line">        <span class="comment">// 构造缓存引用解析器 CacheRefResolver 对象</span></span><br><span class="line">        CacheRefResolver cacheRefResolver = <span class="keyword">new</span> CacheRefResolver(builderAssistant, context.getStringAttribute(<span class="string">"namespace"</span>));</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 从记录缓存对象的 Configuration#caches 集合中获取引用的缓存对象</span></span><br><span class="line">            cacheRefResolver.resolveCacheRef();</span><br><span class="line">        } <span class="keyword">catch</span> (IncompleteElementException e) {</span><br><span class="line">            <span class="comment">// 如果解析出现异常则记录到 Configuration#incompleteCacheRefs 中，稍后再处理</span></span><br><span class="line">            configuration.addIncompleteCacheRef(cacheRefResolver);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先会在 <code>Configuration#cacheRefMap</code> 属性中记录一下当前的引用关系，其中 key 是 <code>&lt;cache-ref/&gt;</code> 所在的 namespace，value 则是引用的缓存对象所在的 namespace。然后从 <code>Configuration#caches</code> 属性中获取引用的缓存对象，在分析 <code>&lt;cache/&gt;</code> 标签时，我们曾提及到最终解析构造的缓存对象会记录到 <code>Configuration#caches</code> 属性中，这里则是一个逆过程。</p>

        <h4 id="解析-resultMap-标签">
          <a href="#解析-resultMap-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 resultMap 标签</h4>
      <p>标签 <code>&lt;resultMap/&gt;</code> 用于配置结果集映射，建立结果集与实体类对象属性之间的映射关系。这是一个非常有用且提升开发效率的配置，如果是纯 JDBC 开发，在处理结果集与实体类对象之间的映射时还需要手动硬编码注入。对于一张字段较多的表来说，简直写到手抽筋，而 <code>&lt;resultMap/&gt;</code> 标签配置配合 mybatis-generator 工具的逆向工程可以解放我们的双手。下面是一个典型的配置，用于建立数据表 t_user 与 User 实体类之间的属性映射关系：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"org.zhenchao.mybatis.entity.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"phone"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"phone"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>在开始介绍 <code>&lt;resultMap/&gt;</code> 标签的解析过程之前，我们需要对该标签涉及到的两个主要的类 ResultMapping 和 ResultMap 有一个了解。前者用于封装除 <code>&lt;discriminator/&gt;</code> 标签以外的其它子标签配置（该标签具备自己的封装类），后者则用于封装整个 <code>&lt;resultMap/&gt;</code> 标签。</p>
<ul>
<li><strong>ResultMapping</strong></li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultMapping</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 对应标签的 property 属性 */</span></span><br><span class="line">    <span class="keyword">private</span> String property;</span><br><span class="line">    <span class="comment">/** 对应标签的 column 属，配置数据表列名（or 别名） */</span></span><br><span class="line">    <span class="keyword">private</span> String column;</span><br><span class="line">    <span class="comment">/** 对应 java 类型，配置类型全限定名（or 别名） */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; javaType;</span><br><span class="line">    <span class="comment">/** 对应列的 JDBC 类型 */</span></span><br><span class="line">    <span class="keyword">private</span> JdbcType jdbcType;</span><br><span class="line">    <span class="comment">/** 类型处理器，会覆盖默认类型处理器 */</span></span><br><span class="line">    <span class="keyword">private</span> TypeHandler&lt;?&gt; typeHandler;</span><br><span class="line">    <span class="comment">/** 对应标签的 resultMap 属性，以 id 的方式引某个已定义的 &lt;resultMap/&gt; */</span></span><br><span class="line">    <span class="keyword">private</span> String nestedResultMapId;</span><br><span class="line">    <span class="comment">/** 对应标签的 select 属性，以 id 的方式引用某个已定义的 &lt;select/&gt; */</span></span><br><span class="line">    <span class="keyword">private</span> String nestedQueryId;</span><br><span class="line">    <span class="comment">/** 对标签的 notNullColumns 属性 */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; notNullColumns;</span><br><span class="line">    <span class="comment">/** 对应标签的 columnPrefix 属性 */</span></span><br><span class="line">    <span class="keyword">private</span> String columnPrefix;</span><br><span class="line">    <span class="comment">/** 记录处理后的标志 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultFlag&gt; flags;</span><br><span class="line">    <span class="comment">/** 记录标签 column 拆分后生成的结果 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultMapping&gt; composites;</span><br><span class="line">    <span class="comment">/** 对应标签 resultSet 属性 */</span></span><br><span class="line">    <span class="keyword">private</span> String resultSet;</span><br><span class="line">    <span class="comment">/** 对应标签 foreignColumn 属性 */</span></span><br><span class="line">    <span class="keyword">private</span> String foreignColumn;</span><br><span class="line">    <span class="comment">/** 对应标签 fetchType 属性，配置是否延迟加载 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lazy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略构造器类定义，以及 getter 和 setter 方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>ResultMapping 类中定义的属性如上述代码注释。此外，还内置了一个 Builder 内部构造器类，用于封装数据构造 ResultMapping 对象，并实现了对属性值的基本校验逻辑。</p>
<ul>
<li><strong>ResultMap</strong></li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultMap</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 对应标签的 id 属性 */</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">/** 对应标签的 type 属性 */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line">    <span class="comment">/** 记录除 &lt;discriminator/&gt; 标签以外的其它映射关系 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultMapping&gt; resultMappings;</span><br><span class="line">    <span class="comment">/** 记录带有 id 属性的映射关系 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultMapping&gt; idResultMappings;</span><br><span class="line">    <span class="comment">/** 记录带有 constructor 属性的映射关系 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultMapping&gt; constructorResultMappings;</span><br><span class="line">    <span class="comment">/** 记录带有 property 属性的映射关系 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultMapping&gt; propertyResultMappings;</span><br><span class="line">    <span class="comment">/** 记录配置中所有的 column 属性集合 */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; mappedColumns;</span><br><span class="line">    <span class="comment">/** 记录配置中所有的 property 属性集合 */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; mappedProperties;</span><br><span class="line">    <span class="comment">/** 封装 &lt;discriminator/&gt; 标签 */</span></span><br><span class="line">    <span class="keyword">private</span> Discriminator discriminator;</span><br><span class="line">    <span class="comment">/** 是否包含嵌套的结果映射 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line">    <span class="comment">/** 是否包含嵌套查询 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedQueries;</span><br><span class="line">    <span class="comment">/** 是否开启自动映射 */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean autoMapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略构造器类，以及 getter 和 setter 方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>ResultMap 类中定义的属性如上述代码注释。与 ResultMapping 一样，也是通过内置 Builder 内部构造器类来构造 ResultMap 对象，构造器的实现比较简单，读者可以参考源码实现。</p>
<p>了解了内部数据结构 ResultMapping 和 ResultMap 的定义，以及二者之间的相互依赖关系，接下来开始分析 <code>&lt;resultMap/&gt;</code> 标签的解析过程，实现位于 <code>XMLMapperBuilder#resultMapElements</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultMap <span class="title">resultMapElement</span><span class="params">(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings, Class&lt;?&gt; enclosingType)</span> </span>{</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"processing "</span> + resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    <span class="comment">// 获取 type 属性，支持 type、ofType、resultType，以及 javaType 类型配置</span></span><br><span class="line">    String type = resultMapNode.getStringAttribute(<span class="string">"type"</span>,</span><br><span class="line">        resultMapNode.getStringAttribute(<span class="string">"ofType"</span>,</span><br><span class="line">            resultMapNode.getStringAttribute(<span class="string">"resultType"</span>,</span><br><span class="line">                resultMapNode.getStringAttribute(<span class="string">"javaType"</span>))));</span><br><span class="line">    <span class="comment">// 基于 TypeAliasRegistry 解析 type 属性对应的实体类型</span></span><br><span class="line">    Class&lt;?&gt; typeClass = <span class="keyword">this</span>.resolveClass(type);</span><br><span class="line">    <span class="keyword">if</span> (typeClass == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 尝试基于 &lt;association/&gt; 子标签或 &lt;case/&gt; 子标签解析实体类型</span></span><br><span class="line">        typeClass = <span class="keyword">this</span>.inheritEnclosingType(resultMapNode, enclosingType);</span><br><span class="line">    }</span><br><span class="line">    Discriminator discriminator = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 用于记录解析结果</span></span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(additionalResultMappings);</span><br><span class="line">    <span class="comment">// 获取并遍历处理所有的子标签</span></span><br><span class="line">    List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();</span><br><span class="line">    <span class="keyword">for</span> (XNode resultChild : resultChildren) {</span><br><span class="line">        <span class="comment">// 解析 &lt;constructor/&gt; 子标签，封装成为 ResultMapping 对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"constructor"</span>.equals(resultChild.getName())) {</span><br><span class="line">            <span class="keyword">this</span>.processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 解析 &lt;discriminator/&gt; 子标签，封装成为 Discriminator 对象</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"discriminator"</span>.equals(resultChild.getName())) {</span><br><span class="line">            discriminator = <span class="keyword">this</span>.processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 解析 &lt;association/&gt;、&lt;collection/&gt;、&lt;id/&gt; 和 &lt;result/&gt; 子标签，封装成为 ResultMapping 对象</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            List&lt;ResultFlag&gt; flags = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"id"</span>.equals(resultChild.getName())) {</span><br><span class="line">                flags.add(ResultFlag.ID);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 创建 ResultMapping 对象，并记录到 resultMappings 集合中</span></span><br><span class="line">            resultMappings.add(<span class="keyword">this</span>.buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取 id 属性（标识当前 &lt;resultMap/&gt; 标签），如果没有指定则基于规则生成一个</span></span><br><span class="line">    String id = resultMapNode.getStringAttribute(<span class="string">"id"</span>, resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    <span class="comment">// 获取 extends 属性，用于指定继承关系</span></span><br><span class="line">    String extend = resultMapNode.getStringAttribute(<span class="string">"extends"</span>);</span><br><span class="line">    <span class="comment">// 获取 autoMapping 属性，是否启用自动映射（自动查找与列名相同的属性名称，并执行注入）</span></span><br><span class="line">    Boolean autoMapping = resultMapNode.getBooleanAttribute(<span class="string">"autoMapping"</span>);</span><br><span class="line">    ResultMapResolver resultMapResolver = <span class="keyword">new</span> ResultMapResolver(</span><br><span class="line">        builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 基于解析得到的配置构造 ResultMap 对象，记录到 Configuration#resultMaps 中</span></span><br><span class="line">        <span class="keyword">return</span> resultMapResolver.resolve();</span><br><span class="line">    } <span class="keyword">catch</span> (IncompleteElementException e) {</span><br><span class="line">        <span class="comment">// 记录解析异常的 &lt;resultMap/&gt; 标签，后续尝试二次解析</span></span><br><span class="line">        configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>标签 <code>&lt;resultMap/&gt;</code> 包含 4 个属性配置，即 id、type、extends 和 autoMapping。</p>
<ul>
<li><strong>id</strong> ：标识当前 <code>&lt;resultMap/&gt;</code> 标签，如果没有指定则会调用 <code>XNode#getValueBasedIdentifier</code> 方法基于规则自动生成一个，用于提升 MyBatis 的执行性能。</li>
<li><strong>type</strong> ：设置当前标签所关联的实体类对象，支持 type、ofType、resultType，以及 javaType 等配置方式，以尽可能用简单的配置支持更多的实体类型。</li>
<li><strong>extends</strong> ：指定当前标签的继承关系。</li>
<li><strong>autoMapping</strong> ：一个 boolean 类型的配置项，如果为 true 则表示开启自动映射功能，MyBatis 会自动查找实例类对象中与结果集列名相同的属性名，并调用 setter 方法执行注入。标签 <code>&lt;resultMap/&gt;</code> 中明确指定的映射关系优先级要高于自动映射。</li>
</ul>
<p>标签 <code>&lt;resultMap/&gt;</code> 包含 <code>&lt;constructor/&gt;</code>、<code>&lt;id/&gt;</code>、<code>&lt;result/&gt;</code>、<code>&lt;association/&gt;</code>、<code>&lt;collection/&gt;</code>，以及 <code>&lt;discriminator/&gt;</code> 六个子标签。关于这些子标签的作用可以参阅 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#Result_Maps">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，除 <code>&lt;discriminator/&gt;</code> 以外，其余五个标签的解析实现大同小异，下面以 <code>&lt;constructor/&gt;</code> 标签为例对解析实现展开分析。</p>
<p>子标签 <code>&lt;constructor/&gt;</code> 的解析由 <code>XMLMapperBuilder#processConstructorElement</code> 方法实现，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processConstructorElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    XNode resultChild, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取并处理 &lt;constructor/&gt; 标签中配置的子标签列表</span></span><br><span class="line">    List&lt;XNode&gt; argChildren = resultChild.getChildren();</span><br><span class="line">    <span class="keyword">for</span> (XNode argChild : argChildren) {</span><br><span class="line">        List&lt;ResultFlag&gt; flags = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        flags.add(ResultFlag.CONSTRUCTOR);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"idArg"</span>.equals(argChild.getName())) {</span><br><span class="line">            flags.add(ResultFlag.ID); <span class="comment">// 添加 ID 标识</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 封装标签配置为 ResultMapping 对象，记录到 resultMappings 集合中</span></span><br><span class="line">        resultMappings.add(<span class="keyword">this</span>.buildResultMappingFromContext(argChild, resultType, flags));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>子标签 <code>&lt;constructor/&gt;</code> 用于指定实体类的构造方法以实现在构造实体类对象时注入结果值。上述方法直接遍历处理该标签的所有子标签，即 <code>&lt;idArg/&gt;</code> 和 <code>&lt;arg/&gt;</code>，并调用 <code>XMLMapperBuilder#buildResultMappingFromContext</code> 方法创建对应的 ResultMapping 对象，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultMapping <span class="title">buildResultMappingFromContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取对应的属性配置</span></span><br><span class="line">    String property;</span><br><span class="line">    <span class="keyword">if</span> (flags.contains(ResultFlag.CONSTRUCTOR)) {</span><br><span class="line">        property = context.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        property = context.getStringAttribute(<span class="string">"property"</span>);</span><br><span class="line">    }</span><br><span class="line">    String column = context.getStringAttribute(<span class="string">"column"</span>);</span><br><span class="line">    String javaType = context.getStringAttribute(<span class="string">"javaType"</span>);</span><br><span class="line">    String jdbcType = context.getStringAttribute(<span class="string">"jdbcType"</span>);</span><br><span class="line">    String nestedSelect = context.getStringAttribute(<span class="string">"select"</span>);</span><br><span class="line">    <span class="comment">// 存在嵌套配置，嵌套解析</span></span><br><span class="line">    String nestedResultMap = context.getStringAttribute(<span class="string">"resultMap"</span>, () -&gt;</span><br><span class="line">        <span class="keyword">this</span>.processNestedResultMappings(context, Collections.emptyList(), resultType));</span><br><span class="line">    String notNullColumn = context.getStringAttribute(<span class="string">"notNullColumn"</span>);</span><br><span class="line">    String columnPrefix = context.getStringAttribute(<span class="string">"columnPrefix"</span>);</span><br><span class="line">    String typeHandler = context.getStringAttribute(<span class="string">"typeHandler"</span>);</span><br><span class="line">    String resultSet = context.getStringAttribute(<span class="string">"resultSet"</span>);</span><br><span class="line">    String foreignColumn = context.getStringAttribute(<span class="string">"foreignColumn"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> lazy = <span class="string">"lazy"</span>.equals(context.getStringAttribute(<span class="string">"fetchType"</span>, configuration.isLazyLoadingEnabled() ? <span class="string">"lazy"</span> : <span class="string">"eager"</span>));</span><br><span class="line">    <span class="comment">// 基于 TypeAliasRegistry 解析 JavaType 对应的 Class 对象</span></span><br><span class="line">    Class&lt;?&gt; javaTypeClass = <span class="keyword">this</span>.resolveClass(javaType);</span><br><span class="line">    <span class="comment">// 基于 TypeAliasRegistry 解析 TypeHandler 对应的 Class 对象</span></span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = <span class="keyword">this</span>.resolveClass(typeHandler);</span><br><span class="line">    <span class="comment">// 获取 JdbcType 对应的具体枚举对象</span></span><br><span class="line">    JdbcType jdbcTypeEnum = <span class="keyword">this</span>.resolveJdbcType(jdbcType);</span><br><span class="line">    <span class="comment">// 封装成 ResultMapping 对象</span></span><br><span class="line">    <span class="keyword">return</span> builderAssistant.buildResultMapping(</span><br><span class="line">        resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap,</span><br><span class="line">        notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先会获取标签所有的属性配置项，并基于 TypeAliasRegistry 对属性所表示的类型进行解析，最后调用 <code>MapperBuilderAssistant#buildResultMapping</code> 方法构造封装配置项对应的 ResultMapping 对象，这里本质上还是调用 ResultMapping 的构造器进行构造。其中，方法 <code>XMLMapperBuilder#buildResultMappingFromContext</code> 是一个通用方法，除了上面用于封装 <code>&lt;constructor/&gt;</code> 子标签，对于标签 <code>&lt;id/&gt;</code>、<code>&lt;result/&gt;</code>、<code>&lt;association/&gt;</code> 和 <code>&lt;collection/&gt;</code> 来说也都是直接调用该方法进行解析。</p>
<p>继续来看一下 <code>&lt;discriminator/&gt;</code> 标签，该标签并没有直接采用 ResultMapping 类进行封装，而是采用 Discriminator 类对 ResultMapping 进行封装，这主要取决于该标签的用途。MyBatis 使用该标签基于具体的结果值选择不同的结果集映射，解析实现位于 <code>XMLMapperBuilder#processDiscriminatorElement</code> 方法中，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Discriminator <span class="title">processDiscriminatorElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    XNode context, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取相关属性配置</span></span><br><span class="line">    String column = context.getStringAttribute(<span class="string">"column"</span>);</span><br><span class="line">    String javaType = context.getStringAttribute(<span class="string">"javaType"</span>);</span><br><span class="line">    String jdbcType = context.getStringAttribute(<span class="string">"jdbcType"</span>);</span><br><span class="line">    String typeHandler = context.getStringAttribute(<span class="string">"typeHandler"</span>);</span><br><span class="line">    <span class="comment">// 基于 TypeAliasRegistry 解析类型属性对应的 Class 对象</span></span><br><span class="line">    Class&lt;?&gt; javaTypeClass = <span class="keyword">this</span>.resolveClass(javaType);</span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = <span class="keyword">this</span>.resolveClass(typeHandler);</span><br><span class="line">    JdbcType jdbcTypeEnum = <span class="keyword">this</span>.resolveJdbcType(jdbcType);</span><br><span class="line">    <span class="comment">// 遍历处理子标签列表</span></span><br><span class="line">    Map&lt;String, String&gt; discriminatorMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (XNode caseChild : context.getChildren()) {</span><br><span class="line">        String value = caseChild.getStringAttribute(<span class="string">"value"</span>);</span><br><span class="line">        String resultMap = caseChild.getStringAttribute(<span class="string">"resultMap"</span>,</span><br><span class="line">            <span class="comment">// 嵌套解析</span></span><br><span class="line">            <span class="keyword">this</span>.processNestedResultMappings(caseChild, resultMappings, resultType));</span><br><span class="line">        discriminatorMap.put(value, resultMap);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 封装成 Discriminator 对象，本质上依赖于 Discriminator 的构造器构建</span></span><br><span class="line">    <span class="keyword">return</span> builderAssistant.buildDiscriminator(</span><br><span class="line">        resultType, column, javaTypeClass, jdbcTypeEnum, typeHandlerClass, discriminatorMap);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>可以看到，具体的解析步骤与其它标签如出一辙，参考代码注释。</p>
<p>在将这六类子标签解析成为相应对象并记录到 resultMappings 集合中之后，下一步就是基于这些配置构造 ResultMapResolver 解析器，并调用 <code>ResultMapResolver#resolve</code> 方法解析 <code>&lt;resultMap/&gt;</code> 配置为 ResultMap 对象记录到 <code>Configuration#resultMaps</code> 属性中。</p>
<p>方法 <code>ResultMapResolver#resolve</code> 直接将请求委托给了 <code>MapperBuilderAssistant#addResultMap</code> 方法执行，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">resolve</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> assistant.addResultMap(</span><br><span class="line">        <span class="keyword">this</span>.id, <span class="keyword">this</span>.type, <span class="keyword">this</span>.extend, <span class="keyword">this</span>.discriminator, <span class="keyword">this</span>.resultMappings, <span class="keyword">this</span>.autoMapping);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.ibatis.builder.MapperBuilderAssistant#addResultMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">addResultMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String id,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">    String extend,</span></span></span><br><span class="line"><span class="function"><span class="params">    Discriminator discriminator,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;ResultMapping&gt; resultMappings,</span></span></span><br><span class="line"><span class="function"><span class="params">    Boolean autoMapping)</span> </span>{</span><br><span class="line">    <span class="comment">// 格式化 id 值，格式：namespace.id</span></span><br><span class="line">    id = <span class="keyword">this</span>.applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    extend = <span class="keyword">this</span>.applyCurrentNamespace(extend, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 extend 配置</span></span><br><span class="line">    <span class="keyword">if</span> (extend != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 被继承的 ResultMap 不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!configuration.hasResultMap(extend)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">"Could not find a parent resultmap with id '"</span> + extend + <span class="string">"'"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获取需要被继承的 ResultMap 对象</span></span><br><span class="line">        ResultMap resultMap = configuration.getResultMap(extend);</span><br><span class="line">        <span class="comment">// 获取父 ResultMap 对象中包含的 ResultMapping 对象集合</span></span><br><span class="line">        List&lt;ResultMapping&gt; extendedResultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(resultMap.getResultMappings());</span><br><span class="line">        <span class="comment">// 删除被覆盖的 ResultMapping 对象</span></span><br><span class="line">        extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">        <span class="comment">// Remove parent constructor if this resultMap declares a constructor.</span></span><br><span class="line">        <span class="keyword">boolean</span> declaresConstructor = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 查找当前 &lt;resultMap/&gt; 标签中是否定义了 &lt;constructor/&gt; 子标签</span></span><br><span class="line">        <span class="keyword">for</span> (ResultMapping resultMapping : resultMappings) {</span><br><span class="line">            <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) {</span><br><span class="line">                declaresConstructor = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 当前 &lt;resultMap/&gt; 中定义了 &lt;constructor/&gt; 子标签，</span></span><br><span class="line">        <span class="comment">// 则无需父 ResultMap 中记录的相应 &lt;constructor/&gt;，遍历删除</span></span><br><span class="line">        <span class="keyword">if</span> (declaresConstructor) {</span><br><span class="line">            extendedResultMappings.removeIf(</span><br><span class="line">                resultMapping -&gt; resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 添加需要继承的 ResultMapping 对象集合</span></span><br><span class="line">        resultMappings.addAll(extendedResultMappings);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建 ResultMap 对象，并记录到 Configuration#resultMaps 中</span></span><br><span class="line">    ResultMap resultMap = <span class="keyword">new</span> ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)</span><br><span class="line">        .discriminator(discriminator)</span><br><span class="line">        .build();</span><br><span class="line">    configuration.addResultMap(resultMap);</span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>具体过程如代码注释。</p>

        <h4 id="解析-sql-标签">
          <a href="#解析-sql-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 sql 标签</h4>
      <p>在 MyBatis 中可以通过 <code>&lt;sql/&gt;</code> 标签配置一些可以被复用的 SQL 语句片段，当我们在某个 SQL 语句中需要使用这些片段时，可以通过 <code>&lt;include/&gt;</code> 子标签引入，具体示例可以参考 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#insert_update_and_delete">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。对于 <code>&lt;sql/&gt;</code> 标签的解析由 <code>XMLMapperBuilder#sqlElement</code> 方法实现，最终记录到 <code>Configuration#sqlFragments</code> 集合中，方法实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sqlElement</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历处理所有的 &lt;sql/&gt; 标签</span></span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) {</span><br><span class="line">        <span class="comment">// 获取数据库标识 databaseId 属性</span></span><br><span class="line">        String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line">        <span class="comment">// 获取 id 属性</span></span><br><span class="line">        String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">        <span class="comment">// 格式化 id，格式：namespace.id</span></span><br><span class="line">        id = builderAssistant.applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 判断数据库标识 databaseId 与当前 Configuration 中配置的是否一致：</span></span><br><span class="line"><span class="comment">         * 1. 如果指定了 requiredDatabaseId，则 databaseId 必须和 requiredDatabaseId 一致</span></span><br><span class="line"><span class="comment">         * 2. 如果没有指定了 requiredDatabaseId，则 databaseId 必须为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) {</span><br><span class="line">            sqlFragments.put(id, context);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先会获取 <code>&lt;sql/&gt;</code> 标签的属性配置，即 id 和 databaseId，并对 id 进行格式化处理；然后判断当前 <code>&lt;sql/&gt;</code> 标签配置的数据库标识 databaseId 是否与当前运行的数据库环境相匹配，并忽略不匹配的 <code>&lt;sql/&gt;</code> 标签。参数 requiredDatabaseId 在重载方法中指定，本质上就是从全局配置 Configuration 对象中获取的 <code>Configuration#databaseId</code> 属性值：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sqlElement</span><span class="params">(List&lt;XNode&gt; list)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 获取当前运行环境对应的数据库标识</span></span><br><span class="line">        <span class="keyword">this</span>.sqlElement(list, configuration.getDatabaseId());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.sqlElement(list, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>最终这些解析得到的 <code>&lt;sql/&gt;</code> 标签会被记录到 <code>Configuration#sqlFragments</code> 属性中（在构造 XMLMapperBuilder 对象时进行初始化），后面分析 <code>&lt;include/&gt;</code> 标签时可以看到会从该属性值获取引用的 SQL 语句片段。</p>

        <h4 id="解析-select-insert-update-delete-标签">
          <a href="#解析-select-insert-update-delete-标签" class="heading-link"><i class="fas fa-link"></i></a>解析 select / insert / update / delete 标签</h4>
      <p>标签 <code>&lt;select/&gt;</code>、<code>&lt;insert/&gt;</code>、<code>&lt;update/&gt;</code> 和 <code>&lt;delete/&gt;</code> 用于配置映射文件中最核心的数据库操作语句（下文统称这 4 个标签为 SQL 语句标签），包括静态 SQL 语句和动态 SQL 语句。MyBatis 通过 MappedStatement 类封装这些 SQL 语句标签的配置，并调用 <code>XMLStatementBuilder#parseStatementNode</code> 方法对标签进行解析，构建 MappedStatement 对象并记录到 <code>Configuration#mappedStatements</code> 属性中。</p>
<p>方法 <code>XMLMapperBuilder#buildStatementFromContext</code> 对于标签的解析主要做了一些统筹调度的工作，具体解析还是交由 XMLStatementBuilder 类进行处理，该方法的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.buildStatementFromContext(list, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历处理获取到的所有 SQL 语句标签</span></span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) {</span><br><span class="line">        <span class="comment">// 创建 XMLStatementBuilder 解析器，负责解析具体的 SQL 语句标签</span></span><br><span class="line">        <span class="keyword">final</span> XMLStatementBuilder statementParser =</span><br><span class="line">            <span class="keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 执行解析操作</span></span><br><span class="line">            statementParser.parseStatementNode();</span><br><span class="line">        } <span class="keyword">catch</span> (IncompleteElementException e) {</span><br><span class="line">            <span class="comment">// 记录解析异常的 SQL 语句标签，稍后尝试二次解析</span></span><br><span class="line">            configuration.addIncompleteStatement(statementParser);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现比较简单，无非是遍历获取到的所有 SQL 语句标签列表，然后构建 XMLStatementBuilder 解析器并调用 <code>XMLStatementBuilder#parseStatementNode</code> 方法对各个 SQL 语句标签进解析。对于解析异常的标签则会记录到 <code>Configuration#incompleteStatements</code> 属性中，稍后会再次尝试解析。</p>
<p>下面分析一下 <code>XMLStatementBuilder#parseStatementNode</code> 方法的具体实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 id 和 databaseId 属性</span></span><br><span class="line">    String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前 SQL 语句是否适配当前数据库类型，忽略不适配的 SQL 语句</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取并解析属性配置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 SQL 语句类型</span></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="comment">// 标识是否是 SELECT 语句</span></span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="comment">// 标识任何时候只要语句被调用，都会导致本地缓存和二级缓存被清空，适用于修改数据操作</span></span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">"flushCache"</span>, !isSelect);</span><br><span class="line">    <span class="comment">// 设置本条语句的结果是否被二级缓存，默认适用于 SELECT 语句</span></span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">"useCache"</span>, isSelect);</span><br><span class="line">    <span class="comment">// 仅针对嵌套结果 SELECT 语句适用</span></span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">"resultOrdered"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 &lt;include/&gt; 子标签</span></span><br><span class="line">    XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析传入参数类型的完全限定名或别名</span></span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">"parameterType"</span>);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = <span class="keyword">this</span>.resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">"lang"</span>);</span><br><span class="line">    LanguageDriver langDriver = <span class="keyword">this</span>.getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 &lt;selectKey/&gt; 子标签</span></span><br><span class="line">    <span class="keyword">this</span>.processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析对应的 KeyGenerator 实现，用于生成填充 keyProperty 属性指定的列值</span></span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 当前 SQL 语句标签下存在 &lt;selectKey/&gt; 配置，直接获取对应的 SelectKeyGenerator</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) {</span><br><span class="line">        keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 当前 SQL 语句标签下不存在 &lt;selectKey/&gt; 配置</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 依据当前标签的 useGeneratedKeys 配置，或全局的 useGeneratedKeys 配置，以及是否是 INSERT 方法来决定具体的 keyGenerator 实现</span></span><br><span class="line">        <span class="comment">// 属性 useGeneratedKeys 仅对 INSERT 和 UPDATE 有用，使用 JDBC 的 getGeneratedKeys 方法取出由数据库内部生成的主键</span></span><br><span class="line">        keyGenerator = context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">            configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">            ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 SQL 语句标签对应的 SqlSource 对象</span></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    <span class="comment">// 获取具体的 Statement 类型，默认使用 PreparedStatement</span></span><br><span class="line">    StatementType statementType = StatementType.valueOf(</span><br><span class="line">        context.getStringAttribute(<span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    <span class="comment">// 设置批量返回的结果行数，默认值为 unset（依赖驱动）</span></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">"fetchSize"</span>);</span><br><span class="line">    <span class="comment">// 数据库执行超时时间（单位：秒），默认值为 unset（依赖驱动）</span></span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">"timeout"</span>);</span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">"parameterMap"</span>); <span class="comment">// 已废弃</span></span><br><span class="line">    <span class="comment">// 期望返回类型完全限定名或别名，对于集合类型应该是集合元素类型，而非集合类型本身</span></span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = <span class="keyword">this</span>.resolveClass(resultType);</span><br><span class="line">    <span class="comment">// 引用的 &lt;resultMap/&gt; 的标签 ID</span></span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">"resultMap"</span>);</span><br><span class="line">    <span class="comment">// FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）</span></span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">"resultSetType"</span>);</span><br><span class="line">    ResultSetType resultSetTypeEnum = <span class="keyword">this</span>.resolveResultSetType(resultSetType);</span><br><span class="line">    <span class="keyword">if</span> (resultSetTypeEnum == <span class="keyword">null</span>) {</span><br><span class="line">        resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// （仅对 INSERT 和 UPDATE 有用）唯一标记一个属性，通过 getGeneratedKeys 的返回值或者通过 INSERT 语句的 selectKey 子标签设置它的键值</span></span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">    <span class="comment">// （仅对 INSERT 和 UPDATE 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（如 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置</span></span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">    <span class="comment">// 仅对多结果集适用，将列出语句执行后返回的结果集并给每个结果集一个名称，名称采用逗号分隔</span></span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">"resultSets"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建当前 SQL 语句配置对应的 MappedStatement 对象，并记录到 Configuration#mappedStatements 中</span></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>解析 SQL 语句标签的过程如上述代码注释，配合官方文档对于各个属性和子标签作用的解释应该不难理解，关于子标签 <code>&lt;include/&gt;</code> 和 <code>&lt;selectKey/&gt;</code> 的解析实现稍后会详细说明。</p>
<p>MyBatis 使用 MappedStatement 对象封装 SQL 语句标签配置，并记录到 <code>Configuration#mappedStatements</code> 属性中，在这个过程中会调用 <code>LanguageDriver#createSqlSource</code> 方法创建 SQL 语句标签对应的 SqlSource 对象。SqlSource 类用于封装 SQL 语句标签（或 Mapper 接口方法注解）中配置的 SQL 语句，但是这里的 SQL 语句暂时还不能被数据库执行，因为其中可能包含占位符。关于 SqlSource 类暂时先了解其作用即可，稍后会对其实现做详细介绍，下面先来看一下 <code>LanguageDriver#createSqlSource</code> 方法的实现，具体实现类为 XMLLanguageDriver：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> </span>{</span><br><span class="line">    XMLScriptBuilder builder = <span class="keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">    <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#parseScriptNode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 判断是否是动态 SQL，解析封装为 MixedSqlNode 对象</span></span><br><span class="line">    MixedSqlNode rootSqlNode = <span class="keyword">this</span>.parseDynamicTags(context);</span><br><span class="line">    SqlSource sqlSource;</span><br><span class="line">    <span class="comment">// 动态 SQL，封装为 DynamicSqlSource 对象</span></span><br><span class="line">    <span class="keyword">if</span> (isDynamic) {</span><br><span class="line">        sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 静态 SQL，封装为 RawSqlSource 对象</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sqlSource;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先会调用 <code>XMLScriptBuilder#parseDynamicTags</code> 方法对当前 SQL 语句标签中的占位符进行解析，并判断是否为动态 SQL，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MixedSqlNode <span class="title">parseDynamicTags</span><span class="params">(XNode node)</span> </span>{</span><br><span class="line">    List&lt;SqlNode&gt; contents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取并处理所有的子标签</span></span><br><span class="line">    NodeList children = node.getNode().getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) {</span><br><span class="line">        <span class="comment">// 构造对应的 XNode 对象，期间会尝试解析所有的 ${} 占位符</span></span><br><span class="line">        XNode child = node.newXNode(children.item(i));</span><br><span class="line">        <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) {</span><br><span class="line">            <span class="comment">// 获取标签的 value 值</span></span><br><span class="line">            String data = child.getStringBody(<span class="string">""</span>);</span><br><span class="line">            TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(data);</span><br><span class="line">            <span class="comment">// 基于是否存在未解析的占位符 ${} 判断是否是动态 SQL</span></span><br><span class="line">            <span class="keyword">if</span> (textSqlNode.isDynamic()) {</span><br><span class="line">                contents.add(textSqlNode);</span><br><span class="line">                <span class="comment">// 标记为动态 SQL</span></span><br><span class="line">                isDynamic = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                contents.add(<span class="keyword">new</span> StaticTextSqlNode(data));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果子标签是 element 类型，则必定是一个动态 SQL</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) { <span class="comment">// issue #628</span></span><br><span class="line">            String nodeName = child.getNode().getNodeName();</span><br><span class="line">            <span class="comment">// 获取 nodeName 对应的 NodeHandler</span></span><br><span class="line">            NodeHandler handler = nodeHandlerMap.get(nodeName);</span><br><span class="line">            <span class="keyword">if</span> (handler == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Unknown element &lt;"</span> + nodeName + <span class="string">"&gt; in SQL statement."</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 基于具体的 NodeHandler 处理动态 SQL</span></span><br><span class="line">            handler.handleNode(child, contents);</span><br><span class="line">            isDynamic = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 封装 SqlNode 集合为 MixedSqlNode 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>整个过程主要是遍历当前 SQL 语句标签的所有子标签，并依据当前子标签的类型分而治之，可以配合官方文档的 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">动态 SQL 配置示例</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 进行理解。如果当前子标签是一个具体的字符串或 CDATA 表达式（即 SQL 语句片段），则会获取字面值并依据是否包含未解析的 <code>${}</code> 占位符判断是否是动态 SQL，并封装成对应的 SqlNode 对象。SqlNode 是一个接口，用于封装定义的动态 SQL 节点和文本节点，包含多个实现类，该接口及其具体实现类留到后面针对性介绍。如果当前子标签是一个具体的 XML 标签，则必定是一个动态 SQL 配置，此时会依据标签名称选择对应的 NodeHandler 对节点进行处理。标签与具体 NodeHandler 的映射关系如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#initNodeHandlerMap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initNodeHandlerMap</span><span class="params">()</span> </span>{</span><br><span class="line">    nodeHandlerMap.put(<span class="string">"trim"</span>, <span class="keyword">new</span> TrimHandler());</span><br><span class="line">    nodeHandlerMap.put(<span class="string">"where"</span>, <span class="keyword">new</span> WhereHandler());</span><br><span class="line">    nodeHandlerMap.put(<span class="string">"set"</span>, <span class="keyword">new</span> SetHandler());</span><br><span class="line">    nodeHandlerMap.put(<span class="string">"foreach"</span>, <span class="keyword">new</span> ForEachHandler());</span><br><span class="line">    nodeHandlerMap.put(<span class="string">"if"</span>, <span class="keyword">new</span> IfHandler());</span><br><span class="line">    nodeHandlerMap.put(<span class="string">"choose"</span>, <span class="keyword">new</span> ChooseHandler());</span><br><span class="line">    nodeHandlerMap.put(<span class="string">"when"</span>, <span class="keyword">new</span> IfHandler());</span><br><span class="line">    nodeHandlerMap.put(<span class="string">"otherwise"</span>, <span class="keyword">new</span> OtherwiseHandler());</span><br><span class="line">    nodeHandlerMap.put(<span class="string">"bind"</span>, <span class="keyword">new</span> BindHandler());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>下面以 ForEachHandler 为例进行说明，其余 NodeHandler 实现与之类似。ForEachHandler 类对应动态 SQL 中的 <code>&lt;foreach/&gt;</code> 标签，这是一个我十分喜欢的标签，可以很方便的动态构造较长的条件语句。NodeHandler 中仅声明了 <code>NodeHandler#handleNode</code> 这一个方法，ForEachHandler 针对该方法的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> </span>{</span><br><span class="line">    <span class="comment">// 解析 &lt;foreach/&gt; 的子标签</span></span><br><span class="line">    MixedSqlNode mixedSqlNode = XMLScriptBuilder.<span class="keyword">this</span>.parseDynamicTags(nodeToHandle);</span><br><span class="line">    <span class="comment">// 获取属性配置</span></span><br><span class="line">    String collection = nodeToHandle.getStringAttribute(<span class="string">"collection"</span>);</span><br><span class="line">    String item = nodeToHandle.getStringAttribute(<span class="string">"item"</span>);</span><br><span class="line">    String index = nodeToHandle.getStringAttribute(<span class="string">"index"</span>);</span><br><span class="line">    String open = nodeToHandle.getStringAttribute(<span class="string">"open"</span>);</span><br><span class="line">    String close = nodeToHandle.getStringAttribute(<span class="string">"close"</span>);</span><br><span class="line">    String separator = nodeToHandle.getStringAttribute(<span class="string">"separator"</span>);</span><br><span class="line">    <span class="comment">// 封装为 ForEachSqlNode 对象</span></span><br><span class="line">    ForEachSqlNode forEachSqlNode = <span class="keyword">new</span> ForEachSqlNode(</span><br><span class="line">        configuration, mixedSqlNode, collection, index, item, open, close, separator);</span><br><span class="line">    targetContents.add(forEachSqlNode);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法首先会调用前面介绍的 <code>XMLScriptBuilder#parseDynamicTags</code> 方法对占位符进行嵌套解析，然后获取标签相关属性配置，并构造 ForEachSqlNode 对象。ForEachSqlNode 类在后面介绍 SqlNode 类时会进行介绍，这里先不展开。</p>
<p>介绍完了 <code>XMLScriptBuilder#parseDynamicTags</code> 方法，我们继续回到该方法调用的地方，即 <code>XMLScriptBuilder#parseScriptNode</code> 方法。接下来，MyBatis 会依据 <code>XMLScriptBuilder#parseDynamicTags</code> 方法的解析和判定结果分别创建对应的 SqlSource 对象。如果是动态 SQL，则采用 DynamicSqlSource 进行封装，否则采用 RawSqlSource 进行封装。</p>
<p>至此，我们在映射文件或注解中定义的 SQL 语句就被解析封装成对应的 SqlSource 对象驻于内存之中。接下来，MyBatis 会依据配置创建对应的 KeyGenerator 对象，这个留到后面解析 <code>&lt;selectKey/&gt;</code> 子标签时再进行说明。最后，MyBatis 会将 SQL 语句标签封装成 MappedStatement 对象，记录到 <code>Configuration#mappedStatements</code> 属性中。</p>

        <h5 id="解析-include-子标签">
          <a href="#解析-include-子标签" class="heading-link"><i class="fas fa-link"></i></a>解析 include 子标签</h5>
      <p>MyBatis 在解析 SQL 语句标签时会包含对 <code>&lt;include/&gt;</code> 子标签的解析。前面我们曾分析了 <code>&lt;sql/&gt;</code> 标签，该标签用于配置可复用的 SQL 语句片段，而 <code>&lt;include/&gt;</code> 标签则是用来引用已定义的 <code>&lt;sql/&gt;</code> 标签配置。对于 <code>&lt;include/&gt;</code> 子标签的解析由 <code>XMLIncludeTransformer#applyIncludes</code> 方法实现，该方法首先会尝试获取记录在 Configuration 配置对象中记录的 <code>&lt;properties/&gt;</code> 等属性变量，然后调用重载的 <code>XMLIncludeTransformer#applyIncludes</code> 方法进行解析，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyIncludes</span><span class="params">(Node source)</span> </span>{</span><br><span class="line">    Properties variablesContext = <span class="keyword">new</span> Properties();</span><br><span class="line">    Properties configurationVariables = configuration.getVariables();</span><br><span class="line">    Optional.ofNullable(configurationVariables).ifPresent(variablesContext::putAll);</span><br><span class="line">    <span class="keyword">this</span>.applyIncludes(source, variablesContext, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyIncludes</span><span class="params">(Node source, <span class="keyword">final</span> Properties variablesContext, <span class="keyword">boolean</span> included)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意：最开始进入本方法时，source 参数对应的标签并不是 &lt;include/&gt;，而是 &lt;select/&gt; 这类标签 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 &lt;include/&gt; 标签</span></span><br><span class="line">    <span class="keyword">if</span> (source.getNodeName().equals(<span class="string">"include"</span>)) {</span><br><span class="line">        <span class="comment">// 获取 refid 指向的 &lt;sql/&gt; 标签对象的深拷贝</span></span><br><span class="line">        Node toInclude = <span class="keyword">this</span>.findSqlFragment(<span class="keyword">this</span>.getStringAttribute(source, <span class="string">"refid"</span>), variablesContext);</span><br><span class="line">        <span class="comment">// 获取 &lt;include/&gt; 标签下的 &lt;property/&gt; 子标签列表，与 variablesContext 合并返回新的 Properties 对象</span></span><br><span class="line">        Properties toIncludeContext = <span class="keyword">this</span>.getVariablesContext(source, variablesContext);</span><br><span class="line">        <span class="comment">// 递归处理，这里的 included 参数为 true</span></span><br><span class="line">        <span class="keyword">this</span>.applyIncludes(toInclude, toIncludeContext, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (toInclude.getOwnerDocument() != source.getOwnerDocument()) {</span><br><span class="line">            toInclude = source.getOwnerDocument().importNode(toInclude, <span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 替换 &lt;include/&gt; 标签为 &lt;sql/&gt; 标签</span></span><br><span class="line">        source.getParentNode().replaceChild(toInclude, source);</span><br><span class="line">        <span class="keyword">while</span> (toInclude.hasChildNodes()) {</span><br><span class="line">            <span class="comment">// 将 &lt;sql/&gt; 的子标签添加到 &lt;sql/&gt; 标签的前面</span></span><br><span class="line">            toInclude.getParentNode().insertBefore(toInclude.getFirstChild(), toInclude);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 删除 &lt;sql/&gt; 标签</span></span><br><span class="line">        toInclude.getParentNode().removeChild(toInclude);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (source.getNodeType() == Node.ELEMENT_NODE) {</span><br><span class="line">        <span class="keyword">if</span> (included &amp;&amp; !variablesContext.isEmpty()) {</span><br><span class="line">            <span class="comment">// 解析 ${} 占位符</span></span><br><span class="line">            NamedNodeMap attributes = source.getAttributes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) {</span><br><span class="line">                Node attr = attributes.item(i);</span><br><span class="line">                attr.setNodeValue(PropertyParser.parse(attr.getNodeValue(), variablesContext));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 遍历处理当前 SQL 语句标签的子标签</span></span><br><span class="line">        NodeList children = source.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) {</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            <span class="keyword">this</span>.applyIncludes(children.item(i), variablesContext, included);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (included</span><br><span class="line">        &amp;&amp; (source.getNodeType() == Node.TEXT_NODE || source.getNodeType() == Node.CDATA_SECTION_NODE)</span><br><span class="line">        &amp;&amp; !variablesContext.isEmpty()) {</span><br><span class="line">        <span class="comment">// 替换占位符为 variablesContext 中对应的配置值，这里替换的是引用 &lt;sql/&gt; 标签中定义的语句片段中对应的占位符</span></span><br><span class="line">        source.setNodeValue(PropertyParser.parse(source.getNodeValue(), variablesContext));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>第一次进入上述方法时，参数 source 对应的并不是一个 <code>&lt;include/&gt;</code> 标签，由参数可以推导出它是一个具体的 SQL 语句标签（即 <code>Node.ELEMENT_NODE</code>），所以方法一开始会进入中间的 <code>else if</code> 代码块（注意，最开始调用 <code>XMLIncludeTransformer#applyIncludes</code> 方法时传递的 included 参数为 false，所以对于 SQL 语句标签下面的 <code>Node.TEXT_NODE</code> 类型字面值是不会进入最后一个 <code>else if</code> 代码块的）。在这里会获取 SQL 语句标签的所有子标签，并递归调用 <code>XMLIncludeTransformer#applyIncludes</code> 方法进行处理，只有当存在 <code>&lt;include/&gt;</code> 标签时才会继续执行下面的逻辑。如果当前是 <code>&lt;include/&gt;</code> 标签，则会尝试获取 refid 属性，并对属性值中的占位符进行解析替换，然后从 <code>Configuration#sqlFragments</code> 属性中获取 id 对应的 <code>&lt;sql/&gt;</code> 标签节点的深拷贝对象。相关实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findSqlFragment</span><span class="params">(String refid, Properties variables)</span> </span>{</span><br><span class="line">    <span class="comment">// 解析带有 ${} 占位符的字符串，将其中的占位符变量替换成 variables 中对应的属性值</span></span><br><span class="line">    refid = PropertyParser.parse(refid, variables);  <span class="comment">// 注意：这里替换的并不是 &lt;sql/&gt; 语句片段中的占位符</span></span><br><span class="line">    refid = builderAssistant.applyCurrentNamespace(refid, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 从 Configuration#sqlFragments 中获取 id 对应的 &lt;sql/&gt; 标签</span></span><br><span class="line">        XNode nodeToInclude = configuration.getSqlFragments().get(refid);</span><br><span class="line">        <span class="comment">// 返回节点的深拷贝对象</span></span><br><span class="line">        <span class="keyword">return</span> nodeToInclude.getNode().cloneNode(<span class="keyword">true</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalArgumentException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">"Could not find SQL statement to include with refid '"</span> + refid + <span class="string">"'"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>接下来会尝试获取 <code>&lt;include/&gt;</code> 标签下的 <code>&lt;property/&gt;</code> 子标签列表，并与入参的 variablesContext 对象合并成为新的 Properties 对象。然后，递归调用 <code>XMLIncludeTransformer#applyIncludes</code> 方法，此时第三个参数 included 为 true，意味着会进入最后一个 <code>else if</code> 代码块。此时会依据之前解析得到的属性值替换引入的 SQL 语句片段中的占位符，最终将对应的 <code>&lt;include/&gt;</code> 标签替换成对应解析后的 <code>&lt;sql/&gt;</code> 标签，记录到当前所隶属的 SQL 语句标签中。</p>

        <h5 id="解析-selectKey-子标签">
          <a href="#解析-selectKey-子标签" class="heading-link"><i class="fas fa-link"></i></a>解析 selectKey 子标签</h5>
      <p>标签 <code>&lt;selectKey/&gt;</code> 用于为不支持自动生成自增主键的数据库或驱动提供主键生成支持，以及获取插入操作返回的主键值。该标签的解析位于 <code>XMLStatementBuilder#processSelectKeyNodes</code> 方法中，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectKeyNodes</span><span class="params">(String id, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取所有的 &lt;selectKey/&gt; 标签</span></span><br><span class="line">    List&lt;XNode&gt; selectKeyNodes = context.evalNodes(<span class="string">"selectKey"</span>);</span><br><span class="line">    <span class="comment">// 解析 &lt;selectKey/&gt; 标签</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 移除 &lt;selectKey/&gt; 标签</span></span><br><span class="line">    <span class="keyword">this</span>.removeSelectKeyNodes(selectKeyNodes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSelectKeyNodes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String parentId, List&lt;XNode&gt; list, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver, String skRequiredDatabaseId)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历处理所有的 &lt;selectKey/&gt; 标签</span></span><br><span class="line">    <span class="keyword">for</span> (XNode nodeToHandle : list) {</span><br><span class="line">        String id = parentId + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">        String databaseId = nodeToHandle.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line">        <span class="comment">// 验证数据库类型是否匹配，忽略不匹配的 &lt;selectKey/&gt; 标签</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.databaseIdMatchesCurrent(id, databaseId, skRequiredDatabaseId)) {</span><br><span class="line">            <span class="keyword">this</span>.parseSelectKeyNode(id, nodeToHandle, parameterTypeClass, langDriver, databaseId);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法执行过程如代码注释，核心步骤位于 <code>XMLStatementBuilder#parseSelectKeyNode</code> 方法中。该方法首先会获取 <code>&lt;selectKey/&gt;</code> 相应的属性配置，然后封装定义的 SQL 语句为 SqlSource 对象，最后将整个 <code>&lt;selectKey/&gt;</code> 配置封装成为 MappedStatement 对象记录到 <code>Configuration#mappedStatements</code> 属性中，同时创建对应的 KeyGenerator 对象，记录到 <code>Configuration#keyGenerators</code> 属性中。方法 <code>XMLStatementBuilder#parseSelectKeyNode</code> 实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSelectKeyNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String id, XNode nodeToHandle, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver, String databaseId)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取相应属性配置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析结果类型配置</span></span><br><span class="line">    String resultType = nodeToHandle.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = <span class="keyword">this</span>.resolveClass(resultType);</span><br><span class="line">    <span class="comment">// 解析 statementType 配置，默认使用 PreparedStatement</span></span><br><span class="line">    StatementType statementType = StatementType.valueOf(</span><br><span class="line">        nodeToHandle.getStringAttribute(<span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    <span class="comment">// 标签 &lt;selectKey/&gt; 生成结果应用的目标属性，多个用逗号分隔个</span></span><br><span class="line">    String keyProperty = nodeToHandle.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">    <span class="comment">// 匹配属性的返回结果集中的列名称，多个以逗号分隔</span></span><br><span class="line">    String keyColumn = nodeToHandle.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">    <span class="comment">// 设置在目标语句前还是后执行</span></span><br><span class="line">    <span class="keyword">boolean</span> executeBefore = <span class="string">"BEFORE"</span>.equals(nodeToHandle.getStringAttribute(<span class="string">"order"</span>, <span class="string">"AFTER"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认值</span></span><br><span class="line">    <span class="keyword">boolean</span> useCache = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = <span class="keyword">false</span>;</span><br><span class="line">    KeyGenerator keyGenerator = NoKeyGenerator.INSTANCE;</span><br><span class="line">    Integer fetchSize = <span class="keyword">null</span>;</span><br><span class="line">    Integer timeout = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flushCache = <span class="keyword">false</span>;</span><br><span class="line">    String parameterMap = <span class="keyword">null</span>;</span><br><span class="line">    String resultMap = <span class="keyword">null</span>;</span><br><span class="line">    ResultSetType resultSetTypeEnum = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对应的 SqlSource 对象（用于封装配置的 SQL 语句，此时的 SQL 语句仍不可执行），默认使用的是 XMLLanguageDriver</span></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, nodeToHandle, parameterTypeClass);</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 SQL 对应的 MappedStatement 对象，记录到 Configuration#mappedStatements 属性中</span></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    id = builderAssistant.applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    MappedStatement keyStatement = configuration.getMappedStatement(id, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 创建对应的 KeyGenerator，记录到 Configuration#keyGenerators 属性中</span></span><br><span class="line">    configuration.addKeyGenerator(id, <span class="keyword">new</span> SelectKeyGenerator(keyStatement, executeBefore));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>在前面解析 SQL 语句标签时包含如下代码段，用于决策 KeyGenerator 具体实现。如果当前标签配置了 <code>&lt;selectKey/&gt;</code> 标签则优先从 <code>Configuration#keyGenerators</code> 属性中获取，也就是上面记录到该属性中的 SelectKeyGenerator 对象。对于未配置 <code>&lt;selectKey/&gt;</code> 标签的 SQL 语句标签，则会判断当前标签是否有设置 useGeneratedKeys 属性（即使用 JDBC 的 getGeneratedKeys 方法取出由数据库内部生成的主键），或者判断当前是否有设置全局的 useGeneratedKeys 属性，以及当前是否是 INSERT 数据库操作类型以决策具体的 KeyGenerator 实现。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析对应的 KeyGenerator 实现，用于生成填充 keyProperty 属性指定的列值</span></span><br><span class="line">KeyGenerator keyGenerator;</span><br><span class="line">String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 当前 SQL 语句标签下存在 &lt;selectKey/&gt; 配置，直接获取对应的 SelectKeyGenerator</span></span><br><span class="line"><span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) {</span><br><span class="line">    keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 当前 SQL 语句标签下不存在 &lt;selectKey/&gt; 配置</span></span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 依据当前标签的 useGeneratedKeys 配置，或全局的 useGeneratedKeys 配置，以及是否是 INSERT 方法来决定具体的 keyGenerator 实现</span></span><br><span class="line">    <span class="comment">// 属性 useGeneratedKeys 仅对 INSERT 和 UPDATE 有用，使用 JDBC 的 getGeneratedKeys 方法取出由数据库内部生成的主键</span></span><br><span class="line">    keyGenerator = context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">        configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">        ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于 KeyGenerator 接口来说，包含三种实现类：Jdbc3KeyGenerator、NoKeyGenerator 和 SelectKeyGenerator。该接口的定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyGenerator</span> </span>{</span><br><span class="line">    <span class="comment">/** 前置操作， order=BEFORE */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processBefore</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span></span>;</span><br><span class="line">    <span class="comment">/** 后置操作， order=AFTER */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processAfter</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>对于这三种实现而言，其中 NoKeyGenerator 虽然实现了该接口，但是对应方法体全部都是空实现，所以没什么可以分析的，我们接下来分别探究一下 Jdbc3KeyGenerator 和 SelectKeyGenerator 的实现。</p>
<ul>
<li><strong>Jdbc3KeyGenerator</strong></li>
</ul>
<p>首先来看 Jdbc3KeyGenerator 实现类，这是一个用于获取数据库自增主键值的实现版本。Jdbc3KeyGenerator 的 <code>Jdbc3KeyGenerator#processBefore</code> 方法是一个空实现，主要实现逻辑位于 <code>Jdbc3KeyGenerator#processAfter</code> 方法中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processAfter</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.processBatch(ms, stmt, parameter);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBatch</span><span class="params">(MappedStatement ms, Statement stmt, Object parameter)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 keyProperty 属性配置，用于指定生成结果所映射的目标属性，可能存在多个</span></span><br><span class="line">    <span class="keyword">final</span> String[] keyProperties = ms.getKeyProperties();</span><br><span class="line">    <span class="keyword">if</span> (keyProperties == <span class="keyword">null</span> || keyProperties.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 调用 Statement#getGeneratedKeys 方法获取数据库自动生成的主键</span></span><br><span class="line">    <span class="keyword">try</span> (ResultSet rs = stmt.getGeneratedKeys()) {</span><br><span class="line">        <span class="comment">// 获取 ResultSet 元数据信息</span></span><br><span class="line">        <span class="keyword">final</span> ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">        <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">        <span class="keyword">if</span> (rsmd.getColumnCount() &lt; keyProperties.length) {</span><br><span class="line">            <span class="comment">// Error?</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 使用主键值填充 parameter 目标属性</span></span><br><span class="line">            <span class="keyword">this</span>.assignKeys(configuration, rs, rsmd, keyProperties, parameter);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Error getting generated key or setting result to parameter object. Cause: "</span> + e, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">assignKeys</span><span class="params">(Configuration configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ResultSet rs,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ResultSetMetaData rsmd,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] keyProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Object parameter)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="keyword">if</span> (parameter <span class="keyword">instanceof</span> ParamMap || parameter <span class="keyword">instanceof</span> StrictMap) {</span><br><span class="line">        <span class="comment">// Multi-param or single param with @Param</span></span><br><span class="line">        <span class="keyword">this</span>.assignKeysToParamMap(configuration, rs, rsmd, keyProperties, (Map&lt;String, ?&gt;) parameter);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (parameter <span class="keyword">instanceof</span> ArrayList</span><br><span class="line">        &amp;&amp; !((ArrayList&lt;?&gt;) parameter).isEmpty()</span><br><span class="line">        &amp;&amp; ((ArrayList&lt;?&gt;) parameter).get(<span class="number">0</span>) <span class="keyword">instanceof</span> ParamMap) {</span><br><span class="line">        <span class="comment">// Multi-param or single param with @Param in batch operation</span></span><br><span class="line">        <span class="keyword">this</span>.assignKeysToParamMapList(configuration, rs, rsmd, keyProperties, (ArrayList&lt;ParamMap&lt;?&gt;&gt;) parameter);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Single param without @Param</span></span><br><span class="line">        <span class="keyword">this</span>.assignKeysToParam(configuration, rs, rsmd, keyProperties, parameter);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述实现的主要逻辑就是获取数据库自增的主键值，并设置到用户传递实参（parameter）的相应属性中。用户指定的实参可以是一个具体的实体类对象、Map 对象，以及集合类型，上述方法会依据入参类型分而治之。以 t_user 这张数据表为例，假设有如下插入语句：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"org.zhenchao.mybatis.entity.User"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into t_user (username, password, age, phone, email)</span><br><span class="line">    values (#{username,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR},</span><br><span class="line">            #{age,jdbcType=INTEGER}, #{phone,jdbcType=VARCHAR}, #{email,jdbcType=VARCHAR})</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>那么 MyBatis 在执行插入时会先获取到数据库的自增 ID 值，并填充到 User 对象中。这里最终会调用 <code>Jdbc3KeyGenerator#assignKeysToParam</code> 方法填充目标属性值，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">assignKeysToParam</span><span class="params">(Configuration configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ResultSet rs,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ResultSetMetaData rsmd,</span></span></span><br><span class="line"><span class="function"><span class="params">                               String[] keyProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Object parameter)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    <span class="comment">// 将 Object 类型参数转换成相应的集合类型</span></span><br><span class="line">    Collection&lt;?&gt; params = collectionize(parameter);</span><br><span class="line">    <span class="keyword">if</span> (params.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 遍历为每个目标属性配置创建对应的 KeyAssigner 分配器</span></span><br><span class="line">    List&lt;KeyAssigner&gt; assignerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyProperties.length; i++) {</span><br><span class="line">        assignerList.add(<span class="keyword">new</span> KeyAssigner(configuration, rsmd, i + <span class="number">1</span>, <span class="keyword">null</span>, keyProperties[i]));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 遍历填充目标属性</span></span><br><span class="line">    Iterator&lt;?&gt; iterator = params.iterator();</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) {</span><br><span class="line">        <span class="keyword">if</span> (!iterator.hasNext()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(String.format(MSG_TOO_MANY_KEYS, params.size()));</span><br><span class="line">        }</span><br><span class="line">        Object param = iterator.next();</span><br><span class="line">        <span class="comment">// 基于 KeyAssigner 使用自增 ID 填充目标属性</span></span><br><span class="line">        assignerList.forEach(x -&gt; x.assign(rs, param));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator.KeyAssigner#assign</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(ResultSet rs, Object param)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (paramName != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// If paramName is set, param is ParamMap</span></span><br><span class="line">        param = ((ParamMap&lt;?&gt;) param).get(paramName);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建实参对应的 MetaObject 对象，以实现对于实参对象的反射操作</span></span><br><span class="line">    MetaObject metaParam = configuration.newMetaObject(param);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (typeHandler == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 创建目标属性对应的类型处理器</span></span><br><span class="line">            <span class="keyword">if</span> (metaParam.hasSetter(propertyName)) {</span><br><span class="line">                Class&lt;?&gt; propertyType = metaParam.getSetterType(propertyName);</span><br><span class="line">                typeHandler = typeHandlerRegistry.getTypeHandler(</span><br><span class="line">                    propertyType, JdbcType.forCode(rsmd.getColumnType(columnPosition)));</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"No setter found for the keyProperty '"</span></span><br><span class="line">                    + propertyName + <span class="string">"' in '"</span> + metaParam.getOriginalObject().getClass().getName() + <span class="string">"'."</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (typeHandler == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// Error?</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 设置目标属性值</span></span><br><span class="line">            Object value = typeHandler.getResult(rs, columnPosition);</span><br><span class="line">            metaParam.setValue(propertyName, value);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Error getting generated key or setting result to parameter object. Cause: "</span> + e,</span><br><span class="line">            e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果对上述实现不能很好的理解，建议 debug 一下，能够豁然开朗。</p>
<ul>
<li><strong>SelectKeyGenerator</strong></li>
</ul>
<p>SelectKeyGenerator 主要适用于那些不支持自动生成自增主键的数据库类型，从而为这些数据库生成主键值。SelectKeyGenerator 实现了 keyGenerator 接口中定义的全部方法，但是这些方法本质上均将请求直接委托给 <code>SelectKeyGenerator#processGeneratedKeys</code> 方法处理，实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processGeneratedKeys</span><span class="params">(Executor executor, MappedStatement ms, Object parameter)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; keyStatement != <span class="keyword">null</span> &amp;&amp; keyStatement.getKeyProperties() != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 获取 keyProperty 属性配置，用于指定生成结果所映射的目标属性，可能存在多个</span></span><br><span class="line">            String[] keyProperties = keyStatement.getKeyProperties();</span><br><span class="line">            <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">            <span class="comment">// 创建实参 parameter 对应的 MetaObject 对象，便于反射操作</span></span><br><span class="line">            <span class="keyword">final</span> MetaObject metaParam = configuration.newMetaObject(parameter);</span><br><span class="line">            <span class="comment">// 创建 SQL 执行器，并执行 &lt;selectKey/&gt; 中定义的 SQL 语句</span></span><br><span class="line">            Executor keyExecutor = configuration.newExecutor(executor.getTransaction(), ExecutorType.SIMPLE);</span><br><span class="line">            List&lt;Object&gt; values = keyExecutor.query(</span><br><span class="line">                keyStatement, parameter, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理 &lt;selectKey/&gt; 的返回值，填充目标属性 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (values.size() == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"SelectKey returned no data."</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (values.size() &gt; <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"SelectKey returned more than one value."</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 创建主键值对应的 MetaObject 对象</span></span><br><span class="line">                MetaObject metaResult = configuration.newMetaObject(values.get(<span class="number">0</span>));</span><br><span class="line">                <span class="comment">// 单列主键的情况</span></span><br><span class="line">                <span class="keyword">if</span> (keyProperties.length == <span class="number">1</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (metaResult.hasGetter(keyProperties[<span class="number">0</span>])) {</span><br><span class="line">                        <span class="keyword">this</span>.setValue(metaParam, keyProperties[<span class="number">0</span>], metaResult.getValue(keyProperties[<span class="number">0</span>]));</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 没有 getter 方法，尝试直接获取属性值</span></span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// no getter for the property - maybe just a single value object, so try that</span></span><br><span class="line">                        <span class="keyword">this</span>.setValue(metaParam, keyProperties[<span class="number">0</span>], values.get(<span class="number">0</span>));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 多列主键的情况，依次从主键对象中获取对应的属性记录到用户参数对象中</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">this</span>.handleMultipleProperties(keyProperties, metaParam, metaResult);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (ExecutorException e) {</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Error selecting key or setting result to parameter object. Cause: "</span> + e, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>SelectKeyGenerator 会执行 <code>&lt;selectKey/&gt;</code> 中定义的 SQL 语句，拿到具体的返回值依据 keyProperty 配置填充目标属性。</p>

        <h3 id="封装-SQL-语句">
          <a href="#封装-SQL-语句" class="heading-link"><i class="fas fa-link"></i></a>封装 SQL 语句</h3>
      <p>上面的分析中曾遇到 SqlNode 和 SqlSource 这两个接口，本小节将对这两个接口及其实现类做一个分析。在这之前我们需要简单了解一下这两个接口各自的作用，由前面的分析我们知道对于一个 SQL 语句标签而言，最后会被封装成为一个 MappedStatement 对象，而标签中定义的 SQL 语句则由 SqlSource 进行表示，SqlNode 则用来定义动态 SQL 节点和文本节点等。</p>

        <h4 id="SqlNode">
          <a href="#SqlNode" class="heading-link"><i class="fas fa-link"></i></a>SqlNode</h4>
      <p>由点及面，我们先来看一下 SqlNode 的相关实现。SqlNode 是一个接口，其中仅声明了一个 <code>SqlNode#apply</code> 方法，接口定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlNode</span> </span>{</span><br><span class="line">    <span class="comment">/** 基于传递的实参，解析动态 SQL 节点 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>围绕该接口的实现类的 UML 图如下：</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2017/mybatis-sqlnode.png" alt="image">
      </p>
<p>下面逐一对 SqlNode 的实现类进行分析。</p>
<ul>
<li><strong>MixedSqlNode</strong></li>
</ul>
<p>首先来看一下前面多次遇到的 MixedSqlNode，它通过一个 <code>MixedSqlNode#contents</code> 集合属性记录包含的 SqlNode 对象，其 <code>MixedSqlNode#apply</code> 方法会遍历该集合并应用记录的各个 SqlNode 对象的 <code>SqlNode#apply</code> 方法，实现比较简单。</p>
<ul>
<li><strong>StaticTextSqlNode</strong></li>
</ul>
<p>与 MixedSqlNode 实现类似的还包括 StaticTextSqlNode 类。该类采用一个 String 类型的 <code>StaticTextSqlNode#text</code> 属性记录非动态的 SQL 节点，其 <code>StaticTextSqlNode#apply</code> 方法直接调用 <code>DynamicContext#appendSql</code> 方法将记录的 SQL 节点添加到一个 StringBuilder 类型属性中。该属性用于记录 SQL 语句片段，当我们最后调用 <code>DynamicContext#getSql</code> 方法时会调用该属性的 toString 方法拼接记录的 SQL 片段，返回最终完整的 SQL 语句。</p>
<ul>
<li><strong>TextSqlNode</strong></li>
</ul>
<p>TextSqlNode 用于封装包含占位符 <code>${}</code> 的动态 SQL 节点，前面在分析 SQL 语句标签时也曾遇到。该实现类的 <code>TextSqlNode#apply</code> 方法定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>{</span><br><span class="line">    <span class="comment">// BindingTokenParser 是内部类，基于 DynamicContext#bindings 中的属性解析 SQL 语句中的占位符</span></span><br><span class="line">    GenericTokenParser parser = <span class="keyword">this</span>.createParser(<span class="keyword">new</span> BindingTokenParser(context, injectionFilter));</span><br><span class="line">    <span class="comment">// 解析并记录 SQL 片段到 DynamicContext 中</span></span><br><span class="line">    context.appendSql(parser.parse(text));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>GenericTokenParser 的执行逻辑我们之前遇到过多次，它主要用来查找指定标识的占位符（这里的占位符是 <code>${}</code>），并基于指定的 TokenHandler 对解析到的占位符变量进行处理。TextSqlNode 内部实现了 TokenHandler 解析器（即 BindingTokenParser），该解析器基于 <code>DynamicContext#bindings</code> 属性中记录的参数值解析 SQL 语句中的占位符，并将解析结果记录到 DynamicContext 对象中。</p>
<ul>
<li><strong>VarDeclSqlNode</strong></li>
</ul>
<p>VarDeclSqlNode 对应动态 SQL 中的 <code>&lt;bind/&gt;</code> 标签，该标签可以从 OGNL 表达式中创建一个变量并将其绑定到上下文中，官方文档中关于该标签的使用示例如下：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlogsLike"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + _parameter.getTitle() + '%'"</span> /&gt;</span></span><br><span class="line">    SELECT * FROM BLOG WHERE title LIKE #{pattern}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>VarDeclSqlNode 定义了 <code>VarDeclSqlNode#name</code> 和 <code>VarDeclSqlNode#expression</code> 两个属性，分别与 <code>&lt;bind/&gt;</code> 标签的属性对应。该实现类的 <code>VarDeclSqlNode#apply</code> 方法完成了对 OGNL 表达式的解析，并将解析得到的真实值记录到 <code>DynamicContext#bindings</code> 属性中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>{</span><br><span class="line">    <span class="comment">// 解析 OGNL 表达式对应的值</span></span><br><span class="line">    <span class="keyword">final</span> Object value = OgnlCache.getValue(expression, context.getBindings());</span><br><span class="line">    <span class="comment">// 绑定到上下文中，name 对应属性 &lt;bind/&gt; 标签的 name 属性配置</span></span><br><span class="line">    context.bind(name, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<ul>
<li><strong>IfSqlNode</strong></li>
</ul>
<p>IfSqlNode 对应动态 SQL 的 <code>&lt;if/&gt;</code> 标签，这也是我们频繁使用的条件标签。IfSqlNode 的属性定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 用于解析 &lt;if/&gt; 标签的 test 表达式 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line"><span class="comment">/** 记录 &lt;if/&gt; 标签中的 test 表达式 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String test;</span><br><span class="line"><span class="comment">/** 记录 &lt;if/&gt; 标签的子标签 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br></pre></td></tr></tbody></table></div></figure>
<p>相应的 <code>IfSqlNode#apply</code> 实现会首先调用 <code>ExpressionEvaluator#evaluateBoolean</code> 方法判定 <code>IfSqlNode#test</code> 属性记录的表达式是否为 true，如果为 true 则应用记录的子标签的 <code>SqlNode#apply</code> 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>{</span><br><span class="line">    <span class="comment">// 检测 test 表达式是否为 true</span></span><br><span class="line">    <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) {</span><br><span class="line">        <span class="comment">// 执行子标签的 apply 方法</span></span><br><span class="line">        contents.apply(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.ibatis.scripting.xmltags.ExpressionEvaluator#evaluateBoolean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluateBoolean</span><span class="params">(String expression, Object parameterObject)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取 OGNL 表达式对应的值</span></span><br><span class="line">    Object value = OgnlCache.getValue(expression, parameterObject);</span><br><span class="line">    <span class="comment">// 转换为 boolean 类型返回</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Boolean) {</span><br><span class="line">        <span class="keyword">return</span> (Boolean) value;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Number) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(String.valueOf(value)).compareTo(BigDecimal.ZERO) != <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<ul>
<li><strong>ChooseSqlNode</strong></li>
</ul>
<p>ChooseSqlNode 对应动态 SQL 中的 <code>&lt;choose/&gt;</code> 标签，我们通常利用此标签配合 <code>&lt;when/&gt;</code> 和 <code>&lt;otherwise/&gt;</code> 标签实现 switch 功能，具体使用方式可以参考官方示例。实现层面，MyBatis 并没有定义 WhenSqlNode 和 OtherwiseSqlNode 类与另外两个标签相对应，而是采用 IfSqlNode 表示 <code>&lt;when/&gt;</code> 标签，采用 MixedSqlNode 表示 <code>&lt;otherwise/&gt;</code> 标签。ChooseSqlNode 类的属性和 <code>ChooseSqlNode#apply</code> 方法定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 对应 &lt;otherwise/&gt; 标签，采用 {<span class="doctag">@link</span> MixedSqlNode} 表示 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode defaultSqlNode;</span><br><span class="line"><span class="comment">/** 对应 &lt;when/&gt; 标签，采用 {<span class="doctag">@link</span> IfSqlNode} 表示 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SqlNode&gt; ifSqlNodes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历应用 &lt;when/&gt; 标签，一旦成功一个就返回</span></span><br><span class="line">    <span class="keyword">for</span> (SqlNode sqlNode : ifSqlNodes) {</span><br><span class="line">        <span class="keyword">if</span> (sqlNode.apply(context)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 所有的 &lt;when/&gt; 都不满足，执行 &lt;otherwise/&gt; 标签</span></span><br><span class="line">    <span class="keyword">if</span> (defaultSqlNode != <span class="keyword">null</span>) {</span><br><span class="line">        defaultSqlNode.apply(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<ul>
<li><strong>TrimSqlNode</strong></li>
</ul>
<p>TrimSqlNode 对应 <code>&lt;trim/&gt;</code> 标签，用于处理动态 SQL 拼接在一些条件下出现不完整 SQL 的情况，具体使用可以参考官方示例。该实现类的属性和 <code>TrimSqlNode#apply</code> 方法定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 记录 &lt;trim/&gt; 标签的子标签 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br><span class="line"><span class="comment">/** 期望追加的前缀字符串 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line"><span class="comment">/** 期望追加的后缀字符串 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String suffix;</span><br><span class="line"><span class="comment">/** 如果 &lt;trim/&gt; 包裹的 SQL 语句为空，则删除指定前缀 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; prefixesToOverride;</span><br><span class="line"><span class="comment">/** 如果 &lt;trim/&gt; 包裹的 SQL 语句为空，则删除指定后缀 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; suffixesToOverride;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 FilteredDynamicContext 对象，封装上下文</span></span><br><span class="line">    FilteredDynamicContext filteredDynamicContext = <span class="keyword">new</span> FilteredDynamicContext(context);</span><br><span class="line">    <span class="comment">// 应用子标签的 apply 方法</span></span><br><span class="line">    <span class="keyword">boolean</span> result = contents.apply(filteredDynamicContext);</span><br><span class="line">    <span class="comment">// 处理前缀和后缀</span></span><br><span class="line">    filteredDynamicContext.applyAll();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>TrimSqlNode 中定义了内部类 FilteredDynamicContext，它是对上下文对象 DynamicContext 的封装，其 <code>FilteredDynamicContext#applyAll</code> 方法实现了对不完整 SQL 的处理。该方法调用 <code>FilteredDynamicContext#applyPrefix</code> 和 <code>FilteredDynamicContext#applySuffix</code> 方法分别处理 SQL 的前缀和后缀，并将处理完后的 SQL 片段记录到上下文对象中：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyAll</span><span class="params">()</span> </span>{</span><br><span class="line">    sqlBuffer = <span class="keyword">new</span> StringBuilder(sqlBuffer.toString().trim());</span><br><span class="line">    <span class="comment">// 全部转换成大写</span></span><br><span class="line">    String trimmedUppercaseSql = sqlBuffer.toString().toUpperCase(Locale.ENGLISH);</span><br><span class="line">    <span class="keyword">if</span> (trimmedUppercaseSql.length() &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 处理前缀</span></span><br><span class="line">        <span class="keyword">this</span>.applyPrefix(sqlBuffer, trimmedUppercaseSql);</span><br><span class="line">        <span class="comment">// 处理后缀</span></span><br><span class="line">        <span class="keyword">this</span>.applySuffix(sqlBuffer, trimmedUppercaseSql);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 添加解析后的结果到 delegate 中</span></span><br><span class="line">    delegate.appendSql(sqlBuffer.toString());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>方法 <code>FilteredDynamicContext#applyPrefix</code> 和 <code>FilteredDynamicContext#applySuffix</code> 的实现思路相同，这里以 <code>FilteredDynamicContext#applyPrefix</code> 方法为例进行说明。该方法会遍历指定的前缀并判断当前 SQL 片段是否以包含的前缀开头，是的话则会删除该前缀，如果指定了 prefix 属性则会在 SQL 语句片段前面追加对应的前缀值。WhereSqlNode 和 SetSqlNode 均由 TrimSqlNode 派生而来，实现比较简单，不多作撰述。</p>
<ul>
<li><strong>ForEachSqlNode</strong></li>
</ul>
<p>最后再来看一下 ForEachSqlNode 类，该类对应 <code>&lt;foreach/&gt;</code> 标签，前面我们曾介绍了相关的 ForEachHandler 类实现。ForEachSqlNode 类是所有 SqlNode 实现类中最复杂的一个，其主要的属性定义如下（建议参考官方文档进行理解）：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 标识符 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ITEM_PREFIX = <span class="string">"__frch_"</span>;</span><br><span class="line"><span class="comment">/** 用于判断循环的终止条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line"><span class="comment">/** 迭代的集合表达式 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String collectionExpression;</span><br><span class="line"><span class="comment">/** 记录子标签 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br><span class="line"><span class="comment">/** open 标识 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String open;</span><br><span class="line"><span class="comment">/** close 标识 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String close;</span><br><span class="line"><span class="comment">/** 循环过程中，各项之间的分隔符 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String separator;</span><br><span class="line"><span class="comment">/** index 是迭代的次数，item 是当前迭代的元素 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String item;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String index;</span><br></pre></td></tr></tbody></table></div></figure>
<p>ForEachSqlNode 中定义了两个内部类：FilteredDynamicContext 和 PrefixedContext。</p>
<p><strong>FilteredDynamicContext</strong> 由 DynamicContext 派生而来，其中稍复杂的实现是 <code>FilteredDynamicContext#appendSql</code> 方法：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendSql</span><span class="params">(String sql)</span> </span>{</span><br><span class="line">    GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">"#{"</span>, <span class="string">"}"</span>, content -&gt; {</span><br><span class="line">        <span class="comment">// 替换 item 为 __frch_item_index</span></span><br><span class="line">        String newContent = content.replaceFirst(<span class="string">"^\\s*"</span> + item + <span class="string">"(?![^.,:\\s])"</span>, itemizeItem(item, index));</span><br><span class="line">        <span class="comment">// 替换 itemIndex 为 __frch_itemIndex_index</span></span><br><span class="line">        <span class="keyword">if</span> (itemIndex != <span class="keyword">null</span> &amp;&amp; newContent.equals(content)) {</span><br><span class="line">            newContent = content.replaceFirst(<span class="string">"^\\s*"</span> + itemIndex + <span class="string">"(?![^.,:\\s])"</span>, itemizeItem(itemIndex, index));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 追加 #{} 标识</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#{"</span> + newContent + <span class="string">"}"</span>;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    delegate.appendSql(parser.parse(sql));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>实际上这里还是之前多次碰到的 GenericTokenParser 解析占位符的套路（这里的占位符是 <code>#{}</code>），对应的 <code>TokenHandler#handleToken</code> 方法会将 item 替换成 <code>__frch_item_index</code> 的形式，拼接的过程由 <code>ForEachSqlNode#itemizeItem</code> 方法实现:</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">itemizeItem</span><span class="params">(String item, <span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">    <span class="comment">// 返回 __frch_item_i 的形式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(ITEM_PREFIX).append(item).append(<span class="string">"_"</span>).append(i).toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>PrefixedContext</strong> 也派生自 DynamicContext 类，在遍历集合拼接时主要用于封装一个由指定前缀和集合元素组成的基本元组，具体实现比较简单。</p>
<p>回到 ForEachSqlNode 类本身，继续来看 <code>ForEachSqlNode#apply</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>{</span><br><span class="line">    Map&lt;String, Object&gt; bindings = context.getBindings();</span><br><span class="line">    <span class="comment">// 解析集合 OGNL 表达式对应的值，返回值对应的迭代器</span></span><br><span class="line">    <span class="keyword">final</span> Iterable&lt;?&gt; iterable = evaluator.evaluateIterable(collectionExpression, bindings);</span><br><span class="line">    <span class="keyword">if</span> (!iterable.iterator().hasNext()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 添加 open 前缀标识</span></span><br><span class="line">    <span class="keyword">this</span>.applyOpen(context);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 迭代处理集合</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : iterable) {</span><br><span class="line">        <span class="comment">// 备份一下上下文对象</span></span><br><span class="line">        DynamicContext oldContext = context;</span><br><span class="line">        <span class="comment">// 第一次遍历，或未指定分隔符</span></span><br><span class="line">        <span class="keyword">if</span> (first || separator == <span class="keyword">null</span>) {</span><br><span class="line">            context = <span class="keyword">new</span> PrefixedContext(context, <span class="string">""</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 其它情况</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            context = <span class="keyword">new</span> PrefixedContext(context, separator);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> uniqueNumber = context.getUniqueNumber();</span><br><span class="line">        <span class="comment">// 如果是 Map 类型，将 key 和 value 记录到 DynamicContext#bindings 属性中</span></span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) {</span><br><span class="line">            <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            Map.Entry&lt;Object, Object&gt; mapEntry = (Map.Entry&lt;Object, Object&gt;) o;</span><br><span class="line">            <span class="keyword">this</span>.applyIndex(context, mapEntry.getKey(), uniqueNumber);</span><br><span class="line">            <span class="keyword">this</span>.applyItem(context, mapEntry.getValue(), uniqueNumber);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将当前索引值和元素记录到 DynamicContext#bindings 属性中</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">this</span>.applyIndex(context, i, uniqueNumber);</span><br><span class="line">            <span class="keyword">this</span>.applyItem(context, o, uniqueNumber);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 应用子标签的 apply 方法</span></span><br><span class="line">        contents.apply(<span class="keyword">new</span> FilteredDynamicContext(configuration, context, index, item, uniqueNumber));</span><br><span class="line">        <span class="keyword">if</span> (first) {</span><br><span class="line">            first = !((PrefixedContext) context).isPrefixApplied();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 恢复上下文对象</span></span><br><span class="line">        context = oldContext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 添加 close 后缀标识</span></span><br><span class="line">    <span class="keyword">this</span>.applyClose(context);</span><br><span class="line">    context.getBindings().remove(item);</span><br><span class="line">    context.getBindings().remove(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法的执行过程阅读起来没什么压力，但就是不知道具体在做什么事情。下面我们以批量查询用户信息表 t_user 中的多个用户信息为例来走一遍上述方法的执行过程，对应的动态查询语句定义如下：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByIds"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_user WHERE id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">index</span>=<span class="string">"idx"</span> <span class="attr">item</span>=<span class="string">"itm"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        #{itm}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>假设我们现在希望查询 id 为 1 和 2 的两个用户，执行流程可以表述如下：</p>
<ol>
<li>解析获取到集合表达式对应的集合迭代器对象，这里对应的是一个 List 类型集合的迭代器，其中包含了 1 和 2 两个元素；</li>
<li>调用 <code>ForEachSqlNode#applyOpen</code> 方法添加 OPEN 标识符，这里即 <code>(</code>；</li>
<li>进入 for 循环，因为是第一次遍历，所以会创建 prefix 参数为空字符串的 PrefixedContext 对象；</li>
<li>这里集合类型中封装的是 Long 类型（不是 Map 类型）：<ul>
<li>调用 <code>ForEachSqlNode#applyIndex</code> 方法，记录键值对 <code>(idx, 0)</code> 和 <code>(__frch_idx_0, 0)</code> 到 <code>DynamicContext#bindings</code> 属性中；</li>
<li>调用 <code>ForEachSqlNode#applyItem</code> 方法，记录键值对 <code>(itm, 1)</code> 和 <code>(__frch_itm_0, 1)</code> 到 <code>DynamicContext#bindings</code> 中；</li>
</ul>
</li>
<li>应用子标签的 <code>SqlNode#apply</code> 方法，这里会触发 <code>FilteredDynamicContext#appendSql</code> 方法解析占位符 <code>#{itm}</code> 为 <code>#{__frch_itm_0}</code>，此时生成的 SQL 语句片段已然成为 <code>SELECT * FROM t_user WHERE id IN ( #{__frch_itm_0}</code>；</li>
<li>进入 for 循环的第二次遍历，此时 first 变量已经置为 false，且这里设置了分隔符，所以执行 <code>new PrefixedContext(context, separator)</code> 创建上下文对象；</li>
<li>这里集合类型同样是 Long 类型（不是 Map 类型）：<ul>
<li>调用 <code>ForEachSqlNode#applyIndex</code> 方法，记录键值对 <code>(idx, 1)</code> 和 <code>(__frch_idx_1, 1)</code> 到 <code>DynamicContext#bindings</code> 属性中；</li>
<li>调用 <code>ForEachSqlNode#applyItem</code> 方法，记录键值对 <code>(itm, 2)</code> 和 <code>(__frch_itm_1, 2)</code> 到 <code>DynamicContext#bindings</code> 属性中；</li>
</ul>
</li>
<li>应用子标签的 <code>SqlNode#apply</code> 方法，这里会触发 <code>FilteredDynamicContext#appendSql</code> 方法解析占位符 <code>#{itm}</code> 为 <code>#{__frch_itm_1}</code>，此时生成的 SQL 语句片段已然成为 <code>SELECT * FROM t_user WHERE id IN ( #{__frch_itm_0}, #{__frch_itm_1}</code></li>
<li>for 循环结束，调用 <code>ForEachSqlNode#applyClose</code> 追加 CLOSE 标识符，这里即 <code>)</code>。</li>
</ol>
<p>最后解析得到的 SQL 为 <code>SELECT * FROM t_user WHERE id IN ( #{__frch_itm_0} , #{__frch_itm_1} )</code>。希望通过这样一个过程辅助读者进行理解，如果还是云里雾里可以 debug 一下整个过程。</p>

        <h4 id="SqlSource">
          <a href="#SqlSource" class="heading-link"><i class="fas fa-link"></i></a>SqlSource</h4>
      <p>前面介绍了 SqlSource 用于表示映射文件或注解定义的 SQL 语句标签中的 SQL 语句，但是这里的 SQL 语句并不是可执行的，其中可能包含一些动态占位符。SqlSource 接口的定义如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSource</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于传入的参数返回可执行的 SQL 语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameterObject 用户传递的实参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>围绕该接口的实现类的 UML 图如下：</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2017/mybatis-sqlsource.png" alt="image">
      </p>
<p>其中，RawSqlSource 用于封装静态定义的 SQL 语句；DynamicSqlSource 用于封装动态定义的 SQL 语句；ProviderSqlSource 则用于封装注解形式定义的 SQL 语句。不管是动态还是静态的 SQL 语句，经过处理之后都会封装成为 StaticSqlSource 对象，其中包含的 SQL 语句是可以直接执行的。</p>
<p>考虑 MyBatis 目前还是主推 XML 的配置使用方式，所以不打算对 ProviderSqlSource 展开说明。在开始分析剩余三个实现类之前，需要先对这几个类共享的一个核心组件 SqlSourceBuilder 进行分析。SqlSourceBuilder 继承自 BaseBuilder，主要用于解析前面经过 <code>SqlNode#apply</code> 方法处理的 SQL 语句中的占位符属性，同时将占位符替换成  <code>?</code> 字符串。</p>
<p>SqlSourceBuilder 中仅定义了一个 <code>SqlSourceBuilder#parse</code> 方法，实现了对占位符 <code>#{}</code> 中属性的解析，并将占位符替换成 <code>?</code>。最终将解析得到的 SQL 语句和相关参数封装成 StaticSqlSource 对象返回。方法 <code>SqlSourceBuilder#parse</code> 的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String originalSql, // 经过 SqlNode#apply 方法处理后的 SQL 语句</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; parameterType, // 用户传递的实参类型</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; additionalParameters)</span> </span>{ <span class="comment">// 记录形参与实参之间的对应关系，即 SqlNode#apply 方法处理之后记录在 DynamicContext#bindings 属性中的键值对</span></span><br><span class="line">    <span class="comment">// 创建 ParameterMappingTokenHandler 对象，用于解析 #{} 占位符</span></span><br><span class="line">    ParameterMappingTokenHandler handler =</span><br><span class="line">        <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">    GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">"#{"</span>, <span class="string">"}"</span>, handler);</span><br><span class="line">    String sql = parser.parse(originalSql); <span class="comment">// SELECT * FROM t_user WHERE id IN ( ? , ? )</span></span><br><span class="line">    <span class="comment">// 构造 StaticSqlSource 对象，其中封装了被替换成 ? 的 SQL 语句，以及参数对应的 ParameterMapping 集合</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>该方法的实现还是我们熟悉的套路，获取指定占位符中的属性，然后交由对应的 TokenHandler 进行处理。SqlSourceBuilder 定义了 ParameterMappingTokenHandler 内部类，这是一个具体的 TokenHandler 实现，该内部类同时还继承自 BaseBuilder 抽象类，对应的 <code>ParameterMappingTokenHandler#handleToken</code> 方法实现如下;</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>{ <span class="comment">// 占位符中定义的属性，例如 __frch_itm_0</span></span><br><span class="line">    <span class="comment">// 调用 buildParameterMapping 方法构造当前 content 对应的 ParameterMapping 对象，并记录到 parameterMappings 集合中</span></span><br><span class="line">    <span class="comment">// ParameterMapping{property='__frch_itm_0', mode=IN, javaType=class java.lang.Long, jdbcType=null, numericScale=null, resultMapId='null', jdbcTypeName='null', expression='null'}</span></span><br><span class="line">    parameterMappings.add(<span class="keyword">this</span>.buildParameterMapping(content));</span><br><span class="line">    <span class="comment">// 全部返回 ? 字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"?"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法会调用 <code>ParameterMappingTokenHandler#buildParameterMapping</code> 方法构造实参 content （占位符中的属性）对应的 ParameterMapping 对象，并记录到 <code>ParameterMappingTokenHandler#parameterMappings</code> 属性中，同时返回 <code>?</code> 占位符将原始 SQL 中对应的占位符全部替换成 <code>?</code> 字符。这里我们以前面 <code>SqlNode#apply</code> 方法解析得到的 <code>SELECT * FROM t_user WHERE id IN ( #{__frch_itm_0} , #{__frch_itm_1} )</code> 为例，该 SQL 语句经过 <code>SqlSourceBuilder#parse</code> 方法处理之后会被解析成 <code>SELECT * FROM t_user WHERE id IN ( ? , ? )</code> 的形式封装到 StaticSqlSource 对象中。对应的 <code>ParameterMappingTokenHandler#parameterMappings</code> 参数内容如下：</p>
<figure class="highlight text"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParameterMapping{property='__frch_itm_0', mode=IN, javaType=class java.lang.Long, jdbcType=null, numericScale=null, resultMapId='null', jdbcTypeName='null', expression='null'}</span><br><span class="line">ParameterMapping{property='__frch_itm_1', mode=IN, javaType=class java.lang.Long, jdbcType=null, numericScale=null, resultMapId='null', jdbcTypeName='null', expression='null'}</span><br></pre></td></tr></tbody></table></div></figure>
<p>了解了 SqlSourceBuilder 的作用，我们回头来看 DynamicSqlSource 的实现就会比较容易，DynamicSqlSource 实现了 SqlSource 接口中声明的 <code>SqlSource#getBoundSql</code> 方法，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>{</span><br><span class="line">    <span class="comment">// 构造上下文对象</span></span><br><span class="line">    DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line">    <span class="comment">// 应用 SqlNode#apply 方法（树型结构，会遍历应用树中各个节点的 SqlNode#apply 方法），各司其职追加 SQL 片段到上下文中</span></span><br><span class="line">    rootSqlNode.apply(context);</span><br><span class="line">    <span class="comment">// 创建 SqlSourceBuilder 对象，解析占位符属性，并将 SQL 语句中的 #{} 占位符替换成 ? 字符</span></span><br><span class="line">    SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">    Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass(); <span class="comment">// 解析用户实参类型</span></span><br><span class="line">    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); <span class="comment">// 解析并封装结果为 StaticSqlSource 对象</span></span><br><span class="line">    <span class="comment">// 基于 SqlSourceBuilder 解析结果和实参创建 BoundSql 对象</span></span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    <span class="comment">// 将 DynamicContext#bindings 中的参数信息复制到 BoundSql#additionalParameters 属性中</span></span><br><span class="line">    context.getBindings().forEach(boundSql::setAdditionalParameter);</span><br><span class="line">    <span class="keyword">return</span> boundSql;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>该方法最终会将解析得到的 SQL 语句，以及相应的参数全部封装到 BoundSql 对象中返回，具体过程可以参考上述代码注释。</p>
<p>相对于 DynamicSqlSource 来说，RawSqlSource 的 <code>RawSqlSource#getBoundSql</code> 方法实现就要简单了许多。RawSqlSource 直接将请求委托给了 StaticSqlSource 处理，本质上就是基于用户传递的参数来构造 BoundSql 对象。对应 SQL 的解析则放置在构造方法中，在构造方法中会调用 <code>RawSqlSource#getSql</code> 方法获取对应的 SQL 定义，同样基于 SqlSourceBuilder 对原始 SQL 语句进行解析，封装成 StaticSqlSource 对象记录到属性中，在实际运行时只要填充参数即可。这也是很容易理解的，毕竟对于静态 SQL 来说，它的模式在整个应用程序运行过程中是不变的，所以在系统初始化时完成解析操作，后续可以直接拿来使用，但是对于动态 SQL 来说，SQL 语句的具体模式取决于用户传递的参数，需要在运行时实时解析。</p>

        <h3 id="绑定-Mapper-接口">
          <a href="#绑定-Mapper-接口" class="heading-link"><i class="fas fa-link"></i></a>绑定 Mapper 接口</h3>
      <p>饶了一大圈，看起来我们似乎完成了对映射文件的加载和解析工作，实际上我们确实完成了对映射文件的解析，但是光解析还是不够的，实际开发中我们对于这些定义在映射文件中的 SQL 语句的调用一般都是通过 Mapper 接口完成。所以还需要建立映射文件与具体 Mapper 接口之间的映射关系，这一过程由 <code>XMLMapperBuilder#bindMapperForNamespace</code> 方法实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取当前映射文件的 namespace 配置</span></span><br><span class="line">    String namespace = builderAssistant.getCurrentNamespace();</span><br><span class="line">    <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) {</span><br><span class="line">        Class&lt;?&gt; boundType = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 解析 namespace 对应的 Mapper 接口类型</span></span><br><span class="line">            boundType = Resources.classForName(namespace);</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">            <span class="comment">// ignore, bound type is not required</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (boundType != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 当前 Mapper 还未加载</span></span><br><span class="line">            <span class="keyword">if</span> (!configuration.hasMapper(boundType)) {</span><br><span class="line">                <span class="comment">// Spring may not know the real resource name so we set a flag</span></span><br><span class="line">                <span class="comment">// to prevent loading again this resource from the mapper interface</span></span><br><span class="line">                <span class="comment">// look at MapperAnnotationBuilder#loadXmlResource</span></span><br><span class="line">                <span class="comment">// 记录当前已经加载的 namespace 标识到 Configuration#loadedResources 属性中</span></span><br><span class="line">                configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</span><br><span class="line">                <span class="comment">// 注册对应的 Mapper 接口到 Configuration#mapperRegistry 属性中（对应 MapperRegistry）</span></span><br><span class="line">                configuration.addMapper(boundType);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述方法首先会获取对应映射文件的命名空间，然后构造命名空间字面量对应的 Class 类型，并记录到 Configuration 对象中。这里本质上调用的是 <code>MapperRegistry#addMapper</code> 方法执行注册操作，MapperRegistry 的实现之前已经分析过，这里就不再重复说明。</p>

        <h3 id="处理解析失败的标签">
          <a href="#处理解析失败的标签" class="heading-link"><i class="fas fa-link"></i></a>处理解析失败的标签</h3>
      <p>在前面分析解析过程时，对于一些解析异常的标签会记录到 Configuration 对象的相应属性中，包括 SQL 语句标签、<code>&lt;resultMap/&gt;</code> 标签，以及 <code>&lt;cache-ref/&gt;</code> 标签。需要说明的是这些记录的标签不一定全是解析异常所致，有些标签的解析存在依赖关系，如果 A 依赖于 B，在解析 A 时 B 还未被解析，MyBatis 则会将标签 A 记录起来，等到最后再尝试解析。在映射文件解析过程的最后会再次尝试对这些标签进行解析，如下面的代码所示：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理解析失败的 &lt;resultMap/&gt; 标签</span></span><br><span class="line"><span class="keyword">this</span>.parsePendingResultMaps();</span><br><span class="line"><span class="comment">// 处理解析失败的 &lt;cache-ref/&gt; 标签</span></span><br><span class="line"><span class="keyword">this</span>.parsePendingCacheRefs();</span><br><span class="line"><span class="comment">// 处理解析失败的 SQL 语句标签</span></span><br><span class="line"><span class="keyword">this</span>.parsePendingStatements();</span><br></pre></td></tr></tbody></table></div></figure>
<p>这些再次触发解析的方法在实现上都是一个思路，就是从 Configuration 对象中获取解析失败的标签对象集合，然后遍历执行相应的解析方法，前面已经对这些标签的解析过程进行了分析，不再重复。</p>

        <h3 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>至此，我们算是真正完成了对映射文件的加载与解析工作，也基本上完成了 MyBatis 框架的初始化过程，接下来可以创建 SqlSession 对象，并执行具体的数据库操作。在下一篇中，我们将一起来分析 MyBatis 执行 SQL 语句的具体过程实现，包括获取 SQL 语句、绑定参数、执行数据库操作，以及结果集映射等操作。</p>

        <h3 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h3>
      <ol>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis 官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/27087564/">MyBatis 技术内幕</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2017/10/14/mybatis/mybatis-mapper/">https://plotor.github.io/2017/10/14/mybatis/mybatis-mapper/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/MyBatis/">MyBatis</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2017/10/15/mybatis/mybatis-execute-sql/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">MyBatis 源码解析：SQL 语句的执行机制</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2017/10/12/mybatis/mybatis-config/"><span class="paginator-prev__text">MyBatis 源码解析：配置文件的加载与解析</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%A7%A3%E6%9E%90%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">
          加载与解析映射文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-cache-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.1.</span> <span class="toc-text">
          解析 cache 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-cache-ref-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.</span> <span class="toc-text">
          解析 cache-ref 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-resultMap-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.3.</span> <span class="toc-text">
          解析 resultMap 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-sql-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.4.</span> <span class="toc-text">
          解析 sql 标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-select-insert-update-delete-%E6%A0%87%E7%AD%BE"><span class="toc-number">1.5.</span> <span class="toc-text">
          解析 select &#x2F; insert &#x2F; update &#x2F; delete 标签</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-include-%E5%AD%90%E6%A0%87%E7%AD%BE"><span class="toc-number">1.5.1.</span> <span class="toc-text">
          解析 include 子标签</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-selectKey-%E5%AD%90%E6%A0%87%E7%AD%BE"><span class="toc-number">1.5.2.</span> <span class="toc-text">
          解析 selectKey 子标签</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85-SQL-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.</span> <span class="toc-text">
          封装 SQL 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SqlNode"><span class="toc-number">2.1.</span> <span class="toc-text">
          SqlNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SqlSource"><span class="toc-number">2.2.</span> <span class="toc-text">
          SqlSource</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-Mapper-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">
          绑定 Mapper 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%A0%87%E7%AD%BE"><span class="toc-number">4.</span> <span class="toc-text">
          处理解析失败的标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">
          总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">95</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2025</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>