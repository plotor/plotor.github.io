<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/favicon_16.png?v=2.6.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/favicon_32.png?v=2.6.1" type="image/png" sizes="32x32"><meta name="google-site-verification" content="O5CNgi37yYXs3qQp7Xz61oL_AmGiwM28d7hRt5yh2to"><meta name="baidu-site-verification" content="pnKVynCWMP"><meta name="description" content="ConcurrentHashMap 是线程安全的 HashMap。此前，HashTable 一直被认为是线程安全的 HashMap，ConcurrentHashMap 相对于 HashTable 采用了 锁分段机制 ，即将原本对整个对象加锁的实现进行粒度细化。这也是源于 HashMap 基本的存储特性，因为许多读写请求都是被哈希到了互相独立的区域，这种情况下即使并发读写也不会相互影响，更不会有线程">
<meta property="og:type" content="article">
<meta property="og:title" content="基于锁分段机制的 ConcurrentHashMap 实现内幕">
<meta property="og:url" content="https://plotor.github.io/2016/08/16/java/segment-based-concurrent-hashmap/index.html">
<meta property="og:site_name" content="指  间">
<meta property="og:description" content="ConcurrentHashMap 是线程安全的 HashMap。此前，HashTable 一直被认为是线程安全的 HashMap，ConcurrentHashMap 相对于 HashTable 采用了 锁分段机制 ，即将原本对整个对象加锁的实现进行粒度细化。这也是源于 HashMap 基本的存储特性，因为许多读写请求都是被哈希到了互相独立的区域，这种情况下即使并发读写也不会相互影响，更不会有线程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://plotor.github.io/images/2016/concurrent_hashmap.png">
<meta property="article:published_time" content="2016-08-16T00:06:30.000Z">
<meta property="article:modified_time" content="2024-12-10T08:35:13.046Z">
<meta property="article:author" content="zhenchao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://plotor.github.io/images/2016/concurrent_hashmap.png"><title>基于锁分段机制的 ConcurrentHashMap 实现内幕 | 指  间</title><link ref="canonical" href="https://plotor.github.io/2016/08/16/java/segment-based-concurrent-hashmap/"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-circle"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">基于锁分段机制的 ConcurrentHashMap 实现内幕</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2016-08-16</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">5.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">27分</span></span></div></header><div class="post-body"><p>ConcurrentHashMap 是线程安全的 HashMap。此前，HashTable 一直被认为是线程安全的 HashMap，ConcurrentHashMap 相对于 HashTable 采用了 <strong>锁分段机制</strong> ，即将原本对整个对象加锁的实现进行粒度细化。这也是源于 HashMap 基本的存储特性，因为许多读写请求都是被哈希到了互相独立的区域，这种情况下即使并发读写也不会相互影响，更不会有线程安全问题，而对于操作加全局锁的实现方式显然是浪费了这一天然的并发优势，我们需要加锁的位置是真正存在竞争的地方，而分段锁很好的利用了这一特点。<a id="more"></a></p>

        <h3 id="一-存储结构设计">
          <a href="#一-存储结构设计" class="heading-link"><i class="fas fa-link"></i></a>一. 存储结构设计</h3>
      <p>在实现上，ConcurrentHashMap 内置了两个静态内部类 HashEntry 和 Segment，前者用来封装 key/value，后者则用来充当锁的角色。一个 Segment（分段）上挂载着一张包含多行记录的表（table），负责范围内各个结点读写的线程安全，每行记录都是由一个以 HashEntry 为结点的链表构成。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="/images/2016/concurrent_hashmap.png" alt="image">
      </p>
<p>上面这张图具体描绘了 ConcurrentHashMap 的存储结构设计，默认情况下一个 ConcurrentHashMap 包含 16 个分段（Segment），每个分段包含一张表（HashEntry 类型数组 table），而表中的每行记录都是一个包含了若干个 HashEntry 类型结点的链表，HashEntry 可以看作是整个存储结构中最小的存储单元。在这样的存储结构基础上，我们可以初步臆测 ConcurrentHashMap 存储、读取数据的实现过程，概括来说就是先基于 key 的哈希值定位到具体的分段，然后映射到对应的表，最后就是对表中链表的常规遍历操作。而在这个过程中，锁的粒度控制在一个分段范围内，也就是说只有哈希到同一个分段内的多个读写操作才会存在竞争，而分段与分段之间的读写操作则互不影响、并发执行。段内竞争的线程安全则以具体的分段对象作为锁来执行同步策略，所以在默认理想情况下，一个 ConcurrentHashMap 具备 16 个线程的并发读写能力，这相对于对整个存储对象加全局锁的 HashTable 来说，效率提升了许多。</p>
<p>我们先来分别看一下 HashEntry 和 Segment 这两个基础组件的内部结构实现，首先来看一下 HashEntry:</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// 哈希值，key 的 hash 值，不允许修改，所以用 final 修饰，同时也保证了可见性</span></span><br><span class="line">    <span class="keyword">final</span> K key;  <span class="comment">// 键，final 修饰保证不允许修改与可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> V value; <span class="comment">// 值，volatile 修饰保证值的可见性，value 的值允许被更新</span></span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next; <span class="comment">// 链表 next 指针</span></span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) {</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分实现</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>HashEntry 是对 key/value 的封装类，可以将一个 HashEntry 对象看做是整个存储结构中的最小单位，它是一个结点，包含了必要的 hash、key、value 元素，因为采用链地址法来解决冲突，所以还包含了链表的 next 指针。四个属性中 hash 和 key 是 final 修饰的，而 value 和 next 则是由 volatile 来修饰，这样的设计最根本的都是希望保证在并发访问过程中结点的线程可见性，又因为后两者是可变的对象，所以采用 volatile 进行修饰。</p>
<p>再来看一下 Segment 的实现，Segment 实现了 ReentrantLock 类，所以可以将其视为一个针对 HashMap 作了适配的可重入锁，每个 Segment 对象的责任就是用来保证其守护的表内各个结点访问的线程安全：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分段内挂载的表，表中包含了若干条记录（对应数组大小），每条记录都是一个由一系列 HashEntry 结点构成的链表 */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 计数当前 Segment 范围内 HashEntry 结点的数目（各个槽位上链表长度之和） */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** table 被修改的次数，可以用来表示一段时间内分段内是否有操作行为（不包含更新 key 对应的 value 行为） */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再散列阈值，当 table 范围内包含的 HashEntry 结点的数量超过该阈值时，将触发再散列</span></span><br><span class="line"><span class="comment">     * threshold = capacity * loadFactor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 装载因子 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) {</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">        <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">        <span class="keyword">this</span>.table = tab;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 put、rehash、scanAndLockForPut、scanAndLock、remove、replace 方法的实现</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Segment 可以理解为分段，默认 ConcurrentHashMap 包含 16 个分段，对应的属性已经在代码中注释，这里再进一步讲解一下 table 属性，因为它是存储结构的一份子。table 属性是一个 HashEntry 类型的数组，每个数组元素都是一个 HashEntry 链表。HashEntry 的名字取的个人觉得既好也不好，说其好是因为每个链表的起始节点也是 HashEntry 类型，可以形象的称其为“入口”，但是具体到链表中的每个结点应该用 Node 来表示更加形象，不过真正理解了也就不会因为名字而疑惑。</p>
<p>接下来我们继续探究 ConcurrentHashMap 基于 HashEntry 和 Segment 的实现，实际上是对前面的存储结构图示的具体描述：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 默认分段的数量 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 默认的装载因子 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 默认的并发度 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分段 table 内最大的行记录数 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分段 table 内行记录数最小值，必须是二次幂 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分段的最大数目 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// 保守值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 加锁之前的重试次数 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 掩码值，用来计算分段数组的下标，以定位具体的分段 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 偏移量 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分段数组 */</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    <span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找最佳匹配参数，大于给定参数 concurrencyLevel 的最小二次幂</span></span><br><span class="line">        <span class="comment">// 必须是二次幂是用来保证能够通过按位与来定位具体的分段</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) {</span><br><span class="line">            ++sshift;  <span class="comment">// 默认为 4</span></span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>; <span class="comment">// 默认为 16</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;  <span class="comment">// 偏移量，默认为 28</span></span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;  <span class="comment">// 掩码值，默认为 15</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize; <span class="comment">// 16 / 16 = 1</span></span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity) ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; <span class="comment">// cap 表示每个分段中 table 的最大长度</span></span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">        putAll(m);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略剩余方法实现</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>具体的属性含义参考代码注释，我们来看一下构造函数的内部逻辑。构造函数允许我们指定 initialCapacity、loadFactor，以及 concurrencyLevel 三个参数值，其中 loadFactor 译为装载因子，在数据结构课程中讲解哈希冲突时已经对相关概念解释的比较清楚，这里不再多做说明，默认为 0.75，一般不建议修改。</p>
<p>我们来看一下 initialCapacity 和 concurrencyLevel 两个参数，这两个参数一起用来控制构造 map 的初始化大小，其中 concurrencyLevel 用来控制分段的数目，构造函数会计算得到大于该值的最小二次幂作为 map 的分段数目，因为分段数目的多少对应着并发度的多少，所以参数命名为 concurrencyLevel 也不难理解。之所以需要用大于该值的最小二次幂作为分段大小，主要是为了配合哈希函数的定义， <strong>方便通过逻辑与运算来定位具体的分段</strong> ，相对于数值运算来说这样效率更高。再来看一下 initialCapacity，该参数用来控制整个 map 集合包含结点的的初始值，最终还是用来控制分段内表的记录行数。</p>

        <h3 id="二-基本方法实现">
          <a href="#二-基本方法实现" class="heading-link"><i class="fas fa-link"></i></a>二. 基本方法实现</h3>
      <p>探究了 ConcurrentHashMap 的存储结构设计，我们继续来看一下常用操作的实现细节。对于 Map 集合来说，常用的方法有添加（put）、获取（get）、删除（remove）键值，以及对这些基本方法的包装方法，此外还有获取集合大小（size）等操作，下面我们针对 ConcurrentHashMap 中典型方法逐个说明。</p>

        <h4 id="2-1-添加或更新键值对：put-K-key-V-value">
          <a href="#2-1-添加或更新键值对：put-K-key-V-value" class="heading-link"><i class="fas fa-link"></i></a>2.1 添加或更新键值对：put(K key, V value)</h4>
      <p>首先来看一下 put 方法，我们都知道 put 操作会修改集合中的数据，也就是写操作，而写操作若希望保证线程安全和可见，则需要一定的同步策略。ConcurrentHashMap 的写操作相对于 HashTable 要高效很多，这主要归功于锁分段机制，具体的实现如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算键对应的哈希值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基于键的哈希值找到对应的 Segment 对象</span></span><br><span class="line"><span class="comment">     * 将 hash 向右移动 segmentShift 偏移位，并与 segmentMask 执行 与 操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Segment 的 put 方法，执行 put 操作</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述过程的逻辑比较明确，可以概括成如下三步：</p>
<blockquote>
<ol>
<li>调用 hash 方法计算 key 的哈希值</li>
<li>基于 key 的哈希值定位具体的分段 Segment</li>
<li>调用 Segment 对象的 put 方法执行 put 逻辑</li>
</ol>
</blockquote>
<p>从整个操作过程我们可以很直观的理解锁分段的实现细节，Segment 就是这里的锁对象，put 操作会首先定位当前需要操作的具体 Segment 对象，然后调用该对象的 put 方法执行写入或更新操作，而具体的锁策略就位于 Segment 的 put 方法内，这个我们后面再深入探究，先来看一下定位具体分段的过程，首先看一下 hash 算法的实现：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed; <span class="comment">// 调用 randomHashSeed(this) 方法计算得到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) {</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算随机的 hash 种子，减少哈希碰撞</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> <span class="keyword">int</span> hashSeed = randomHashSeed(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomHashSeed</span><span class="params">(ConcurrentHashMap instance)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (sun.misc.VM.isBooted() &amp;&amp; Holder.ALTERNATIVE_HASHING) {</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.randomHashSeed(instance);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>之所以不直接使用 jdk 提供的 hashCode() 方法，而是在此基础上进行改写（Wang/Jenkins Hash），主要是考虑到原生哈希算法冲突的可能性较大，而哈希均衡是 ConcurrentHashMap 良好性能的基础，下面的例子证明了改写之后的算法在哈希均衡性上优于原生算法：</p>
<blockquote>
<p>我做了一个测试，不通过再哈希而直接执行哈希计算。</p>
<p>System.out.println(Integer.parseInt(“0001111”, 2) &amp; 15);<br>System.out.println(Integer.parseInt(“0011111”, 2) &amp; 15);<br>System.out.println(Integer.parseInt(“0111111”, 2) &amp; 15);<br>System.out.println(Integer.parseInt(“1111111”, 2) &amp; 15);</p>
<p>计算后输出的哈希值全是15，通过这个例子可以发现如果不进行再哈希，哈希冲突会非常严重，因为只要低位一样，无论高位是什么数，其哈希值总是一样。我们再把上面的二进制数据进行再哈希后结果如下，为了方便阅读，不足32位的高位补了0，每隔四位用竖线分割下。</p>
<p>0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110<br>1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000<br>0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110<br>1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010</p>
<p>可以发现每一位的数据都散列开了，通过这种再哈希能让数字的每一位都能参加到哈希运算当中，从而减少哈希冲突。</p>
</blockquote>
<p>例子引用自 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/ConcurrentHashMap/">聊聊并发 — 深入分析ConcurrentHashMap</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>
<p>然后方法会基于计算得到的哈希值定位具体的分段：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"><span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">    s = ensureSegment(j);</span><br></pre></td></tr></tbody></table></div></figure>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于下标获取对应的分段对象，如果不存在则基于 CAS 策略创建</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) {</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;  <span class="comment">// 分段内 table 的长度</span></span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) { <span class="comment">// recheck</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>默认在构造 ConcurrentHashMap 对象时，segmentShift 值为 28，segmentMask 值为 15，而 hash 值为 32 为，所以这里的计算逻辑是对 hash 右移 28 位，再与 segmentMask 执行与操作，目的是让高 4 位也参与到哈希运算中，最终计算得到对应 segments 数组下标。然后基于下标获取对应的分段，如果分段不存在的话，则会基于 CAS 策略创建并记录相应的分段对象。</p>
<p>接着会调用获取到的 Segment 对象的 put 方法执行 put 操作，记录 key/value 值，其中包含了分段锁机制的具体实现细节：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.ConcurrentHashMap.Segment#put</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">    <span class="comment">// 加锁，如果 tryLock 成功则继续，否则循环尝试加锁</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table; <span class="comment">// 当前 Segment 的 table</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;  <span class="comment">// 计算对应的 table 下标</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index); <span class="comment">// 获取对应的 entry</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) {</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// 对应 entry 上存在链表，且当前还在链表结点上</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) {</span><br><span class="line">                    <span class="comment">// 找到相同的 key，则更新对应的 value</span></span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) {</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                e = e.next; <span class="comment">// 遍历链表上的下一个结点</span></span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 对应 entry 上没有链表，或已经达到链尾</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);  <span class="comment">// 在链表上前置插入新的结点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first); <span class="comment">// 创建新的结点</span></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);  <span class="comment">// 再散列，table 长度扩充一倍</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node); <span class="comment">// 更新 entry</span></span><br><span class="line">                ++modCount; <span class="comment">// 只有当前新插入结点时才计数，如果仅仅是更新已有 key 的 value 则不计数</span></span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;  <span class="comment">// 因为是新的结点，所以 oldValue = null</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如代码注释所示，整个过程还是比较直观的，在代码一开始会尝试锁定当前分段对象，锁定之后就是常规的链表操作，因为整个操作位于临界区中，所以无需再考虑线程安全问题。而具体的实现正如我们一开始简单臆测的一样，首先通过与操作定位 key 在表中的记录行，然后对行上的链表执行遍历，如果对应的 key 已经存在则更新对应的 value，否则在链表最前端插入新的结点。因为 HashEntry 中 value 属性采用 volatile 修饰，所以能够保证更新操作能够立即对 get 线程可见，而之所以要采取前置插入是考虑到一个概率问题，HashMap 的开发者认为 <strong>后面插入的 Entry 被检索的概率更大，从而提升整体 get 性能</strong> ，并且读操作是不需要加锁的，个人觉得前置插入还可以保证在插入的过程中如果存在读线程在遍历当前链表，则插入操作不会对整个遍历过程产生影响。</p>

        <h4 id="2-2-获取指定键值：get-Object-key">
          <a href="#2-2-获取指定键值：get-Object-key" class="heading-link"><i class="fas fa-link"></i></a>2.2 获取指定键值：get(Object key)</h4>
      <p>再来看一下 get 操作，相对于 put 操作而言，get 要简单许多，这是因为读的过程是不需要加锁的，HashEntry 的设计能够保证节点变更的线程可见性。而结合对于存储结构设计的理解，即使不看源码，我们也能够大致知道整个过程的实现细节，这里不再展开说明。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);  <span class="comment">// 计算 key 的哈希值</span></span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp; (tab = s.table) != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 获取对应的 entry，并遍历链表上的结点</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != <span class="keyword">null</span>; e = e.next) {</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="comment">// 找到对应的 key，返回对应的 value</span></span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// key 不存在，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="2-3-删除指定键值：remove-Object-key">
          <a href="#2-3-删除指定键值：remove-Object-key" class="heading-link"><i class="fas fa-link"></i></a>2.3 删除指定键值：remove(Object key)</h4>
      <p>remove 操作类似于 put 操作，都是需要对存储结构进行修改的操作，put 是插入或更新结点，而 remove 则是删除结点，所以都需要进行加锁操作。整个过程同样也分为三个步骤：</p>
<blockquote>
<ol>
<li>计算 key 对应的哈希值</li>
<li>基于 key 的哈希值定位具体的分段 Segment</li>
<li>调用 Segment 对象的 remove 方法执行删除逻辑</li>
</ol>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    <span class="comment">// 1. 计算 key 对应的哈希值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2. 根据 key 的哈希值找到对应的 Segment 对象</span></span><br><span class="line">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">    <span class="comment">// 3. 调用 Segment 对象的 remove 方法执行删除</span></span><br><span class="line">    <span class="keyword">return</span> s == <span class="keyword">null</span> ? <span class="keyword">null</span> : s.remove(key, hash, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>Segment 对象作为具体的锁对象，所以加锁的细节同样位于 Segment 的 remove 方法中（如下），而具体的实现细节比较直观，做代码注释所示，不再过多撰述。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>{</span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryLock()) scanAndLock(key, hash);</span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);  <span class="comment">// 找到 key 对应的 entry</span></span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历 entry 上的链表寻找目标 key</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 找到了目标 key</span></span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) {</span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="comment">// 如果没有制定期望值，或者当前结点的 value 等于期望值，则执行删除逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) {</span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 没有前置结点，则直接将目标结点的 next 结点作为起始节点</span></span><br><span class="line">                        setEntryAt(tab, index, next);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 存在前置结点，则修改前置结点的 next 指向目标结点的 next</span></span><br><span class="line">                        pred.setNext(next);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    --count;</span><br><span class="line">                    oldValue = v;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h4 id="2-4-获取集合的大小：size">
          <a href="#2-4-获取集合的大小：size" class="heading-link"><i class="fas fa-link"></i></a>2.4 获取集合的大小：size()</h4>
      <p>最后我们来一起看一下 size 方法，该方法用于返回当前 map 集合所包含的结点总数目。前面讲解 Segment 类设计的时候，介绍过该类包含一个 count 属性，用于记录分段内结点的总数，并且在具体插入或删除分段内结点时会更新该属性值，那么是不是说这里的 size 方法只需要对所有分段的 count 累加求和返回就行了呢？如果是这样的话那么这里势必要对所有分段加锁，以保证计算的过程中分段内的结构不被更改，否则获取到的 count 极有可能是过期的数据，但是这样的操作性能上将是不太乐观的。</p>
<p>方法 size 的具体实现并没有一上来就加锁，而是先尝试两遍不加锁的累加求和方式，如果两次中所有结点的总数并没有发生变化，则认为计算得到的 size 是可信的，直接返回而不需要加锁，否则再加锁求和也不迟，基于概率统计，这样的设计能够在很大程序上提升整个 ConcurrentHashMap 的性能。具体实现见下面代码注释：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// 标识当前元素总量是否超过 int 类型上限</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// 各个分段内修改数量的总数</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// 记录上一次各个分段内修改数量的总数</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// 重试次数</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) {  <span class="comment">// 达到重试最大次数，逐个锁定分段</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            }</span><br><span class="line">            sum = <span class="number">0L</span>;  <span class="comment">// 记录当前各个分段的修改总量</span></span><br><span class="line">            size = <span class="number">0</span>;  <span class="comment">// 记录所有分段的元素总量</span></span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) {</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) {</span><br><span class="line">                    sum += seg.modCount;  <span class="comment">// 累加分段内修改的次数</span></span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;  <span class="comment">// 累加分段内元素的总量</span></span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;  <span class="comment">// 标识溢出</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 两次检查修改量都没有变化，说明计算的长度 size 可信</span></span><br><span class="line">            last = sum;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果溢出则返回 int 最大值，否则返回真实 size</span></span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>以上主要列举了典型的几个操作的具体实现细节，实际上只要理解了整个 ConcurrentHashMap 的存储结构设计，具体方法的实现源码阅读起来将会简单许多，甚至有时候会觉得就是应该这样编码实现。不得不说锁分段技术是一种很巧妙的设计，简单的技术原理，简单的源码实现，却能够极大的提升并发的性能。</p>
<p>但最后还是要泼一盆凉水，在写作本文时，jdk 1.8 已经发布，1.8 版本的 ConcurrentHashMap 彻底摒弃了锁分段技术，转而采用 CAS 机制，并引入了红黑树以解决链表过长而导致的性能低下问题，所有的改进都是为了性能的提升，不过这也增加了代码的实现复杂度，1.7 版本的 ConcurrentHashMap 源码仅 1600 多行，而 1.8 版本则增加到 6000 多行，如此复杂的实现不得不让人再次敬佩 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Doug_Lea">Doug Lea</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 大师，以后抽时间笔者再来用一篇《<a href="/2019/01/31/java/cas-based-concurrent-hashmap/">基于 CAS 机制的 ConcurrentHashMap 实现内幕</a>》的文章，从源码层面探究 1.8 版本 ConcurrentHashMap 的实现细节。</p>

        <h3 id="参考">
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a>参考</h3>
      <ol>
<li>jdk 1.7 源码</li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692/">java 并发编程实战</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html">探索 ConcurrentHashMap 高并发性的实现机制</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/ConcurrentHashMap/">聊聊并发 — 深入分析 ConcurrentHashMap</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://plotor.github.io">zhenchao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://plotor.github.io/2016/08/16/java/segment-based-concurrent-hashmap/">https://plotor.github.io/2016/08/16/java/segment-based-concurrent-hashmap/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/Java/">Java</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://plotor.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2016/08/23/protocol/x-phase-commit/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">CAP 理论与分阶段提交协议</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2016/08/13/java/java-exception/"><span class="paginator-prev__text">Java 异常处理机制与最佳实践</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">
          一. 存储结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">
          二. 基本方法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%B7%BB%E5%8A%A0%E6%88%96%E6%9B%B4%E6%96%B0%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%9Aput-K-key-V-value"><span class="toc-number">2.1.</span> <span class="toc-text">
          2.1 添加或更新键值对：put(K key, V value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E9%94%AE%E5%80%BC%EF%BC%9Aget-Object-key"><span class="toc-number">2.2.</span> <span class="toc-text">
          2.2 获取指定键值：get(Object key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E9%94%AE%E5%80%BC%EF%BC%9Aremove-Object-key"><span class="toc-number">2.3.</span> <span class="toc-text">
          2.3 删除指定键值：remove(Object key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%8E%B7%E5%8F%96%E9%9B%86%E5%90%88%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9Asize"><span class="toc-number">2.4.</span> <span class="toc-text">
          2.4 获取集合的大小：size()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/author.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">追求技术深度，注重文章质量</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/plotor" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="null" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">95</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">27</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2015~2024</span><span class="footer__devider"></span><span>Zhenchao All Rights Reserved</span><span class="footer__devider">|</span><span>浙ICP备 16010916 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-inner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (true) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script data-pjax="">function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'plotor/hexo-comments');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (true) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (true) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.1"></script><script src="/js/stun-boot.js?v=2.6.1"></script><script src="/js/scroll.js?v=2.6.1"></script><script src="/js/header.js?v=2.6.1"></script><script src="/js/sidebar.js?v=2.6.1"></script><script type="application/json" src="/search.json"></script></body></html>